"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater";
exports.ids = ["vendor-chunks/docxtemplater"];
exports.modules = {

/***/ "(ssr)/./node_modules/docxtemplater/js/collect-content-types.js":
/*!****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/collect-content-types.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n    var partNames = {};\n    for(var i = 0, len = overrides.length; i < len; i++){\n        var override = overrides[i];\n        var contentType = override.getAttribute(\"ContentType\");\n        var partName = override.getAttribute(\"PartName\").substr(1);\n        partNames[partName] = contentType;\n    }\n    var _loop = function _loop() {\n        var def = defaults[_i];\n        var contentType = def.getAttribute(\"ContentType\");\n        var extension = def.getAttribute(\"Extension\");\n        // eslint-disable-next-line no-loop-func\n        zip.file(/./).map(function(_ref) {\n            var name = _ref.name;\n            if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n                partNames[name] = contentType;\n            }\n        });\n    };\n    for(var _i = 0, _len = defaults.length; _i < _len; _i++){\n        _loop();\n    }\n    return partNames;\n}\nmodule.exports = collectContentTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRO0FBQ1osU0FBU0Msb0JBQW9CQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsR0FBRztJQUNuRCxJQUFJQyxZQUFZLENBQUM7SUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1MLFVBQVVNLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUNwRCxJQUFJRyxXQUFXUCxTQUFTLENBQUNJLEVBQUU7UUFDM0IsSUFBSUksY0FBY0QsU0FBU0UsWUFBWSxDQUFDO1FBQ3hDLElBQUlDLFdBQVdILFNBQVNFLFlBQVksQ0FBQyxZQUFZRSxNQUFNLENBQUM7UUFDeERSLFNBQVMsQ0FBQ08sU0FBUyxHQUFHRjtJQUN4QjtJQUNBLElBQUlJLFFBQVEsU0FBU0E7UUFDbkIsSUFBSUMsTUFBTVosUUFBUSxDQUFDYSxHQUFHO1FBQ3RCLElBQUlOLGNBQWNLLElBQUlKLFlBQVksQ0FBQztRQUNuQyxJQUFJTSxZQUFZRixJQUFJSixZQUFZLENBQUM7UUFDakMsd0NBQXdDO1FBQ3hDUCxJQUFJYyxJQUFJLENBQUMsS0FBS0MsR0FBRyxDQUFDLFNBQVVDLElBQUk7WUFDOUIsSUFBSUMsT0FBT0QsS0FBS0MsSUFBSTtZQUNwQixJQUFJQSxLQUFLQyxLQUFLLENBQUNELEtBQUtiLE1BQU0sR0FBR1MsVUFBVVQsTUFBTSxNQUFNUyxhQUFhLENBQUNaLFNBQVMsQ0FBQ2dCLEtBQUssSUFBSUEsU0FBU3JCLE9BQU87Z0JBQ2xHSyxTQUFTLENBQUNnQixLQUFLLEdBQUdYO1lBQ3BCO1FBQ0Y7SUFDRjtJQUNBLElBQUssSUFBSU0sS0FBSyxHQUFHTyxPQUFPcEIsU0FBU0ssTUFBTSxFQUFFUSxLQUFLTyxNQUFNUCxLQUFNO1FBQ3hERjtJQUNGO0lBQ0EsT0FBT1Q7QUFDVDtBQUNBbUIsT0FBT0MsT0FBTyxHQUFHeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanM/NDhiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG5mdW5jdGlvbiBjb2xsZWN0Q29udGVudFR5cGVzKG92ZXJyaWRlcywgZGVmYXVsdHMsIHppcCkge1xuICB2YXIgcGFydE5hbWVzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvdmVycmlkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgb3ZlcnJpZGUgPSBvdmVycmlkZXNbaV07XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiQ29udGVudFR5cGVcIik7XG4gICAgdmFyIHBhcnROYW1lID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiUGFydE5hbWVcIikuc3Vic3RyKDEpO1xuICAgIHBhcnROYW1lc1twYXJ0TmFtZV0gPSBjb250ZW50VHlwZTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNbX2ldO1xuICAgIHZhciBjb250ZW50VHlwZSA9IGRlZi5nZXRBdHRyaWJ1dGUoXCJDb250ZW50VHlwZVwiKTtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZGVmLmdldEF0dHJpYnV0ZShcIkV4dGVuc2lvblwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgemlwLmZpbGUoLy4vKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgaWYgKG5hbWUuc2xpY2UobmFtZS5sZW5ndGggLSBleHRlbnNpb24ubGVuZ3RoKSA9PT0gZXh0ZW5zaW9uICYmICFwYXJ0TmFtZXNbbmFtZV0gJiYgbmFtZSAhPT0gY3RYTUwpIHtcbiAgICAgICAgcGFydE5hbWVzW25hbWVdID0gY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IGRlZmF1bHRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgX2xvb3AoKTtcbiAgfVxuICByZXR1cm4gcGFydE5hbWVzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0Q29udGVudFR5cGVzOyJdLCJuYW1lcyI6WyJjdFhNTCIsImNvbGxlY3RDb250ZW50VHlwZXMiLCJvdmVycmlkZXMiLCJkZWZhdWx0cyIsInppcCIsInBhcnROYW1lcyIsImkiLCJsZW4iLCJsZW5ndGgiLCJvdmVycmlkZSIsImNvbnRlbnRUeXBlIiwiZ2V0QXR0cmlidXRlIiwicGFydE5hbWUiLCJzdWJzdHIiLCJfbG9vcCIsImRlZiIsIl9pIiwiZXh0ZW5zaW9uIiwiZmlsZSIsIm1hcCIsIl9yZWYiLCJuYW1lIiwic2xpY2UiLCJfbGVuIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/collect-content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/content-types.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/content-types.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nmodule.exports = {\n    settingsContentType: settingsContentType,\n    coreContentType: coreContentType,\n    appContentType: appContentType,\n    customContentType: customContentType\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsa0JBQWtCO0FBQ3RCLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsc0JBQXNCO0FBQzFCQyxPQUFPQyxPQUFPLEdBQUc7SUFDZkYscUJBQXFCQTtJQUNyQkgsaUJBQWlCQTtJQUNqQkMsZ0JBQWdCQTtJQUNoQkMsbUJBQW1CQTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2NvbnRlbnQtdHlwZXMuanM/MmM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcmVDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuY29yZS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIGFwcENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWxcIjtcbnZhciBjdXN0b21Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIHNldHRpbmdzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnNldHRpbmdzK3htbFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldHRpbmdzQ29udGVudFR5cGU6IHNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZTogY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZTogYXBwQ29udGVudFR5cGUsXG4gIGN1c3RvbUNvbnRlbnRUeXBlOiBjdXN0b21Db250ZW50VHlwZVxufTsiXSwibmFtZXMiOlsiY29yZUNvbnRlbnRUeXBlIiwiYXBwQ29udGVudFR5cGUiLCJjdXN0b21Db250ZW50VHlwZSIsInNldHRpbmdzQ29udGVudFR5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/doc-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/doc-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/@xmldom/xmldom/lib/index.js\"), DOMParser = _require.DOMParser, XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"), last = _require3.last, first = _require3.first;\nfunction isWhiteSpace(value) {\n    return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n    return {\n        get: function get(scope) {\n            if (tag === \".\") {\n                return scope;\n            }\n            if (scope) {\n                return scope[tag];\n            }\n            return scope;\n        }\n    };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n    var regex;\n    // Stryker disable next-line all : because this is an optimisation\n    if (attrToRegex[attr]) {\n        regex = attrToRegex[attr];\n    } else {\n        regex = new RegExp(\"(<.* \".concat(attr, '=\")([^\"]*)(\".*)$'));\n        attrToRegex[attr] = regex;\n    }\n    if (regex.test(partValue)) {\n        return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n    }\n    var end = partValue.lastIndexOf(\"/>\");\n    if (end === -1) {\n        end = partValue.lastIndexOf(\">\");\n    }\n    return partValue.substr(0, end) + \" \".concat(attr, '=\"').concat(attrValue, '\"') + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n    var index = value.indexOf(\" \".concat(attributeName, '=\"'));\n    if (index === -1) {\n        return null;\n    }\n    var startIndex = value.substr(index).search(/[\"']/) + index;\n    var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n    return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n    return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n    var duplicates = [];\n    var hash = {}, result = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n        if (!hash[arr[i]]) {\n            hash[arr[i]] = true;\n            result.push(arr[i]);\n        } else {\n            duplicates.push(arr[i]);\n        }\n    }\n    return duplicates;\n}\nfunction uniq(arr) {\n    var hash = {}, result = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n        if (!hash[arr[i]]) {\n            hash[arr[i]] = true;\n            result.push(arr[i]);\n        }\n    }\n    return result;\n}\nfunction chunkBy(parsed, f) {\n    return parsed.reduce(function(chunks, p) {\n        var currentChunk = last(chunks);\n        var res = f(p);\n        if (res === \"start\") {\n            chunks.push([\n                p\n            ]);\n        } else if (res === \"end\") {\n            currentChunk.push(p);\n            chunks.push([]);\n        } else {\n            currentChunk.push(p);\n        }\n        return chunks;\n    }, [\n        []\n    ]).filter(function(p) {\n        return p.length > 0;\n    });\n}\nvar defaults = {\n    errorLogging: \"json\",\n    paragraphLoop: false,\n    nullGetter: function nullGetter(part) {\n        return part.module ? \"\" : \"undefined\";\n    },\n    xmlFileNames: [\n        \"[Content_Types].xml\"\n    ],\n    parser: parser,\n    linebreaks: false,\n    fileTypeConfig: null,\n    delimiters: {\n        start: \"{\",\n        end: \"}\"\n    },\n    syntax: {}\n};\nfunction xml2str(xmlNode) {\n    var a = new XMLSerializer();\n    return a.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n    if (str.charCodeAt(0) === 65279) {\n        // BOM sequence\n        str = str.substr(1);\n    }\n    return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [\n    [\n        \"&\",\n        \"&amp;\"\n    ],\n    [\n        \"<\",\n        \"&lt;\"\n    ],\n    [\n        \">\",\n        \"&gt;\"\n    ],\n    [\n        '\"',\n        \"&quot;\"\n    ],\n    [\n        \"'\",\n        \"&apos;\"\n    ]\n];\nvar charMapRegexes = charMap.map(function(_ref) {\n    var _ref2 = _slicedToArray(_ref, 2), endChar = _ref2[0], startChar = _ref2[1];\n    return {\n        rstart: new RegExp(startChar, \"g\"),\n        rend: new RegExp(endChar, \"g\"),\n        start: startChar,\n        end: endChar\n    };\n});\nfunction wordToUtf8(string) {\n    var r;\n    for(var i = charMapRegexes.length - 1; i >= 0; i--){\n        r = charMapRegexes[i];\n        string = string.replace(r.rstart, r.end);\n    }\n    return string;\n}\nfunction utf8ToWord(string) {\n    // To make sure that the object given is a string (this is a noop for strings).\n    string = string.toString();\n    var r;\n    for(var i = 0, l = charMapRegexes.length; i < l; i++){\n        r = charMapRegexes[i];\n        string = string.replace(r.rend, r.start);\n    }\n    return string;\n}\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n    var result = [];\n    for(var i = 0; i < arrays.length; i++){\n        var array = arrays[i];\n        for(var j = 0, len = array.length; j < len; j++){\n            result.push(array[j]);\n        }\n    }\n    return result;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n    return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n    /* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\n  \t\tregex=la\n  \tcontent=lolalolilala\n  \t\treturns:\n  \t\t[\n  \t\t\t{array: {0: 'la'}, offset: 2},\n  \t\t\t{array: {0: 'la'}, offset: 8},\n  \t\t\t{array: {0: 'la'}, offset: 10}\n  \t\t]\n  */ var matchArray = [];\n    var match;\n    while((match = regex.exec(content)) != null){\n        matchArray.push({\n            array: match,\n            offset: match.index\n        });\n    }\n    return matchArray;\n}\nfunction isEnding(value, element) {\n    return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n    return value.indexOf(\"<\" + element) === 0 && [\n        \">\",\n        \" \",\n        \"/\"\n    ].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n    var val = getRightOrNull(parsed, element, index);\n    if (val !== null) {\n        return val;\n    }\n    throwXmlTagNotFound({\n        position: \"right\",\n        element: element,\n        parsed: parsed,\n        index: index\n    });\n}\nfunction getRightOrNull(parsed, elements, index) {\n    if (typeof elements === \"string\") {\n        elements = [\n            elements\n        ];\n    }\n    var level = 1;\n    for(var i = index, l = parsed.length; i < l; i++){\n        var part = parsed[i];\n        for(var j = 0, len = elements.length; j < len; j++){\n            var element = elements[j];\n            if (isEnding(part.value, element)) {\n                level--;\n            }\n            if (isStarting(part.value, element)) {\n                level++;\n            }\n            if (level === 0) {\n                return i;\n            }\n        }\n    }\n    return null;\n}\nfunction getLeft(parsed, element, index) {\n    var val = getLeftOrNull(parsed, element, index);\n    if (val !== null) {\n        return val;\n    }\n    throwXmlTagNotFound({\n        position: \"left\",\n        element: element,\n        parsed: parsed,\n        index: index\n    });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n    if (typeof elements === \"string\") {\n        elements = [\n            elements\n        ];\n    }\n    var level = 1;\n    for(var i = index; i >= 0; i--){\n        var part = parsed[i];\n        for(var j = 0, len = elements.length; j < len; j++){\n            var element = elements[j];\n            if (isStarting(part.value, element)) {\n                level--;\n            }\n            if (isEnding(part.value, element)) {\n                level++;\n            }\n            if (level === 0) {\n                return i;\n            }\n        }\n    }\n    return null;\n}\n// Stryker disable all : because those are functions that depend on the parsed\n// structure based and we don't want minimal code here, but rather code that\n// makes things clear.\nfunction isTagStart(tagType, _ref3) {\n    var type = _ref3.type, tag = _ref3.tag, position = _ref3.position;\n    return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagStartStrict(tagType, _ref4) {\n    var type = _ref4.type, tag = _ref4.tag, position = _ref4.position;\n    return type === \"tag\" && tag === tagType && position === \"start\";\n}\nfunction isTagEnd(tagType, _ref5) {\n    var type = _ref5.type, tag = _ref5.tag, position = _ref5.position;\n    return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(part) {\n    return isTagStartStrict(\"w:p\", part) || isTagStartStrict(\"a:p\", part);\n}\nfunction isParagraphEnd(part) {\n    return isTagEnd(\"w:p\", part) || isTagEnd(\"a:p\", part);\n}\nfunction isTextStart(_ref6) {\n    var type = _ref6.type, position = _ref6.position, text = _ref6.text;\n    return type === \"tag\" && position === \"start\" && text;\n}\nfunction isTextEnd(_ref7) {\n    var type = _ref7.type, position = _ref7.position, text = _ref7.text;\n    return type === \"tag\" && position === \"end\" && text;\n}\nfunction isContent(_ref8) {\n    var type = _ref8.type, position = _ref8.position;\n    return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref9, modules) {\n    var module1 = _ref9.module, type = _ref9.type;\n    if (!(modules instanceof Array)) {\n        modules = [\n            modules\n        ];\n    }\n    return type === \"placeholder\" && modules.indexOf(module1) !== -1;\n}\n// Stryker restore all\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;\n// 00    NUL '\\0' (null character)\n// 01    SOH (start of heading)\n// 02    STX (start of text)\n// 03    ETX (end of text)\n// 04    EOT (end of transmission)\n// 05    ENQ (enquiry)\n// 06    ACK (acknowledge)\n// 07    BEL '\\a' (bell)\n// 08    BS  '\\b' (backspace)\n// 0B    VT  '\\v' (vertical tab)\n// 0C    FF  '\\f' (form feed)\n// 0E    SO  (shift out)\n// 0F    SI  (shift in)\n// 10    DLE (data link escape)\n// 11    DC1 (device control 1)\n// 12    DC2 (device control 2)\n// 13    DC3 (device control 3)\n// 14    DC4 (device control 4)\n// 15    NAK (negative ack.)\n// 16    SYN (synchronous idle)\n// 17    ETB (end of trans. blk)\n// 18    CAN (cancel)\n// 19    EM  (end of medium)\n// 1A    SUB (substitute)\n// 1B    ESC (escape)\n// 1C    FS  (file separator)\n// 1D    GS  (group separator)\n// 1E    RS  (record separator)\n// 1F    US  (unit separator)\nfunction hasCorruptCharacters(string) {\n    return corruptCharacters.test(string);\n}\nfunction invertMap(map) {\n    return Object.keys(map).reduce(function(invertedMap, key) {\n        var value = map[key];\n        invertedMap[value] = invertedMap[value] || [];\n        invertedMap[value].push(key);\n        return invertedMap;\n    }, {});\n}\n// This ensures that the sort is stable. The default Array.sort of the browser\n// is not stable in firefox, as the JS spec does not enforce the sort to be\n// stable.\nfunction stableSort(arr, compare) {\n    // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n    return arr.map(function(item, index) {\n        return {\n            item: item,\n            index: index\n        };\n    }).sort(function(a, b) {\n        return compare(a.item, b.item) || a.index - b.index;\n    }).map(function(_ref10) {\n        var item = _ref10.item;\n        return item;\n    });\n// Stryker restore all\n}\nmodule.exports = {\n    endsWith: endsWith,\n    startsWith: startsWith,\n    isContent: isContent,\n    isParagraphStart: isParagraphStart,\n    isParagraphEnd: isParagraphEnd,\n    isTagStart: isTagStart,\n    isTagEnd: isTagEnd,\n    isTextStart: isTextStart,\n    isTextEnd: isTextEnd,\n    isStarting: isStarting,\n    isEnding: isEnding,\n    isModule: isModule,\n    uniq: uniq,\n    getDuplicates: getDuplicates,\n    chunkBy: chunkBy,\n    last: last,\n    first: first,\n    xml2str: xml2str,\n    str2xml: str2xml,\n    getRightOrNull: getRightOrNull,\n    getRight: getRight,\n    getLeftOrNull: getLeftOrNull,\n    getLeft: getLeft,\n    pregMatchAll: pregMatchAll,\n    convertSpaces: convertSpaces,\n    charMapRegexes: charMapRegexes,\n    hasCorruptCharacters: hasCorruptCharacters,\n    defaults: defaults,\n    wordToUtf8: wordToUtf8,\n    utf8ToWord: utf8ToWord,\n    concatArrays: concatArrays,\n    invertMap: invertMap,\n    charMap: charMap,\n    getSingleAttribute: getSingleAttribute,\n    setSingleAttribute: setSingleAttribute,\n    isWhiteSpace: isWhiteSpace,\n    stableSort: stableSort\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxlQUFlQyxHQUFHLEVBQUVDLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JGLFFBQVFHLHNCQUFzQkgsS0FBS0MsTUFBTUcsNEJBQTRCSixLQUFLQyxNQUFNSTtBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCRyxDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPRSxrQkFBa0JGLEdBQUdDO0lBQVMsSUFBSUUsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1AsR0FBR1EsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlMLE1BQU0sWUFBWUgsRUFBRVMsV0FBVyxFQUFFTixJQUFJSCxFQUFFUyxXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJUCxNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPUSxNQUFNQyxJQUFJLENBQUNaO0lBQUksSUFBSUcsTUFBTSxlQUFlLDJDQUEyQ1UsSUFBSSxDQUFDVixJQUFJLE9BQU9ELGtCQUFrQkYsR0FBR0M7QUFBUztBQUMvWixTQUFTQyxrQkFBa0JULEdBQUcsRUFBRXFCLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1yQixJQUFJc0IsTUFBTSxFQUFFRCxNQUFNckIsSUFBSXNCLE1BQU07SUFBRSxJQUFLLElBQUlyQixJQUFJLEdBQUdzQixPQUFPLElBQUlMLE1BQU1HLE1BQU1wQixJQUFJb0IsS0FBS3BCLElBQUtzQixJQUFJLENBQUN0QixFQUFFLEdBQUdELEdBQUcsQ0FBQ0MsRUFBRTtJQUFFLE9BQU9zQjtBQUFNO0FBQ2xMLFNBQVNwQixzQkFBc0JxQixDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJLFFBQVFGLElBQUksT0FBTyxlQUFlLE9BQU9HLFVBQVVILENBQUMsQ0FBQ0csT0FBT0MsUUFBUSxDQUFDLElBQUlKLENBQUMsQ0FBQyxhQUFhO0lBQUUsSUFBSSxRQUFRRSxHQUFHO1FBQUUsSUFBSUcsR0FBR25CLEdBQUdULEdBQUc2QixHQUFHQyxJQUFJLEVBQUUsRUFBRUMsSUFBSSxDQUFDLEdBQUd6QixJQUFJLENBQUM7UUFBRyxJQUFJO1lBQUUsSUFBSU4sSUFBSSxDQUFDeUIsSUFBSUEsRUFBRVosSUFBSSxDQUFDVSxFQUFDLEVBQUdTLElBQUksRUFBRSxNQUFNUixHQUFHO2dCQUFFLElBQUlkLE9BQU9lLE9BQU9BLEdBQUc7Z0JBQVFNLElBQUksQ0FBQztZQUFHLE9BQU8sTUFBTyxDQUFFQSxDQUFBQSxJQUFJLENBQUNILElBQUk1QixFQUFFYSxJQUFJLENBQUNZLEVBQUMsRUFBR1EsSUFBSSxLQUFNSCxDQUFBQSxFQUFFSSxJQUFJLENBQUNOLEVBQUVPLEtBQUssR0FBR0wsRUFBRVQsTUFBTSxLQUFLRyxDQUFBQSxHQUFJTyxJQUFJLENBQUM7UUFBSSxFQUFFLE9BQU9SLEdBQUc7WUFBRWpCLElBQUksQ0FBQyxHQUFHRyxJQUFJYztRQUFHLFNBQVU7WUFBRSxJQUFJO2dCQUFFLElBQUksQ0FBQ1EsS0FBSyxRQUFRTixDQUFDLENBQUMsU0FBUyxJQUFLSSxDQUFBQSxJQUFJSixDQUFDLENBQUMsU0FBUyxJQUFJZixPQUFPbUIsT0FBT0EsQ0FBQUEsR0FBSTtZQUFRLFNBQVU7Z0JBQUUsSUFBSXZCLEdBQUcsTUFBTUc7WUFBRztRQUFFO1FBQUUsT0FBT3FCO0lBQUc7QUFBRTtBQUN6aEIsU0FBUzdCLGdCQUFnQkYsR0FBRztJQUFJLElBQUlrQixNQUFNbUIsT0FBTyxDQUFDckMsTUFBTSxPQUFPQTtBQUFLO0FBQ3BFLElBQUlzQyxXQUFXQyxtQkFBT0EsQ0FBQyx3RUFBZ0IsR0FDckNDLFlBQVlGLFNBQVNFLFNBQVMsRUFDOUJDLGdCQUFnQkgsU0FBU0csYUFBYTtBQUN4QyxJQUFJQyxZQUFZSCxtQkFBT0EsQ0FBQyxvRUFBYSxHQUNuQ0ksc0JBQXNCRCxVQUFVQyxtQkFBbUI7QUFDckQsSUFBSUMsWUFBWUwsbUJBQU9BLENBQUMsa0VBQVksR0FDbENNLE9BQU9ELFVBQVVDLElBQUksRUFDckJDLFFBQVFGLFVBQVVFLEtBQUs7QUFDekIsU0FBU0MsYUFBYVgsS0FBSztJQUN6QixPQUFPLGVBQWVoQixJQUFJLENBQUNnQjtBQUM3QjtBQUNBLFNBQVNZLE9BQU9DLEdBQUc7SUFDakIsT0FBTztRQUNMQyxLQUFLLFNBQVNBLElBQUlDLEtBQUs7WUFDckIsSUFBSUYsUUFBUSxLQUFLO2dCQUNmLE9BQU9FO1lBQ1Q7WUFDQSxJQUFJQSxPQUFPO2dCQUNULE9BQU9BLEtBQUssQ0FBQ0YsSUFBSTtZQUNuQjtZQUNBLE9BQU9FO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsSUFBSUMsY0FBYyxDQUFDO0FBQ25CLFNBQVNDLG1CQUFtQkMsU0FBUyxFQUFFQyxJQUFJLEVBQUVDLFNBQVM7SUFDcEQsSUFBSUM7SUFDSixrRUFBa0U7SUFDbEUsSUFBSUwsV0FBVyxDQUFDRyxLQUFLLEVBQUU7UUFDckJFLFFBQVFMLFdBQVcsQ0FBQ0csS0FBSztJQUMzQixPQUFPO1FBQ0xFLFFBQVEsSUFBSUMsT0FBTyxRQUFRQyxNQUFNLENBQUNKLE1BQU07UUFDeENILFdBQVcsQ0FBQ0csS0FBSyxHQUFHRTtJQUN0QjtJQUNBLElBQUlBLE1BQU1yQyxJQUFJLENBQUNrQyxZQUFZO1FBQ3pCLE9BQU9BLFVBQVVNLE9BQU8sQ0FBQ0gsT0FBTyxLQUFLRSxNQUFNLENBQUNILFdBQVc7SUFDekQ7SUFDQSxJQUFJSyxNQUFNUCxVQUFVUSxXQUFXLENBQUM7SUFDaEMsSUFBSUQsUUFBUSxDQUFDLEdBQUc7UUFDZEEsTUFBTVAsVUFBVVEsV0FBVyxDQUFDO0lBQzlCO0lBQ0EsT0FBT1IsVUFBVVMsTUFBTSxDQUFDLEdBQUdGLE9BQU8sSUFBSUYsTUFBTSxDQUFDSixNQUFNLE1BQU9JLE1BQU0sQ0FBQ0gsV0FBVyxPQUFRRixVQUFVUyxNQUFNLENBQUNGO0FBQ3ZHO0FBQ0EsU0FBU0csbUJBQW1CNUIsS0FBSyxFQUFFNkIsYUFBYTtJQUM5QyxJQUFJQyxRQUFROUIsTUFBTStCLE9BQU8sQ0FBQyxJQUFJUixNQUFNLENBQUNNLGVBQWU7SUFDcEQsSUFBSUMsVUFBVSxDQUFDLEdBQUc7UUFDaEIsT0FBTztJQUNUO0lBQ0EsSUFBSUUsYUFBYWhDLE1BQU0yQixNQUFNLENBQUNHLE9BQU9HLE1BQU0sQ0FBQyxVQUFVSDtJQUN0RCxJQUFJSSxXQUFXbEMsTUFBTTJCLE1BQU0sQ0FBQ0ssYUFBYSxHQUFHQyxNQUFNLENBQUMsVUFBVUQ7SUFDN0QsT0FBT2hDLE1BQU0yQixNQUFNLENBQUNLLGFBQWEsR0FBR0UsV0FBV0Y7QUFDakQ7QUFDQSxTQUFTRyxTQUFTQyxHQUFHLEVBQUVDLE1BQU07SUFDM0IsT0FBT0QsSUFBSUwsT0FBTyxDQUFDTSxRQUFRRCxJQUFJbEQsTUFBTSxHQUFHbUQsT0FBT25ELE1BQU0sTUFBTSxDQUFDO0FBQzlEO0FBQ0EsU0FBU29ELFdBQVdGLEdBQUcsRUFBRUcsTUFBTTtJQUM3QixPQUFPSCxJQUFJSSxTQUFTLENBQUMsR0FBR0QsT0FBT3JELE1BQU0sTUFBTXFEO0FBQzdDO0FBQ0EsU0FBU0UsY0FBYzdFLEdBQUc7SUFDeEIsSUFBSThFLGFBQWEsRUFBRTtJQUNuQixJQUFJQyxPQUFPLENBQUMsR0FDVkMsU0FBUyxFQUFFO0lBQ2IsSUFBSyxJQUFJL0UsSUFBSSxHQUFHd0IsSUFBSXpCLElBQUlzQixNQUFNLEVBQUVyQixJQUFJd0IsR0FBRyxFQUFFeEIsRUFBRztRQUMxQyxJQUFJLENBQUM4RSxJQUFJLENBQUMvRSxHQUFHLENBQUNDLEVBQUUsQ0FBQyxFQUFFO1lBQ2pCOEUsSUFBSSxDQUFDL0UsR0FBRyxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUNmK0UsT0FBTzdDLElBQUksQ0FBQ25DLEdBQUcsQ0FBQ0MsRUFBRTtRQUNwQixPQUFPO1lBQ0w2RSxXQUFXM0MsSUFBSSxDQUFDbkMsR0FBRyxDQUFDQyxFQUFFO1FBQ3hCO0lBQ0Y7SUFDQSxPQUFPNkU7QUFDVDtBQUNBLFNBQVNHLEtBQUtqRixHQUFHO0lBQ2YsSUFBSStFLE9BQU8sQ0FBQyxHQUNWQyxTQUFTLEVBQUU7SUFDYixJQUFLLElBQUkvRSxJQUFJLEdBQUd3QixJQUFJekIsSUFBSXNCLE1BQU0sRUFBRXJCLElBQUl3QixHQUFHLEVBQUV4QixFQUFHO1FBQzFDLElBQUksQ0FBQzhFLElBQUksQ0FBQy9FLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDLEVBQUU7WUFDakI4RSxJQUFJLENBQUMvRSxHQUFHLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQ2YrRSxPQUFPN0MsSUFBSSxDQUFDbkMsR0FBRyxDQUFDQyxFQUFFO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPK0U7QUFDVDtBQUNBLFNBQVNFLFFBQVFDLE1BQU0sRUFBRW5ELENBQUM7SUFDeEIsT0FBT21ELE9BQU9DLE1BQU0sQ0FBQyxTQUFVQyxNQUFNLEVBQUVDLENBQUM7UUFDdEMsSUFBSUMsZUFBZTFDLEtBQUt3QztRQUN4QixJQUFJRyxNQUFNeEQsRUFBRXNEO1FBQ1osSUFBSUUsUUFBUSxTQUFTO1lBQ25CSCxPQUFPbEQsSUFBSSxDQUFDO2dCQUFDbUQ7YUFBRTtRQUNqQixPQUFPLElBQUlFLFFBQVEsT0FBTztZQUN4QkQsYUFBYXBELElBQUksQ0FBQ21EO1lBQ2xCRCxPQUFPbEQsSUFBSSxDQUFDLEVBQUU7UUFDaEIsT0FBTztZQUNMb0QsYUFBYXBELElBQUksQ0FBQ21EO1FBQ3BCO1FBQ0EsT0FBT0Q7SUFDVCxHQUFHO1FBQUMsRUFBRTtLQUFDLEVBQUVJLE1BQU0sQ0FBQyxTQUFVSCxDQUFDO1FBQ3pCLE9BQU9BLEVBQUVoRSxNQUFNLEdBQUc7SUFDcEI7QUFDRjtBQUNBLElBQUlvRSxXQUFXO0lBQ2JDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxZQUFZLFNBQVNBLFdBQVdDLElBQUk7UUFDbEMsT0FBT0EsS0FBS0MsTUFBTSxHQUFHLEtBQUs7SUFDNUI7SUFDQUMsY0FBYztRQUFDO0tBQXNCO0lBQ3JDaEQsUUFBUUE7SUFDUmlELFlBQVk7SUFDWkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO1FBQ1ZDLE9BQU87UUFDUHZDLEtBQUs7SUFDUDtJQUNBd0MsUUFBUSxDQUFDO0FBQ1g7QUFDQSxTQUFTQyxRQUFRQyxPQUFPO0lBQ3RCLElBQUl4RSxJQUFJLElBQUlVO0lBQ1osT0FBT1YsRUFBRXlFLGlCQUFpQixDQUFDRCxTQUFTM0MsT0FBTyxDQUFDLDRCQUE0QjtBQUMxRTtBQUNBLFNBQVM2QyxRQUFRakMsR0FBRztJQUNsQixJQUFJQSxJQUFJa0MsVUFBVSxDQUFDLE9BQU8sT0FBTztRQUMvQixlQUFlO1FBQ2ZsQyxNQUFNQSxJQUFJVCxNQUFNLENBQUM7SUFDbkI7SUFDQSxPQUFPLElBQUl2QixZQUFZbUUsZUFBZSxDQUFDbkMsS0FBSztBQUM5QztBQUNBLElBQUlvQyxVQUFVO0lBQUM7UUFBQztRQUFLO0tBQVE7SUFBRTtRQUFDO1FBQUs7S0FBTztJQUFFO1FBQUM7UUFBSztLQUFPO0lBQUU7UUFBQztRQUFLO0tBQVM7SUFBRTtRQUFDO1FBQUs7S0FBUztDQUFDO0FBQzlGLElBQUlDLGlCQUFpQkQsUUFBUUUsR0FBRyxDQUFDLFNBQVVDLElBQUk7SUFDN0MsSUFBSUMsUUFBUWpILGVBQWVnSCxNQUFNLElBQy9CRSxVQUFVRCxLQUFLLENBQUMsRUFBRSxFQUNsQkUsWUFBWUYsS0FBSyxDQUFDLEVBQUU7SUFDdEIsT0FBTztRQUNMRyxRQUFRLElBQUl6RCxPQUFPd0QsV0FBVztRQUM5QkUsTUFBTSxJQUFJMUQsT0FBT3VELFNBQVM7UUFDMUJiLE9BQU9jO1FBQ1ByRCxLQUFLb0Q7SUFDUDtBQUNGO0FBQ0EsU0FBU0ksV0FBV0MsTUFBTTtJQUN4QixJQUFJOUY7SUFDSixJQUFLLElBQUl2QixJQUFJNEcsZUFBZXZGLE1BQU0sR0FBRyxHQUFHckIsS0FBSyxHQUFHQSxJQUFLO1FBQ25EdUIsSUFBSXFGLGNBQWMsQ0FBQzVHLEVBQUU7UUFDckJxSCxTQUFTQSxPQUFPMUQsT0FBTyxDQUFDcEMsRUFBRTJGLE1BQU0sRUFBRTNGLEVBQUVxQyxHQUFHO0lBQ3pDO0lBQ0EsT0FBT3lEO0FBQ1Q7QUFDQSxTQUFTQyxXQUFXRCxNQUFNO0lBQ3hCLCtFQUErRTtJQUMvRUEsU0FBU0EsT0FBT3pHLFFBQVE7SUFDeEIsSUFBSVc7SUFDSixJQUFLLElBQUl2QixJQUFJLEdBQUd3QixJQUFJb0YsZUFBZXZGLE1BQU0sRUFBRXJCLElBQUl3QixHQUFHeEIsSUFBSztRQUNyRHVCLElBQUlxRixjQUFjLENBQUM1RyxFQUFFO1FBQ3JCcUgsU0FBU0EsT0FBTzFELE9BQU8sQ0FBQ3BDLEVBQUU0RixJQUFJLEVBQUU1RixFQUFFNEUsS0FBSztJQUN6QztJQUNBLE9BQU9rQjtBQUNUO0FBRUEsMERBQTBEO0FBQzFELFNBQVNFLGFBQWFDLE1BQU07SUFDMUIsSUFBSXpDLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSS9FLElBQUksR0FBR0EsSUFBSXdILE9BQU9uRyxNQUFNLEVBQUVyQixJQUFLO1FBQ3RDLElBQUl5SCxRQUFRRCxNQUFNLENBQUN4SCxFQUFFO1FBQ3JCLElBQUssSUFBSTBILElBQUksR0FBR3RHLE1BQU1xRyxNQUFNcEcsTUFBTSxFQUFFcUcsSUFBSXRHLEtBQUtzRyxJQUFLO1lBQ2hEM0MsT0FBTzdDLElBQUksQ0FBQ3VGLEtBQUssQ0FBQ0MsRUFBRTtRQUN0QjtJQUNGO0lBQ0EsT0FBTzNDO0FBQ1Q7QUFDQSxJQUFJNEMsY0FBYyxJQUFJbEUsT0FBT21FLE9BQU9DLFlBQVksQ0FBQyxNQUFNO0FBQ3ZELFNBQVNDLGNBQWNDLENBQUM7SUFDdEIsT0FBT0EsRUFBRXBFLE9BQU8sQ0FBQ2dFLGFBQWE7QUFDaEM7QUFDQSxTQUFTSyxhQUFheEUsS0FBSyxFQUFFeUUsT0FBTztJQUNsQzs7Ozs7Ozs7O0VBU0EsR0FDQSxJQUFJQyxhQUFhLEVBQUU7SUFDbkIsSUFBSUM7SUFDSixNQUFPLENBQUNBLFFBQVEzRSxNQUFNNEUsSUFBSSxDQUFDSCxRQUFPLEtBQU0sS0FBTTtRQUM1Q0MsV0FBV2hHLElBQUksQ0FBQztZQUNkdUYsT0FBT1U7WUFDUEUsUUFBUUYsTUFBTWxFLEtBQUs7UUFDckI7SUFDRjtJQUNBLE9BQU9pRTtBQUNUO0FBQ0EsU0FBU0ksU0FBU25HLEtBQUssRUFBRW9HLE9BQU87SUFDOUIsT0FBT3BHLFVBQVUsT0FBT29HLFVBQVU7QUFDcEM7QUFDQSxTQUFTQyxXQUFXckcsS0FBSyxFQUFFb0csT0FBTztJQUNoQyxPQUFPcEcsTUFBTStCLE9BQU8sQ0FBQyxNQUFNcUUsYUFBYSxLQUFLO1FBQUM7UUFBSztRQUFLO0tBQUksQ0FBQ3JFLE9BQU8sQ0FBQy9CLEtBQUssQ0FBQ29HLFFBQVFsSCxNQUFNLEdBQUcsRUFBRSxNQUFNLENBQUM7QUFDdkc7QUFDQSxTQUFTb0gsU0FBU3ZELE1BQU0sRUFBRXFELE9BQU8sRUFBRXRFLEtBQUs7SUFDdEMsSUFBSXlFLE1BQU1DLGVBQWV6RCxRQUFRcUQsU0FBU3RFO0lBQzFDLElBQUl5RSxRQUFRLE1BQU07UUFDaEIsT0FBT0E7SUFDVDtJQUNBaEcsb0JBQW9CO1FBQ2xCa0csVUFBVTtRQUNWTCxTQUFTQTtRQUNUckQsUUFBUUE7UUFDUmpCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVMwRSxlQUFlekQsTUFBTSxFQUFFMkQsUUFBUSxFQUFFNUUsS0FBSztJQUM3QyxJQUFJLE9BQU80RSxhQUFhLFVBQVU7UUFDaENBLFdBQVc7WUFBQ0E7U0FBUztJQUN2QjtJQUNBLElBQUlDLFFBQVE7SUFDWixJQUFLLElBQUk5SSxJQUFJaUUsT0FBT3pDLElBQUkwRCxPQUFPN0QsTUFBTSxFQUFFckIsSUFBSXdCLEdBQUd4QixJQUFLO1FBQ2pELElBQUk2RixPQUFPWCxNQUFNLENBQUNsRixFQUFFO1FBQ3BCLElBQUssSUFBSTBILElBQUksR0FBR3RHLE1BQU15SCxTQUFTeEgsTUFBTSxFQUFFcUcsSUFBSXRHLEtBQUtzRyxJQUFLO1lBQ25ELElBQUlhLFVBQVVNLFFBQVEsQ0FBQ25CLEVBQUU7WUFDekIsSUFBSVksU0FBU3pDLEtBQUsxRCxLQUFLLEVBQUVvRyxVQUFVO2dCQUNqQ087WUFDRjtZQUNBLElBQUlOLFdBQVczQyxLQUFLMUQsS0FBSyxFQUFFb0csVUFBVTtnQkFDbkNPO1lBQ0Y7WUFDQSxJQUFJQSxVQUFVLEdBQUc7Z0JBQ2YsT0FBTzlJO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUytJLFFBQVE3RCxNQUFNLEVBQUVxRCxPQUFPLEVBQUV0RSxLQUFLO0lBQ3JDLElBQUl5RSxNQUFNTSxjQUFjOUQsUUFBUXFELFNBQVN0RTtJQUN6QyxJQUFJeUUsUUFBUSxNQUFNO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFDQWhHLG9CQUFvQjtRQUNsQmtHLFVBQVU7UUFDVkwsU0FBU0E7UUFDVHJELFFBQVFBO1FBQ1JqQixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxTQUFTK0UsY0FBYzlELE1BQU0sRUFBRTJELFFBQVEsRUFBRTVFLEtBQUs7SUFDNUMsSUFBSSxPQUFPNEUsYUFBYSxVQUFVO1FBQ2hDQSxXQUFXO1lBQUNBO1NBQVM7SUFDdkI7SUFDQSxJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJOUksSUFBSWlFLE9BQU9qRSxLQUFLLEdBQUdBLElBQUs7UUFDL0IsSUFBSTZGLE9BQU9YLE1BQU0sQ0FBQ2xGLEVBQUU7UUFDcEIsSUFBSyxJQUFJMEgsSUFBSSxHQUFHdEcsTUFBTXlILFNBQVN4SCxNQUFNLEVBQUVxRyxJQUFJdEcsS0FBS3NHLElBQUs7WUFDbkQsSUFBSWEsVUFBVU0sUUFBUSxDQUFDbkIsRUFBRTtZQUN6QixJQUFJYyxXQUFXM0MsS0FBSzFELEtBQUssRUFBRW9HLFVBQVU7Z0JBQ25DTztZQUNGO1lBQ0EsSUFBSVIsU0FBU3pDLEtBQUsxRCxLQUFLLEVBQUVvRyxVQUFVO2dCQUNqQ087WUFDRjtZQUNBLElBQUlBLFVBQVUsR0FBRztnQkFDZixPQUFPOUk7WUFDVDtRQUNGO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQSw4RUFBOEU7QUFDOUUsNEVBQTRFO0FBQzVFLHNCQUFzQjtBQUN0QixTQUFTaUosV0FBV0MsT0FBTyxFQUFFQyxLQUFLO0lBQ2hDLElBQUlDLE9BQU9ELE1BQU1DLElBQUksRUFDbkJwRyxNQUFNbUcsTUFBTW5HLEdBQUcsRUFDZjRGLFdBQVdPLE1BQU1QLFFBQVE7SUFDM0IsT0FBT1EsU0FBUyxTQUFTcEcsUUFBUWtHLFdBQVlOLENBQUFBLGFBQWEsV0FBV0EsYUFBYSxhQUFZO0FBQ2hHO0FBQ0EsU0FBU1MsaUJBQWlCSCxPQUFPLEVBQUVJLEtBQUs7SUFDdEMsSUFBSUYsT0FBT0UsTUFBTUYsSUFBSSxFQUNuQnBHLE1BQU1zRyxNQUFNdEcsR0FBRyxFQUNmNEYsV0FBV1UsTUFBTVYsUUFBUTtJQUMzQixPQUFPUSxTQUFTLFNBQVNwRyxRQUFRa0csV0FBV04sYUFBYTtBQUMzRDtBQUNBLFNBQVNXLFNBQVNMLE9BQU8sRUFBRU0sS0FBSztJQUM5QixJQUFJSixPQUFPSSxNQUFNSixJQUFJLEVBQ25CcEcsTUFBTXdHLE1BQU14RyxHQUFHLEVBQ2Y0RixXQUFXWSxNQUFNWixRQUFRO0lBQzNCLE9BQU9RLFNBQVMsU0FBU3BHLFFBQVFrRyxXQUFXTixhQUFhO0FBQzNEO0FBQ0EsU0FBU2EsaUJBQWlCNUQsSUFBSTtJQUM1QixPQUFPd0QsaUJBQWlCLE9BQU94RCxTQUFTd0QsaUJBQWlCLE9BQU94RDtBQUNsRTtBQUNBLFNBQVM2RCxlQUFlN0QsSUFBSTtJQUMxQixPQUFPMEQsU0FBUyxPQUFPMUQsU0FBUzBELFNBQVMsT0FBTzFEO0FBQ2xEO0FBQ0EsU0FBUzhELFlBQVlDLEtBQUs7SUFDeEIsSUFBSVIsT0FBT1EsTUFBTVIsSUFBSSxFQUNuQlIsV0FBV2dCLE1BQU1oQixRQUFRLEVBQ3pCaUIsT0FBT0QsTUFBTUMsSUFBSTtJQUNuQixPQUFPVCxTQUFTLFNBQVNSLGFBQWEsV0FBV2lCO0FBQ25EO0FBQ0EsU0FBU0MsVUFBVUMsS0FBSztJQUN0QixJQUFJWCxPQUFPVyxNQUFNWCxJQUFJLEVBQ25CUixXQUFXbUIsTUFBTW5CLFFBQVEsRUFDekJpQixPQUFPRSxNQUFNRixJQUFJO0lBQ25CLE9BQU9ULFNBQVMsU0FBU1IsYUFBYSxTQUFTaUI7QUFDakQ7QUFDQSxTQUFTRyxVQUFVQyxLQUFLO0lBQ3RCLElBQUliLE9BQU9hLE1BQU1iLElBQUksRUFDbkJSLFdBQVdxQixNQUFNckIsUUFBUTtJQUMzQixPQUFPUSxTQUFTLGlCQUFpQkEsU0FBUyxhQUFhUixhQUFhO0FBQ3RFO0FBQ0EsU0FBU3NCLFNBQVNDLEtBQUssRUFBRUMsT0FBTztJQUM5QixJQUFJdEUsVUFBU3FFLE1BQU1yRSxNQUFNLEVBQ3ZCc0QsT0FBT2UsTUFBTWYsSUFBSTtJQUNuQixJQUFJLENBQUVnQixDQUFBQSxtQkFBbUJuSixLQUFJLEdBQUk7UUFDL0JtSixVQUFVO1lBQUNBO1NBQVE7SUFDckI7SUFDQSxPQUFPaEIsU0FBUyxpQkFBaUJnQixRQUFRbEcsT0FBTyxDQUFDNEIsYUFBWSxDQUFDO0FBQ2hFO0FBQ0Esc0JBQXNCO0FBRXRCLElBQUl1RSxvQkFBb0I7QUFDeEIsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLGtDQUFrQztBQUNsQyxzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixTQUFTQyxxQkFBcUJqRCxNQUFNO0lBQ2xDLE9BQU9nRCxrQkFBa0JsSixJQUFJLENBQUNrRztBQUNoQztBQUNBLFNBQVNrRCxVQUFVMUQsR0FBRztJQUNwQixPQUFPbkcsT0FBTzhKLElBQUksQ0FBQzNELEtBQUsxQixNQUFNLENBQUMsU0FBVXNGLFdBQVcsRUFBRUMsR0FBRztRQUN2RCxJQUFJdkksUUFBUTBFLEdBQUcsQ0FBQzZELElBQUk7UUFDcEJELFdBQVcsQ0FBQ3RJLE1BQU0sR0FBR3NJLFdBQVcsQ0FBQ3RJLE1BQU0sSUFBSSxFQUFFO1FBQzdDc0ksV0FBVyxDQUFDdEksTUFBTSxDQUFDRCxJQUFJLENBQUN3STtRQUN4QixPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBQ0EsOEVBQThFO0FBQzlFLDJFQUEyRTtBQUMzRSxVQUFVO0FBQ1YsU0FBU0UsV0FBVzVLLEdBQUcsRUFBRTZLLE9BQU87SUFDOUIsK0pBQStKO0lBQy9KLE9BQU83SyxJQUFJOEcsR0FBRyxDQUFDLFNBQVVnRSxJQUFJLEVBQUU1RyxLQUFLO1FBQ2xDLE9BQU87WUFDTDRHLE1BQU1BO1lBQ041RyxPQUFPQTtRQUNUO0lBQ0YsR0FBRzZHLElBQUksQ0FBQyxTQUFVaEosQ0FBQyxFQUFFaUosQ0FBQztRQUNwQixPQUFPSCxRQUFROUksRUFBRStJLElBQUksRUFBRUUsRUFBRUYsSUFBSSxLQUFLL0ksRUFBRW1DLEtBQUssR0FBRzhHLEVBQUU5RyxLQUFLO0lBQ3JELEdBQUc0QyxHQUFHLENBQUMsU0FBVW1FLE1BQU07UUFDckIsSUFBSUgsT0FBT0csT0FBT0gsSUFBSTtRQUN0QixPQUFPQTtJQUNUO0FBQ0Esc0JBQXNCO0FBQ3hCO0FBQ0EvRSxPQUFPbUYsT0FBTyxHQUFHO0lBQ2YzRyxVQUFVQTtJQUNWRyxZQUFZQTtJQUNadUYsV0FBV0E7SUFDWFAsa0JBQWtCQTtJQUNsQkMsZ0JBQWdCQTtJQUNoQlQsWUFBWUE7SUFDWk0sVUFBVUE7SUFDVkksYUFBYUE7SUFDYkcsV0FBV0E7SUFDWHRCLFlBQVlBO0lBQ1pGLFVBQVVBO0lBQ1Y0QixVQUFVQTtJQUNWbEYsTUFBTUE7SUFDTkosZUFBZUE7SUFDZkssU0FBU0E7SUFDVHJDLE1BQU1BO0lBQ05DLE9BQU9BO0lBQ1B3RCxTQUFTQTtJQUNURyxTQUFTQTtJQUNUbUMsZ0JBQWdCQTtJQUNoQkYsVUFBVUE7SUFDVk8sZUFBZUE7SUFDZkQsU0FBU0E7SUFDVGYsY0FBY0E7SUFDZEYsZUFBZUE7SUFDZmxCLGdCQUFnQkE7SUFDaEIwRCxzQkFBc0JBO0lBQ3RCN0UsVUFBVUE7SUFDVjJCLFlBQVlBO0lBQ1pFLFlBQVlBO0lBQ1pDLGNBQWNBO0lBQ2RnRCxXQUFXQTtJQUNYNUQsU0FBU0E7SUFDVDVDLG9CQUFvQkE7SUFDcEJYLG9CQUFvQkE7SUFDcEJOLGNBQWNBO0lBQ2Q2SCxZQUFZQTtBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jLXV0aWxzLmpzP2YwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIkB4bWxkb20veG1sZG9tXCIpLFxuICBET01QYXJzZXIgPSBfcmVxdWlyZS5ET01QYXJzZXIsXG4gIFhNTFNlcmlhbGl6ZXIgPSBfcmVxdWlyZS5YTUxTZXJpYWxpemVyO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCA9IF9yZXF1aXJlMi50aHJvd1htbFRhZ05vdEZvdW5kO1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUzLmxhc3QsXG4gIGZpcnN0ID0gX3JlcXVpcmUzLmZpcnN0O1xuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKHZhbHVlKSB7XG4gIHJldHVybiAvXlsgXFxuXFxyXFx0XSskLy50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlcih0YWcpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChzY29wZSkge1xuICAgICAgaWYgKHRhZyA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZVt0YWddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgfTtcbn1cbnZhciBhdHRyVG9SZWdleCA9IHt9O1xuZnVuY3Rpb24gc2V0U2luZ2xlQXR0cmlidXRlKHBhcnRWYWx1ZSwgYXR0ciwgYXR0clZhbHVlKSB7XG4gIHZhciByZWdleDtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIG5leHQtbGluZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uXG4gIGlmIChhdHRyVG9SZWdleFthdHRyXSkge1xuICAgIHJlZ2V4ID0gYXR0clRvUmVnZXhbYXR0cl07XG4gIH0gZWxzZSB7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKFwiKDwuKiBcIi5jb25jYXQoYXR0ciwgXCI9XFxcIikoW15cXFwiXSopKFxcXCIuKikkXCIpKTtcbiAgICBhdHRyVG9SZWdleFthdHRyXSA9IHJlZ2V4O1xuICB9XG4gIGlmIChyZWdleC50ZXN0KHBhcnRWYWx1ZSkpIHtcbiAgICByZXR1cm4gcGFydFZhbHVlLnJlcGxhY2UocmVnZXgsIFwiJDFcIi5jb25jYXQoYXR0clZhbHVlLCBcIiQzXCIpKTtcbiAgfVxuICB2YXIgZW5kID0gcGFydFZhbHVlLmxhc3RJbmRleE9mKFwiLz5cIik7XG4gIGlmIChlbmQgPT09IC0xKSB7XG4gICAgZW5kID0gcGFydFZhbHVlLmxhc3RJbmRleE9mKFwiPlwiKTtcbiAgfVxuICByZXR1cm4gcGFydFZhbHVlLnN1YnN0cigwLCBlbmQpICsgXCIgXCIuY29uY2F0KGF0dHIsIFwiPVxcXCJcIikuY29uY2F0KGF0dHJWYWx1ZSwgXCJcXFwiXCIpICsgcGFydFZhbHVlLnN1YnN0cihlbmQpO1xufVxuZnVuY3Rpb24gZ2V0U2luZ2xlQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoXCIgXCIuY29uY2F0KGF0dHJpYnV0ZU5hbWUsIFwiPVxcXCJcIikpO1xuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHN0YXJ0SW5kZXggPSB2YWx1ZS5zdWJzdHIoaW5kZXgpLnNlYXJjaCgvW1wiJ10vKSArIGluZGV4O1xuICB2YXIgZW5kSW5kZXggPSB2YWx1ZS5zdWJzdHIoc3RhcnRJbmRleCArIDEpLnNlYXJjaCgvW1wiJ10vKSArIHN0YXJ0SW5kZXg7XG4gIHJldHVybiB2YWx1ZS5zdWJzdHIoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4IC0gc3RhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xuICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4O1xufVxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlcyhhcnIpIHtcbiAgdmFyIGR1cGxpY2F0ZXMgPSBbXTtcbiAgdmFyIGhhc2ggPSB7fSxcbiAgICByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKCFoYXNoW2FycltpXV0pIHtcbiAgICAgIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXBsaWNhdGVzLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cGxpY2F0ZXM7XG59XG5mdW5jdGlvbiB1bmlxKGFycikge1xuICB2YXIgaGFzaCA9IHt9LFxuICAgIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaHVua0J5KHBhcnNlZCwgZikge1xuICByZXR1cm4gcGFyc2VkLnJlZHVjZShmdW5jdGlvbiAoY2h1bmtzLCBwKSB7XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICB2YXIgcmVzID0gZihwKTtcbiAgICBpZiAocmVzID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGNodW5rcy5wdXNoKFtwXSk7XG4gICAgfSBlbHNlIGlmIChyZXMgPT09IFwiZW5kXCIpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHApO1xuICAgICAgY2h1bmtzLnB1c2goW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbiAgfSwgW1tdXSkuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAubGVuZ3RoID4gMDtcbiAgfSk7XG59XG52YXIgZGVmYXVsdHMgPSB7XG4gIGVycm9yTG9nZ2luZzogXCJqc29uXCIsXG4gIHBhcmFncmFwaExvb3A6IGZhbHNlLFxuICBudWxsR2V0dGVyOiBmdW5jdGlvbiBudWxsR2V0dGVyKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC5tb2R1bGUgPyBcIlwiIDogXCJ1bmRlZmluZWRcIjtcbiAgfSxcbiAgeG1sRmlsZU5hbWVzOiBbXCJbQ29udGVudF9UeXBlc10ueG1sXCJdLFxuICBwYXJzZXI6IHBhcnNlcixcbiAgbGluZWJyZWFrczogZmFsc2UsXG4gIGZpbGVUeXBlQ29uZmlnOiBudWxsLFxuICBkZWxpbWl0ZXJzOiB7XG4gICAgc3RhcnQ6IFwie1wiLFxuICAgIGVuZDogXCJ9XCJcbiAgfSxcbiAgc3ludGF4OiB7fVxufTtcbmZ1bmN0aW9uIHhtbDJzdHIoeG1sTm9kZSkge1xuICB2YXIgYSA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gIHJldHVybiBhLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbE5vZGUpLnJlcGxhY2UoL3htbG5zKDpbYS16MC05XSspPz1cIlwiID8vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzdHIyeG1sKHN0cikge1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgLy8gQk9NIHNlcXVlbmNlXG4gICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsIFwidGV4dC94bWxcIik7XG59XG52YXIgY2hhck1hcCA9IFtbXCImXCIsIFwiJmFtcDtcIl0sIFtcIjxcIiwgXCImbHQ7XCJdLCBbXCI+XCIsIFwiJmd0O1wiXSwgWydcIicsIFwiJnF1b3Q7XCJdLCBbXCInXCIsIFwiJmFwb3M7XCJdXTtcbnZhciBjaGFyTWFwUmVnZXhlcyA9IGNoYXJNYXAubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGVuZENoYXIgPSBfcmVmMlswXSxcbiAgICBzdGFydENoYXIgPSBfcmVmMlsxXTtcbiAgcmV0dXJuIHtcbiAgICByc3RhcnQ6IG5ldyBSZWdFeHAoc3RhcnRDaGFyLCBcImdcIiksXG4gICAgcmVuZDogbmV3IFJlZ0V4cChlbmRDaGFyLCBcImdcIiksXG4gICAgc3RhcnQ6IHN0YXJ0Q2hhcixcbiAgICBlbmQ6IGVuZENoYXJcbiAgfTtcbn0pO1xuZnVuY3Rpb24gd29yZFRvVXRmOChzdHJpbmcpIHtcbiAgdmFyIHI7XG4gIGZvciAodmFyIGkgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHIgPSBjaGFyTWFwUmVnZXhlc1tpXTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyLnJzdGFydCwgci5lbmQpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4VG9Xb3JkKHN0cmluZykge1xuICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgb2JqZWN0IGdpdmVuIGlzIGEgc3RyaW5nICh0aGlzIGlzIGEgbm9vcCBmb3Igc3RyaW5ncykuXG4gIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuICB2YXIgcjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yZW5kLCByLnN0YXJ0KTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gd2l0aCBmb3IgbG9vcHMgZm9yIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBjb25jYXRBcnJheXMoYXJyYXlzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtqXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgc3BhY2VSZWdleHAgPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgXCJnXCIpO1xuZnVuY3Rpb24gY29udmVydFNwYWNlcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2Uoc3BhY2VSZWdleHAsIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHByZWdNYXRjaEFsbChyZWdleCwgY29udGVudCkge1xuICAvKiByZWdleCBpcyBhIHN0cmluZywgY29udGVudCBpcyB0aGUgY29udGVudC4gSXQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbWF0Y2hlcyB3aXRoIHRoZWlyIG9mZnNldCwgZm9yIGV4YW1wbGU6XG4gIFx0XHRyZWdleD1sYVxuICBcdGNvbnRlbnQ9bG9sYWxvbGlsYWxhXG4gIFx0XHRyZXR1cm5zOlxuICBcdFx0W1xuICBcdFx0XHR7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiAyfSxcbiAgXHRcdFx0e2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogOH0sXG4gIFx0XHRcdHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDEwfVxuICBcdFx0XVxuICAqL1xuICB2YXIgbWF0Y2hBcnJheSA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGNvbnRlbnQpKSAhPSBudWxsKSB7XG4gICAgbWF0Y2hBcnJheS5wdXNoKHtcbiAgICAgIGFycmF5OiBtYXRjaCxcbiAgICAgIG9mZnNldDogbWF0Y2guaW5kZXhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hBcnJheTtcbn1cbmZ1bmN0aW9uIGlzRW5kaW5nKHZhbHVlLCBlbGVtZW50KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCI8L1wiICsgZWxlbWVudCArIFwiPlwiO1xufVxuZnVuY3Rpb24gaXNTdGFydGluZyh2YWx1ZSwgZWxlbWVudCkge1xuICByZXR1cm4gdmFsdWUuaW5kZXhPZihcIjxcIiArIGVsZW1lbnQpID09PSAwICYmIFtcIj5cIiwgXCIgXCIsIFwiL1wiXS5pbmRleE9mKHZhbHVlW2VsZW1lbnQubGVuZ3RoICsgMV0pICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0KHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpIHtcbiAgdmFyIHZhbCA9IGdldFJpZ2h0T3JOdWxsKHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvd1htbFRhZ05vdEZvdW5kKHtcbiAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHRPck51bGwocGFyc2VkLCBlbGVtZW50cywgaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuICB2YXIgbGV2ZWwgPSAxO1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGwgPSBwYXJzZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2pdO1xuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExlZnQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCh7XG4gICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbal07XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbC0tO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aG9zZSBhcmUgZnVuY3Rpb25zIHRoYXQgZGVwZW5kIG9uIHRoZSBwYXJzZWRcbi8vIHN0cnVjdHVyZSBiYXNlZCBhbmQgd2UgZG9uJ3Qgd2FudCBtaW5pbWFsIGNvZGUgaGVyZSwgYnV0IHJhdGhlciBjb2RlIHRoYXRcbi8vIG1ha2VzIHRoaW5ncyBjbGVhci5cbmZ1bmN0aW9uIGlzVGFnU3RhcnQodGFnVHlwZSwgX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlLFxuICAgIHRhZyA9IF9yZWYzLnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWYzLnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiB0YWcgPT09IHRhZ1R5cGUgJiYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIgfHwgcG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIik7XG59XG5mdW5jdGlvbiBpc1RhZ1N0YXJ0U3RyaWN0KHRhZ1R5cGUsIF9yZWY0KSB7XG4gIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICB0YWcgPSBfcmVmNC50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNC5wb3NpdGlvbjtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGFnXCIgJiYgdGFnID09PSB0YWdUeXBlICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBpc1RhZ0VuZCh0YWdUeXBlLCBfcmVmNSkge1xuICB2YXIgdHlwZSA9IF9yZWY1LnR5cGUsXG4gICAgdGFnID0gX3JlZjUudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjUucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInRhZ1wiICYmIHRhZyA9PT0gdGFnVHlwZSAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoU3RhcnQocGFydCkge1xuICByZXR1cm4gaXNUYWdTdGFydFN0cmljdChcInc6cFwiLCBwYXJ0KSB8fCBpc1RhZ1N0YXJ0U3RyaWN0KFwiYTpwXCIsIHBhcnQpO1xufVxuZnVuY3Rpb24gaXNQYXJhZ3JhcGhFbmQocGFydCkge1xuICByZXR1cm4gaXNUYWdFbmQoXCJ3OnBcIiwgcGFydCkgfHwgaXNUYWdFbmQoXCJhOnBcIiwgcGFydCk7XG59XG5mdW5jdGlvbiBpc1RleHRTdGFydChfcmVmNikge1xuICB2YXIgdHlwZSA9IF9yZWY2LnR5cGUsXG4gICAgcG9zaXRpb24gPSBfcmVmNi5wb3NpdGlvbixcbiAgICB0ZXh0ID0gX3JlZjYudGV4dDtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIiAmJiB0ZXh0O1xufVxuZnVuY3Rpb24gaXNUZXh0RW5kKF9yZWY3KSB7XG4gIHZhciB0eXBlID0gX3JlZjcudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY3LnBvc2l0aW9uLFxuICAgIHRleHQgPSBfcmVmNy50ZXh0O1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIiAmJiB0ZXh0O1xufVxuZnVuY3Rpb24gaXNDb250ZW50KF9yZWY4KSB7XG4gIHZhciB0eXBlID0gX3JlZjgudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY4LnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiIHx8IHR5cGUgPT09IFwiY29udGVudFwiICYmIHBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xufVxuZnVuY3Rpb24gaXNNb2R1bGUoX3JlZjksIG1vZHVsZXMpIHtcbiAgdmFyIG1vZHVsZSA9IF9yZWY5Lm1vZHVsZSxcbiAgICB0eXBlID0gX3JlZjkudHlwZTtcbiAgaWYgKCEobW9kdWxlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIG1vZHVsZXMgPSBbbW9kdWxlc107XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBtb2R1bGVzLmluZGV4T2YobW9kdWxlKSAhPT0gLTE7XG59XG4vLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbnZhciBjb3JydXB0Q2hhcmFjdGVycyA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZdLztcbi8vIDAwICAgIE5VTCAnXFwwJyAobnVsbCBjaGFyYWN0ZXIpXG4vLyAwMSAgICBTT0ggKHN0YXJ0IG9mIGhlYWRpbmcpXG4vLyAwMiAgICBTVFggKHN0YXJ0IG9mIHRleHQpXG4vLyAwMyAgICBFVFggKGVuZCBvZiB0ZXh0KVxuLy8gMDQgICAgRU9UIChlbmQgb2YgdHJhbnNtaXNzaW9uKVxuLy8gMDUgICAgRU5RIChlbnF1aXJ5KVxuLy8gMDYgICAgQUNLIChhY2tub3dsZWRnZSlcbi8vIDA3ICAgIEJFTCAnXFxhJyAoYmVsbClcbi8vIDA4ICAgIEJTICAnXFxiJyAoYmFja3NwYWNlKVxuLy8gMEIgICAgVlQgICdcXHYnICh2ZXJ0aWNhbCB0YWIpXG4vLyAwQyAgICBGRiAgJ1xcZicgKGZvcm0gZmVlZClcbi8vIDBFICAgIFNPICAoc2hpZnQgb3V0KVxuLy8gMEYgICAgU0kgIChzaGlmdCBpbilcbi8vIDEwICAgIERMRSAoZGF0YSBsaW5rIGVzY2FwZSlcbi8vIDExICAgIERDMSAoZGV2aWNlIGNvbnRyb2wgMSlcbi8vIDEyICAgIERDMiAoZGV2aWNlIGNvbnRyb2wgMilcbi8vIDEzICAgIERDMyAoZGV2aWNlIGNvbnRyb2wgMylcbi8vIDE0ICAgIERDNCAoZGV2aWNlIGNvbnRyb2wgNClcbi8vIDE1ICAgIE5BSyAobmVnYXRpdmUgYWNrLilcbi8vIDE2ICAgIFNZTiAoc3luY2hyb25vdXMgaWRsZSlcbi8vIDE3ICAgIEVUQiAoZW5kIG9mIHRyYW5zLiBibGspXG4vLyAxOCAgICBDQU4gKGNhbmNlbClcbi8vIDE5ICAgIEVNICAoZW5kIG9mIG1lZGl1bSlcbi8vIDFBICAgIFNVQiAoc3Vic3RpdHV0ZSlcbi8vIDFCICAgIEVTQyAoZXNjYXBlKVxuLy8gMUMgICAgRlMgIChmaWxlIHNlcGFyYXRvcilcbi8vIDFEICAgIEdTICAoZ3JvdXAgc2VwYXJhdG9yKVxuLy8gMUUgICAgUlMgIChyZWNvcmQgc2VwYXJhdG9yKVxuLy8gMUYgICAgVVMgICh1bml0IHNlcGFyYXRvcilcbmZ1bmN0aW9uIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICByZXR1cm4gY29ycnVwdENoYXJhY3RlcnMudGVzdChzdHJpbmcpO1xufVxuZnVuY3Rpb24gaW52ZXJ0TWFwKG1hcCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5yZWR1Y2UoZnVuY3Rpb24gKGludmVydGVkTWFwLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0gPSBpbnZlcnRlZE1hcFt2YWx1ZV0gfHwgW107XG4gICAgaW52ZXJ0ZWRNYXBbdmFsdWVdLnB1c2goa2V5KTtcbiAgICByZXR1cm4gaW52ZXJ0ZWRNYXA7XG4gIH0sIHt9KTtcbn1cbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzb3J0IGlzIHN0YWJsZS4gVGhlIGRlZmF1bHQgQXJyYXkuc29ydCBvZiB0aGUgYnJvd3NlclxuLy8gaXMgbm90IHN0YWJsZSBpbiBmaXJlZm94LCBhcyB0aGUgSlMgc3BlYyBkb2VzIG5vdCBlbmZvcmNlIHRoZSBzb3J0IHRvIGJlXG4vLyBzdGFibGUuXG5mdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZSkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogaW4gcHJldmlvdXMgdmVyc2lvbnMgb2YgQ2hyb21lLCBzb3J0IHdhcyBub3Qgc3RhYmxlIGJ5IGl0c2VsZiwgc28gd2UgaGFkIHRvIGFkZCB0aGlzLiBUaGlzIGlzIHRvIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgb2YgSlMgcnVubmVycy5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYS5pdGVtLCBiLml0ZW0pIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWYxMCkge1xuICAgIHZhciBpdGVtID0gX3JlZjEwLml0ZW07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICBpc0NvbnRlbnQ6IGlzQ29udGVudCxcbiAgaXNQYXJhZ3JhcGhTdGFydDogaXNQYXJhZ3JhcGhTdGFydCxcbiAgaXNQYXJhZ3JhcGhFbmQ6IGlzUGFyYWdyYXBoRW5kLFxuICBpc1RhZ1N0YXJ0OiBpc1RhZ1N0YXJ0LFxuICBpc1RhZ0VuZDogaXNUYWdFbmQsXG4gIGlzVGV4dFN0YXJ0OiBpc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kOiBpc1RleHRFbmQsXG4gIGlzU3RhcnRpbmc6IGlzU3RhcnRpbmcsXG4gIGlzRW5kaW5nOiBpc0VuZGluZyxcbiAgaXNNb2R1bGU6IGlzTW9kdWxlLFxuICB1bmlxOiB1bmlxLFxuICBnZXREdXBsaWNhdGVzOiBnZXREdXBsaWNhdGVzLFxuICBjaHVua0J5OiBjaHVua0J5LFxuICBsYXN0OiBsYXN0LFxuICBmaXJzdDogZmlyc3QsXG4gIHhtbDJzdHI6IHhtbDJzdHIsXG4gIHN0cjJ4bWw6IHN0cjJ4bWwsXG4gIGdldFJpZ2h0T3JOdWxsOiBnZXRSaWdodE9yTnVsbCxcbiAgZ2V0UmlnaHQ6IGdldFJpZ2h0LFxuICBnZXRMZWZ0T3JOdWxsOiBnZXRMZWZ0T3JOdWxsLFxuICBnZXRMZWZ0OiBnZXRMZWZ0LFxuICBwcmVnTWF0Y2hBbGw6IHByZWdNYXRjaEFsbCxcbiAgY29udmVydFNwYWNlczogY29udmVydFNwYWNlcyxcbiAgY2hhck1hcFJlZ2V4ZXM6IGNoYXJNYXBSZWdleGVzLFxuICBoYXNDb3JydXB0Q2hhcmFjdGVyczogaGFzQ29ycnVwdENoYXJhY3RlcnMsXG4gIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgd29yZFRvVXRmODogd29yZFRvVXRmOCxcbiAgdXRmOFRvV29yZDogdXRmOFRvV29yZCxcbiAgY29uY2F0QXJyYXlzOiBjb25jYXRBcnJheXMsXG4gIGludmVydE1hcDogaW52ZXJ0TWFwLFxuICBjaGFyTWFwOiBjaGFyTWFwLFxuICBnZXRTaW5nbGVBdHRyaWJ1dGU6IGdldFNpbmdsZUF0dHJpYnV0ZSxcbiAgc2V0U2luZ2xlQXR0cmlidXRlOiBzZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICBzdGFibGVTb3J0OiBzdGFibGVTb3J0XG59OyJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJyIiwibCIsInQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImUiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImlzQXJyYXkiLCJfcmVxdWlyZSIsInJlcXVpcmUiLCJET01QYXJzZXIiLCJYTUxTZXJpYWxpemVyIiwiX3JlcXVpcmUyIiwidGhyb3dYbWxUYWdOb3RGb3VuZCIsIl9yZXF1aXJlMyIsImxhc3QiLCJmaXJzdCIsImlzV2hpdGVTcGFjZSIsInBhcnNlciIsInRhZyIsImdldCIsInNjb3BlIiwiYXR0clRvUmVnZXgiLCJzZXRTaW5nbGVBdHRyaWJ1dGUiLCJwYXJ0VmFsdWUiLCJhdHRyIiwiYXR0clZhbHVlIiwicmVnZXgiLCJSZWdFeHAiLCJjb25jYXQiLCJyZXBsYWNlIiwiZW5kIiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJnZXRTaW5nbGVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW5kZXgiLCJpbmRleE9mIiwic3RhcnRJbmRleCIsInNlYXJjaCIsImVuZEluZGV4IiwiZW5kc1dpdGgiLCJzdHIiLCJzdWZmaXgiLCJzdGFydHNXaXRoIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiZ2V0RHVwbGljYXRlcyIsImR1cGxpY2F0ZXMiLCJoYXNoIiwicmVzdWx0IiwidW5pcSIsImNodW5rQnkiLCJwYXJzZWQiLCJyZWR1Y2UiLCJjaHVua3MiLCJwIiwiY3VycmVudENodW5rIiwicmVzIiwiZmlsdGVyIiwiZGVmYXVsdHMiLCJlcnJvckxvZ2dpbmciLCJwYXJhZ3JhcGhMb29wIiwibnVsbEdldHRlciIsInBhcnQiLCJtb2R1bGUiLCJ4bWxGaWxlTmFtZXMiLCJsaW5lYnJlYWtzIiwiZmlsZVR5cGVDb25maWciLCJkZWxpbWl0ZXJzIiwic3RhcnQiLCJzeW50YXgiLCJ4bWwyc3RyIiwieG1sTm9kZSIsInNlcmlhbGl6ZVRvU3RyaW5nIiwic3RyMnhtbCIsImNoYXJDb2RlQXQiLCJwYXJzZUZyb21TdHJpbmciLCJjaGFyTWFwIiwiY2hhck1hcFJlZ2V4ZXMiLCJtYXAiLCJfcmVmIiwiX3JlZjIiLCJlbmRDaGFyIiwic3RhcnRDaGFyIiwicnN0YXJ0IiwicmVuZCIsIndvcmRUb1V0ZjgiLCJzdHJpbmciLCJ1dGY4VG9Xb3JkIiwiY29uY2F0QXJyYXlzIiwiYXJyYXlzIiwiYXJyYXkiLCJqIiwic3BhY2VSZWdleHAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjb252ZXJ0U3BhY2VzIiwicyIsInByZWdNYXRjaEFsbCIsImNvbnRlbnQiLCJtYXRjaEFycmF5IiwibWF0Y2giLCJleGVjIiwib2Zmc2V0IiwiaXNFbmRpbmciLCJlbGVtZW50IiwiaXNTdGFydGluZyIsImdldFJpZ2h0IiwidmFsIiwiZ2V0UmlnaHRPck51bGwiLCJwb3NpdGlvbiIsImVsZW1lbnRzIiwibGV2ZWwiLCJnZXRMZWZ0IiwiZ2V0TGVmdE9yTnVsbCIsImlzVGFnU3RhcnQiLCJ0YWdUeXBlIiwiX3JlZjMiLCJ0eXBlIiwiaXNUYWdTdGFydFN0cmljdCIsIl9yZWY0IiwiaXNUYWdFbmQiLCJfcmVmNSIsImlzUGFyYWdyYXBoU3RhcnQiLCJpc1BhcmFncmFwaEVuZCIsImlzVGV4dFN0YXJ0IiwiX3JlZjYiLCJ0ZXh0IiwiaXNUZXh0RW5kIiwiX3JlZjciLCJpc0NvbnRlbnQiLCJfcmVmOCIsImlzTW9kdWxlIiwiX3JlZjkiLCJtb2R1bGVzIiwiY29ycnVwdENoYXJhY3RlcnMiLCJoYXNDb3JydXB0Q2hhcmFjdGVycyIsImludmVydE1hcCIsImtleXMiLCJpbnZlcnRlZE1hcCIsImtleSIsInN0YWJsZVNvcnQiLCJjb21wYXJlIiwiaXRlbSIsInNvcnQiLCJiIiwiX3JlZjEwIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/docxtemplater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/docxtemplater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _excluded = [\n    \"modules\"\n];\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\");\nDocUtils.traits = __webpack_require__(/*! ./traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(ssr)/./node_modules/docxtemplater/js/scope-manager.js\");\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), throwMultiError = _require.throwMultiError, throwResolveBeforeCompile = _require.throwResolveBeforeCompile, throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate, throwRenderTwice = _require.throwRenderTwice;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(ssr)/./node_modules/docxtemplater/js/error-logger.js\");\nvar collectContentTypes = __webpack_require__(/*! ./collect-content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/collect-content-types.js\");\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/common.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/docxtemplater/js/lexer.js\");\nvar defaults = DocUtils.defaults, str2xml = DocUtils.str2xml, xml2str = DocUtils.xml2str, moduleWrapper = DocUtils.moduleWrapper, concatArrays = DocUtils.concatArrays, uniq = DocUtils.uniq, getDuplicates = DocUtils.getDuplicates, stableSort = DocUtils.stableSort;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), XTInternalError = _require2.XTInternalError, throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified, throwFileTypeNotHandled = _require2.throwFileTypeNotHandled, throwApiVersionError = _require2.throwApiVersionError;\nvar currentModuleApiVersion = [\n    3,\n    40,\n    0\n];\nfunction dropUnsupportedFileTypesModules(dx) {\n    dx.modules = dx.modules.filter(function(module1) {\n        if (module1.supportedFileTypes) {\n            if (!Array.isArray(module1.supportedFileTypes)) {\n                throw new Error(\"The supportedFileTypes field of the module must be an array\");\n            }\n            var isSupportedModule = module1.supportedFileTypes.indexOf(dx.fileType) !== -1;\n            if (!isSupportedModule) {\n                module1.on(\"detached\");\n            }\n            return isSupportedModule;\n        }\n        return true;\n    });\n}\nvar Docxtemplater = /*#__PURE__*/ function() {\n    function Docxtemplater(zip) {\n        var _this = this;\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$modules = _ref.modules, modules = _ref$modules === void 0 ? [] : _ref$modules, options = _objectWithoutProperties(_ref, _excluded);\n        _classCallCheck(this, Docxtemplater);\n        if (!Array.isArray(modules)) {\n            throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n        }\n        this.targets = [];\n        this.rendered = false;\n        this.scopeManagers = {};\n        this.compiled = {};\n        this.modules = [\n            commonModule()\n        ];\n        this.setOptions(options);\n        modules.forEach(function(module1) {\n            _this.attachModule(module1);\n        });\n        if (arguments.length > 0) {\n            if (!zip || !zip.files || typeof zip.file !== \"function\") {\n                throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n            }\n            this.loadZip(zip);\n            this.compile();\n            this.v4Constructor = true;\n        }\n    }\n    return _createClass(Docxtemplater, [\n        {\n            key: \"verifyApiVersion\",\n            value: function verifyApiVersion(neededVersion) {\n                neededVersion = neededVersion.split(\".\").map(function(i) {\n                    return parseInt(i, 10);\n                });\n                if (neededVersion.length !== 3) {\n                    throwApiVersionError(\"neededVersion is not a valid version\", {\n                        neededVersion: neededVersion,\n                        explanation: \"the neededVersion must be an array of length 3\"\n                    });\n                }\n                if (neededVersion[0] !== currentModuleApiVersion[0]) {\n                    throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                if (neededVersion[1] > currentModuleApiVersion[1]) {\n                    throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n                    throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                return true;\n            }\n        },\n        {\n            key: \"setModules\",\n            value: function setModules(obj) {\n                this.modules.forEach(function(module1) {\n                    module1.set(obj);\n                });\n            }\n        },\n        {\n            key: \"sendEvent\",\n            value: function sendEvent(eventName) {\n                this.modules.forEach(function(module1) {\n                    module1.on(eventName);\n                });\n            }\n        },\n        {\n            key: \"attachModule\",\n            value: function attachModule(module1) {\n                if (this.v4Constructor) {\n                    throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n                }\n                var moduleType = _typeof(module1);\n                if (moduleType === \"function\") {\n                    throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n                }\n                if (!module1 || moduleType !== \"object\") {\n                    throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n                }\n                if (module1.requiredAPIVersion) {\n                    this.verifyApiVersion(module1.requiredAPIVersion);\n                }\n                if (module1.attached === true) {\n                    if (typeof module1.clone === \"function\") {\n                        module1 = module1.clone();\n                    } else {\n                        throw new Error('Cannot attach a module that was already attached : \"'.concat(module1.name, '\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater'));\n                    }\n                }\n                module1.attached = true;\n                var wrappedModule = moduleWrapper(module1);\n                this.modules.push(wrappedModule);\n                wrappedModule.on(\"attached\");\n                if (this.fileType) {\n                    dropUnsupportedFileTypesModules(this);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setOptions\",\n            value: function setOptions(options) {\n                var _this2 = this;\n                if (this.v4Constructor) {\n                    throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n                }\n                if (!options) {\n                    throw new Error(\"setOptions should be called with an object as first parameter\");\n                }\n                this.options = {};\n                Object.keys(defaults).forEach(function(key) {\n                    var defaultValue = defaults[key];\n                    _this2.options[key] = options[key] != null ? options[key] : _this2[key] || defaultValue;\n                    _this2[key] = _this2.options[key];\n                });\n                this.delimiters.start = DocUtils.utf8ToWord(this.delimiters.start);\n                this.delimiters.end = DocUtils.utf8ToWord(this.delimiters.end);\n                return this;\n            }\n        },\n        {\n            key: \"loadZip\",\n            value: function loadZip(zip) {\n                if (this.v4Constructor) {\n                    throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n                }\n                if (zip.loadAsync) {\n                    throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n                }\n                this.zip = zip;\n                this.updateFileTypeConfig();\n                this.modules = concatArrays([\n                    this.fileTypeConfig.baseModules.map(function(moduleFunction) {\n                        return moduleFunction();\n                    }),\n                    this.modules\n                ]);\n                dropUnsupportedFileTypesModules(this);\n                return this;\n            }\n        },\n        {\n            key: \"precompileFile\",\n            value: function precompileFile(fileName) {\n                var currentFile = this.createTemplateClass(fileName);\n                currentFile.preparse();\n                this.compiled[fileName] = currentFile;\n            }\n        },\n        {\n            key: \"compileFile\",\n            value: function compileFile(fileName) {\n                this.compiled[fileName].parse();\n            }\n        },\n        {\n            key: \"getScopeManager\",\n            value: function getScopeManager(to, currentFile, tags) {\n                if (!this.scopeManagers[to]) {\n                    this.scopeManagers[to] = createScope({\n                        tags: tags,\n                        parser: this.parser,\n                        cachedParsers: currentFile.cachedParsers\n                    });\n                }\n                return this.scopeManagers[to];\n            }\n        },\n        {\n            key: \"resolveData\",\n            value: function resolveData(data) {\n                var _this3 = this;\n                var errors = [];\n                if (!Object.keys(this.compiled).length) {\n                    throwResolveBeforeCompile();\n                }\n                return Promise.resolve(data).then(function(data) {\n                    _this3.setData(data);\n                    _this3.setModules({\n                        data: _this3.data,\n                        Lexer: Lexer\n                    });\n                    _this3.mapper = _this3.modules.reduce(function(value, module1) {\n                        return module1.getRenderedMap(value);\n                    }, {});\n                    return Promise.all(Object.keys(_this3.mapper).map(function(to) {\n                        var _this3$mapper$to = _this3.mapper[to], from = _this3$mapper$to.from, data = _this3$mapper$to.data;\n                        return Promise.resolve(data).then(function(data) {\n                            var currentFile = _this3.compiled[from];\n                            currentFile.filePath = to;\n                            currentFile.scopeManager = _this3.getScopeManager(to, currentFile, data);\n                            return currentFile.resolveTags(data).then(function(result) {\n                                currentFile.scopeManager.finishedResolving = true;\n                                return result;\n                            }, function(errs) {\n                                Array.prototype.push.apply(errors, errs);\n                            });\n                        });\n                    })).then(function(resolved) {\n                        if (errors.length !== 0) {\n                            if (_this3.options.errorLogging) {\n                                logErrors(errors, _this3.options.errorLogging);\n                            }\n                            throwMultiError(errors);\n                        }\n                        return concatArrays(resolved);\n                    });\n                });\n            }\n        },\n        {\n            key: \"reorderModules\",\n            value: function reorderModules() {\n                this.modules = stableSort(this.modules, function(m1, m2) {\n                    return (m2.priority || 0) - (m1.priority || 0);\n                });\n            }\n        },\n        {\n            key: \"throwIfDuplicateModules\",\n            value: function throwIfDuplicateModules() {\n                var duplicates = getDuplicates(this.modules.map(function(_ref2) {\n                    var name = _ref2.name;\n                    return name;\n                }));\n                if (duplicates.length > 0) {\n                    throw new XTInternalError('Detected duplicate module \"'.concat(duplicates[0], '\"'));\n                }\n            }\n        },\n        {\n            key: \"compile\",\n            value: function compile() {\n                var _this4 = this;\n                this.updateFileTypeConfig();\n                this.throwIfDuplicateModules();\n                this.reorderModules();\n                if (Object.keys(this.compiled).length) {\n                    return this;\n                }\n                this.options = this.modules.reduce(function(options, module1) {\n                    return module1.optionsTransformer(options, _this4);\n                }, this.options);\n                this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n                this.xmlDocuments = this.options.xmlFileNames.reduce(function(xmlDocuments, fileName) {\n                    var content = _this4.zip.files[fileName].asText();\n                    xmlDocuments[fileName] = str2xml(content);\n                    return xmlDocuments;\n                }, {});\n                this.setModules({\n                    zip: this.zip,\n                    xmlDocuments: this.xmlDocuments\n                });\n                this.getTemplatedFiles();\n                // Loop inside all templatedFiles (ie xml files with content).\n                // Sometimes they don't exist (footer.xml for example)\n                this.templatedFiles.forEach(function(fileName) {\n                    if (_this4.zip.files[fileName] != null) {\n                        _this4.precompileFile(fileName);\n                    }\n                });\n                this.templatedFiles.forEach(function(fileName) {\n                    if (_this4.zip.files[fileName] != null) {\n                        _this4.compileFile(fileName);\n                    }\n                });\n                this.setModules({\n                    compiled: this.compiled\n                });\n                verifyErrors(this);\n                return this;\n            }\n        },\n        {\n            key: \"getRelsTypes\",\n            value: function getRelsTypes() {\n                var rootRels = this.zip.files[relsFile];\n                var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n                var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n                var relsTypes = {};\n                for(var i = 0, len = rootRelationships.length; i < len; i++){\n                    var r = rootRelationships[i];\n                    relsTypes[r.getAttribute(\"Target\")] = r.getAttribute(\"Type\");\n                }\n                return relsTypes;\n            }\n        },\n        {\n            key: \"getContentTypes\",\n            value: function getContentTypes() {\n                var contentTypes = this.zip.files[ctXML];\n                var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n                var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n                var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n                return {\n                    overrides: overrides,\n                    defaults: defaults,\n                    contentTypes: contentTypes,\n                    contentTypeXml: contentTypeXml\n                };\n            }\n        },\n        {\n            key: \"updateFileTypeConfig\",\n            value: function updateFileTypeConfig() {\n                var _this5 = this;\n                var fileType;\n                if (this.zip.files.mimetype) {\n                    fileType = \"odt\";\n                }\n                this.relsTypes = this.getRelsTypes();\n                var _this$getContentTypes = this.getContentTypes(), overrides = _this$getContentTypes.overrides, defaults = _this$getContentTypes.defaults, contentTypes = _this$getContentTypes.contentTypes, contentTypeXml = _this$getContentTypes.contentTypeXml;\n                if (contentTypeXml) {\n                    this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n                    this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n                    this.setModules({\n                        contentTypes: this.contentTypes,\n                        invertedContentTypes: this.invertedContentTypes\n                    });\n                }\n                this.modules.forEach(function(module1) {\n                    fileType = module1.getFileType({\n                        zip: _this5.zip,\n                        contentTypes: contentTypes,\n                        contentTypeXml: contentTypeXml,\n                        overrides: overrides,\n                        defaults: defaults,\n                        doc: _this5\n                    }) || fileType;\n                });\n                if (fileType === \"odt\") {\n                    throwFileTypeNotHandled(fileType);\n                }\n                if (!fileType) {\n                    throwFileTypeNotIdentified(this.zip);\n                }\n                this.fileType = fileType;\n                dropUnsupportedFileTypesModules(this);\n                this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType]();\n                return this;\n            }\n        },\n        {\n            key: \"renderAsync\",\n            value: function renderAsync(data) {\n                var _this6 = this;\n                return this.resolveData(data).then(function() {\n                    return _this6.render();\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(data) {\n                var _this7 = this;\n                if (this.rendered) {\n                    throwRenderTwice();\n                }\n                this.rendered = true;\n                this.compile();\n                if (this.errors.length > 0) {\n                    throwRenderInvalidTemplate();\n                }\n                if (data) {\n                    this.setData(data);\n                }\n                this.setModules({\n                    data: this.data,\n                    Lexer: Lexer\n                });\n                this.mapper = this.mapper || this.modules.reduce(function(value, module1) {\n                    return module1.getRenderedMap(value);\n                }, {});\n                Object.keys(this.mapper).forEach(function(to) {\n                    var _this7$mapper$to = _this7.mapper[to], from = _this7$mapper$to.from, data = _this7$mapper$to.data;\n                    var currentFile = _this7.compiled[from];\n                    currentFile.scopeManager = _this7.getScopeManager(to, currentFile, data);\n                    currentFile.render(to);\n                    _this7.zip.file(to, currentFile.content, {\n                        createFolders: true\n                    });\n                });\n                verifyErrors(this);\n                this.sendEvent(\"syncing-zip\");\n                this.syncZip();\n                // The synced-zip event is used in the subtemplate module for example\n                this.sendEvent(\"synced-zip\");\n                return this;\n            }\n        },\n        {\n            key: \"syncZip\",\n            value: function syncZip() {\n                var _this8 = this;\n                Object.keys(this.xmlDocuments).forEach(function(fileName) {\n                    _this8.zip.remove(fileName);\n                    var content = xml2str(_this8.xmlDocuments[fileName]);\n                    return _this8.zip.file(fileName, content, {\n                        createFolders: true\n                    });\n                });\n            }\n        },\n        {\n            key: \"setData\",\n            value: function setData(data) {\n                this.data = data;\n                return this;\n            }\n        },\n        {\n            key: \"getZip\",\n            value: function getZip() {\n                return this.zip;\n            }\n        },\n        {\n            key: \"createTemplateClass\",\n            value: function createTemplateClass(path) {\n                var content = this.zip.files[path].asText();\n                return this.createTemplateClassFromContent(content, path);\n            }\n        },\n        {\n            key: \"createTemplateClassFromContent\",\n            value: function createTemplateClassFromContent(content, filePath) {\n                var _this9 = this;\n                var xmltOptions = {\n                    filePath: filePath,\n                    contentType: this.filesContentTypes[filePath],\n                    relsType: this.relsTypes[filePath]\n                };\n                Object.keys(defaults).concat([\n                    \"filesContentTypes\",\n                    \"fileTypeConfig\",\n                    \"fileType\",\n                    \"modules\"\n                ]).forEach(function(key) {\n                    xmltOptions[key] = _this9[key];\n                });\n                return new Docxtemplater.XmlTemplater(content, xmltOptions);\n            }\n        },\n        {\n            key: \"getFullText\",\n            value: function getFullText(path) {\n                return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n            }\n        },\n        {\n            key: \"getTemplatedFiles\",\n            value: function getTemplatedFiles() {\n                var _this10 = this;\n                this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n                this.targets.forEach(function(target) {\n                    _this10.templatedFiles.push(target);\n                });\n                this.templatedFiles = uniq(this.templatedFiles);\n                return this.templatedFiles;\n            }\n        }\n    ]);\n}();\nfunction verifyErrors(doc) {\n    var compiled = doc.compiled;\n    doc.errors = concatArrays(Object.keys(compiled).map(function(name) {\n        return compiled[name].allErrors;\n    }));\n    if (doc.errors.length !== 0) {\n        if (doc.options.errorLogging) {\n            logErrors(doc.errors, doc.options.errorLogging);\n        }\n        throwMultiError(doc.errors);\n    }\n}\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(ssr)/./node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsWUFBWTtJQUFDO0NBQVU7QUFDM0IsU0FBU0MsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLHlCQUF5QkMsTUFBTSxFQUFFQyxRQUFRO0lBQUksSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlFLFNBQVNDLDhCQUE4QkgsUUFBUUM7SUFBVyxJQUFJRyxLQUFLQztJQUFHLElBQUlDLE9BQU9DLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsbUJBQW1CRixPQUFPQyxxQkFBcUIsQ0FBQ1A7UUFBUyxJQUFLSyxJQUFJLEdBQUdBLElBQUlHLGlCQUFpQkMsTUFBTSxFQUFFSixJQUFLO1lBQUVELE1BQU1JLGdCQUFnQixDQUFDSCxFQUFFO1lBQUUsSUFBSUosU0FBU1MsT0FBTyxDQUFDTixRQUFRLEdBQUc7WUFBVSxJQUFJLENBQUNFLE9BQU9SLFNBQVMsQ0FBQ2Esb0JBQW9CLENBQUNDLElBQUksQ0FBQ1osUUFBUUksTUFBTTtZQUFVRixNQUFNLENBQUNFLElBQUksR0FBR0osTUFBTSxDQUFDSSxJQUFJO1FBQUU7SUFBRTtJQUFFLE9BQU9GO0FBQVE7QUFDM2UsU0FBU0MsOEJBQThCSCxNQUFNLEVBQUVDLFFBQVE7SUFBSSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQUcsSUFBSUUsU0FBUyxDQUFDO0lBQUcs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Z0JBQ3BFLElBQUksQ0FBQ08sT0FBTyxDQUFDSyxPQUFPLENBQUMsU0FBVXhGLE1BQU07b0JBQ25DMk4sUUFBUTFDLGNBQWMsQ0FBQzlELElBQUksQ0FBQ25IO2dCQUM5QjtnQkFDQSxJQUFJLENBQUNpTCxjQUFjLEdBQUczSCxLQUFLLElBQUksQ0FBQzJILGNBQWM7Z0JBQzlDLE9BQU8sSUFBSSxDQUFDQSxjQUFjO1lBQzVCO1FBQ0Y7S0FBRTtBQUNKO0FBQ0EsU0FBU0MsYUFBYW9CLEdBQUc7SUFDdkIsSUFBSWhILFdBQVdnSCxJQUFJaEgsUUFBUTtJQUMzQmdILElBQUl2RCxNQUFNLEdBQUcxRixhQUFhakQsT0FBT2lILElBQUksQ0FBQy9CLFVBQVVhLEdBQUcsQ0FBQyxTQUFVYyxJQUFJO1FBQ2hFLE9BQU8zQixRQUFRLENBQUMyQixLQUFLLENBQUMyRyxTQUFTO0lBQ2pDO0lBQ0EsSUFBSXRCLElBQUl2RCxNQUFNLENBQUN4SSxNQUFNLEtBQUssR0FBRztRQUMzQixJQUFJK0wsSUFBSXBILE9BQU8sQ0FBQ2dGLFlBQVksRUFBRTtZQUM1QnRILFVBQVUwSixJQUFJdkQsTUFBTSxFQUFFdUQsSUFBSXBILE9BQU8sQ0FBQ2dGLFlBQVk7UUFDaEQ7UUFDQTFILGdCQUFnQjhKLElBQUl2RCxNQUFNO0lBQzVCO0FBQ0Y7QUFDQXBFLGNBQWN6QyxRQUFRLEdBQUdBO0FBQ3pCeUMsY0FBY2tKLE1BQU0sR0FBRzFMLG1CQUFPQSxDQUFDLG9FQUFhO0FBQzVDd0MsY0FBYzZJLFlBQVksR0FBR3JMLG1CQUFPQSxDQUFDLGtGQUFvQjtBQUN6RHdDLGNBQWM0SCxjQUFjLEdBQUdwSyxtQkFBT0EsQ0FBQyx3RkFBdUI7QUFDOUR3QyxjQUFjbUosVUFBVSxHQUFHM0wsbUJBQU9BLENBQUMsOEVBQWtCO0FBQ3JEZ0MsT0FBTzRKLE9BQU8sR0FBR3BKO0FBQ2pCUix5QkFBeUIsR0FBR1EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzPzIwZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJtb2R1bGVzXCJdO1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgRG9jVXRpbHMgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIik7XG5Eb2NVdGlscy50cmFpdHMgPSByZXF1aXJlKFwiLi90cmFpdHMuanNcIik7XG5Eb2NVdGlscy5tb2R1bGVXcmFwcGVyID0gcmVxdWlyZShcIi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgY3JlYXRlU2NvcGUgPSByZXF1aXJlKFwiLi9zY29wZS1tYW5hZ2VyLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd011bHRpRXJyb3IgPSBfcmVxdWlyZS50aHJvd011bHRpRXJyb3IsXG4gIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUgPSBfcmVxdWlyZS50aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlLFxuICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSA9IF9yZXF1aXJlLnRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlID0gX3JlcXVpcmUudGhyb3dSZW5kZXJUd2ljZTtcbnZhciBsb2dFcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvci1sb2dnZXIuanNcIik7XG52YXIgY29sbGVjdENvbnRlbnRUeXBlcyA9IHJlcXVpcmUoXCIuL2NvbGxlY3QtY29udGVudC10eXBlcy5qc1wiKTtcbnZhciBjdFhNTCA9IFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiO1xudmFyIHJlbHNGaWxlID0gXCJfcmVscy8ucmVsc1wiO1xudmFyIGNvbW1vbk1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY29tbW9uLmpzXCIpO1xudmFyIExleGVyID0gcmVxdWlyZShcIi4vbGV4ZXIuanNcIik7XG52YXIgZGVmYXVsdHMgPSBEb2NVdGlscy5kZWZhdWx0cyxcbiAgc3RyMnhtbCA9IERvY1V0aWxzLnN0cjJ4bWwsXG4gIHhtbDJzdHIgPSBEb2NVdGlscy54bWwyc3RyLFxuICBtb2R1bGVXcmFwcGVyID0gRG9jVXRpbHMubW9kdWxlV3JhcHBlcixcbiAgY29uY2F0QXJyYXlzID0gRG9jVXRpbHMuY29uY2F0QXJyYXlzLFxuICB1bmlxID0gRG9jVXRpbHMudW5pcSxcbiAgZ2V0RHVwbGljYXRlcyA9IERvY1V0aWxzLmdldER1cGxpY2F0ZXMsXG4gIHN0YWJsZVNvcnQgPSBEb2NVdGlscy5zdGFibGVTb3J0O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRJbnRlcm5hbEVycm9yID0gX3JlcXVpcmUyLlhUSW50ZXJuYWxFcnJvcixcbiAgdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQgPSBfcmVxdWlyZTIudGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQsXG4gIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkID0gX3JlcXVpcmUyLnRocm93RmlsZVR5cGVOb3RIYW5kbGVkLFxuICB0aHJvd0FwaVZlcnNpb25FcnJvciA9IF9yZXF1aXJlMi50aHJvd0FwaVZlcnNpb25FcnJvcjtcbnZhciBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbiA9IFszLCA0MCwgMF07XG5mdW5jdGlvbiBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKGR4KSB7XG4gIGR4Lm1vZHVsZXMgPSBkeC5tb2R1bGVzLmZpbHRlcihmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgaWYgKG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcG9ydGVkRmlsZVR5cGVzIGZpZWxkIG9mIHRoZSBtb2R1bGUgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZE1vZHVsZSA9IG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMuaW5kZXhPZihkeC5maWxlVHlwZSkgIT09IC0xO1xuICAgICAgaWYgKCFpc1N1cHBvcnRlZE1vZHVsZSkge1xuICAgICAgICBtb2R1bGUub24oXCJkZXRhY2hlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZE1vZHVsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxudmFyIERvY3h0ZW1wbGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEb2N4dGVtcGxhdGVyKHppcCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRtb2R1bGVzID0gX3JlZi5tb2R1bGVzLFxuICAgICAgbW9kdWxlcyA9IF9yZWYkbW9kdWxlcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJG1vZHVsZXMsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3h0ZW1wbGF0ZXIpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG1vZHVsZXMgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNjb3BlTWFuYWdlcnMgPSB7fTtcbiAgICB0aGlzLmNvbXBpbGVkID0ge307XG4gICAgdGhpcy5tb2R1bGVzID0gW2NvbW1vbk1vZHVsZSgpXTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIF90aGlzLmF0dGFjaE1vZHVsZShtb2R1bGUpO1xuICAgIH0pO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCF6aXAgfHwgIXppcC5maWxlcyB8fCB0eXBlb2YgemlwLmZpbGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYSB2YWxpZCB6aXAgZmlsZSAoanN6aXAgdjIgb3IgcGl6emlwIHYzKVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFppcCh6aXApO1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgICB0aGlzLnY0Q29uc3RydWN0b3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERvY3h0ZW1wbGF0ZXIsIFt7XG4gICAga2V5OiBcInZlcmlmeUFwaVZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5QXBpVmVyc2lvbihuZWVkZWRWZXJzaW9uKSB7XG4gICAgICBuZWVkZWRWZXJzaW9uID0gbmVlZGVkVmVyc2lvbi5zcGxpdChcIi5cIikubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChpLCAxMCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIm5lZWRlZFZlcnNpb24gaXMgbm90IGEgdmFsaWQgdmVyc2lvblwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJ0aGUgbmVlZGVkVmVyc2lvbiBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZGVkVmVyc2lvblswXSAhPT0gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMF0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgbWFqb3IgYXBpIHZlcnNpb24gZG8gbm90IG1hdGNoLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMV0gPiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsxXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBtaW5vciBhcGkgdmVyc2lvbiBpcyBub3QgdXB0b2RhdGUsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZGVkVmVyc2lvblsxXSA9PT0gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMV0gJiYgbmVlZGVkVmVyc2lvblsyXSA+IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzJdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIHBhdGNoIGFwaSB2ZXJzaW9uIGlzIG5vdCB1cHRvZGF0ZSwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZXMob2JqKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5zZXQob2JqKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICBtb2R1bGUub24oZXZlbnROYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRhY2hNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoTW9kdWxlKG1vZHVsZSkge1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiYXR0YWNoTW9kdWxlKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICB2YXIgbW9kdWxlVHlwZSA9IF90eXBlb2YobW9kdWxlKTtcbiAgICAgIGlmIChtb2R1bGVUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBjbGFzcy9mdW5jdGlvbiBhcyBhIG1vZHVsZS4gTW9zdCBwcm9iYWJseSB5b3UgZm9yZ290IHRvIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUgYnkgdXNpbmcgYG5ld2Agb24gdGhlIG1vZHVsZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIW1vZHVsZSB8fCBtb2R1bGVUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJDYW5ub3QgYXR0YWNoTW9kdWxlIHdpdGggYSBmYWxzeSB2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5QXBpVmVyc2lvbihtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUuYXR0YWNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG1vZHVsZSA9IG1vZHVsZS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBtb2R1bGUgdGhhdCB3YXMgYWxyZWFkeSBhdHRhY2hlZCA6IFxcXCJcIi5jb25jYXQobW9kdWxlLm5hbWUsIFwiXFxcIi4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgeW91IGFyZSBpbnN0YW50aWF0aW5nIHRoZSBtb2R1bGUgYXQgdGhlIHJvb3QgbGV2ZWwsIGFuZCB1c2luZyBpdCBmb3IgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIERvY3h0ZW1wbGF0ZXJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2R1bGUuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdmFyIHdyYXBwZWRNb2R1bGUgPSBtb2R1bGVXcmFwcGVyKG1vZHVsZSk7XG4gICAgICB0aGlzLm1vZHVsZXMucHVzaCh3cmFwcGVkTW9kdWxlKTtcbiAgICAgIHdyYXBwZWRNb2R1bGUub24oXCJhdHRhY2hlZFwiKTtcbiAgICAgIGlmICh0aGlzLmZpbGVUeXBlKSB7XG4gICAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0T3B0aW9ucyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IGFzIGZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgX3RoaXMyLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSAhPSBudWxsID8gb3B0aW9uc1trZXldIDogX3RoaXMyW2tleV0gfHwgZGVmYXVsdFZhbHVlO1xuICAgICAgICBfdGhpczJba2V5XSA9IF90aGlzMi5vcHRpb25zW2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGVsaW1pdGVycy5zdGFydCA9IERvY1V0aWxzLnV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLnN0YXJ0KTtcbiAgICAgIHRoaXMuZGVsaW1pdGVycy5lbmQgPSBEb2NVdGlscy51dGY4VG9Xb3JkKHRoaXMuZGVsaW1pdGVycy5lbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFppcCh6aXApIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFppcCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHppcC5sb2FkQXN5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkRvY3h0ZW1wbGF0ZXIgZG9lc24ndCBoYW5kbGUgSlNaaXAgdmVyc2lvbiA+PTMsIHBsZWFzZSB1c2UgcGl6emlwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy56aXAgPSB6aXA7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aGlzLm1vZHVsZXMgPSBjb25jYXRBcnJheXMoW3RoaXMuZmlsZVR5cGVDb25maWcuYmFzZU1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGVGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gbW9kdWxlRnVuY3Rpb24oKTtcbiAgICAgIH0pLCB0aGlzLm1vZHVsZXNdKTtcbiAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50RmlsZSA9IHRoaXMuY3JlYXRlVGVtcGxhdGVDbGFzcyhmaWxlTmFtZSk7XG4gICAgICBjdXJyZW50RmlsZS5wcmVwYXJzZSgpO1xuICAgICAgdGhpcy5jb21waWxlZFtmaWxlTmFtZV0gPSBjdXJyZW50RmlsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuY29tcGlsZWRbZmlsZU5hbWVdLnBhcnNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCB0YWdzKSB7XG4gICAgICBpZiAoIXRoaXMuc2NvcGVNYW5hZ2Vyc1t0b10pIHtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXJzW3RvXSA9IGNyZWF0ZVNjb3BlKHtcbiAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgICAgY2FjaGVkUGFyc2VyczogY3VycmVudEZpbGUuY2FjaGVkUGFyc2Vyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNjb3BlTWFuYWdlcnNbdG9dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlRGF0YShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfdGhpczMuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgX3RoaXMzLnNldE1vZHVsZXMoe1xuICAgICAgICAgIGRhdGE6IF90aGlzMy5kYXRhLFxuICAgICAgICAgIExleGVyOiBMZXhlclxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMzLm1hcHBlciA9IF90aGlzMy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICAgIHJldHVybiBtb2R1bGUuZ2V0UmVuZGVyZWRNYXAodmFsdWUpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfdGhpczMubWFwcGVyKS5tYXAoZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyRtYXBwZXIkdG8gPSBfdGhpczMubWFwcGVyW3RvXSxcbiAgICAgICAgICAgIGZyb20gPSBfdGhpczMkbWFwcGVyJHRvLmZyb20sXG4gICAgICAgICAgICBkYXRhID0gX3RoaXMzJG1hcHBlciR0by5kYXRhO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gX3RoaXMzLmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuZmlsZVBhdGggPSB0bztcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlciA9IF90aGlzMy5nZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RmlsZS5yZXNvbHZlVGFncyhkYXRhKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyLmZpbmlzaGVkUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJzKSB7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVycm9ycywgZXJycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5lcnJvckxvZ2dpbmcpIHtcbiAgICAgICAgICAgICAgbG9nRXJyb3JzKGVycm9ycywgX3RoaXMzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93TXVsdGlFcnJvcihlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uY2F0QXJyYXlzKHJlc29sdmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVvcmRlck1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVvcmRlck1vZHVsZXMoKSB7XG4gICAgICB0aGlzLm1vZHVsZXMgPSBzdGFibGVTb3J0KHRoaXMubW9kdWxlcywgZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICByZXR1cm4gKG0yLnByaW9yaXR5IHx8IDApIC0gKG0xLnByaW9yaXR5IHx8IDApO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRocm93SWZEdXBsaWNhdGVNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRocm93SWZEdXBsaWNhdGVNb2R1bGVzKCkge1xuICAgICAgdmFyIGR1cGxpY2F0ZXMgPSBnZXREdXBsaWNhdGVzKHRoaXMubW9kdWxlcy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9KSk7XG4gICAgICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJEZXRlY3RlZCBkdXBsaWNhdGUgbW9kdWxlIFxcXCJcIi5jb25jYXQoZHVwbGljYXRlc1swXSwgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aGlzLnRocm93SWZEdXBsaWNhdGVNb2R1bGVzKCk7XG4gICAgICB0aGlzLnJlb3JkZXJNb2R1bGVzKCk7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob3B0aW9ucywgbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUub3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIF90aGlzNCk7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyA9IHVuaXEodGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyk7XG4gICAgICB0aGlzLnhtbERvY3VtZW50cyA9IHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMucmVkdWNlKGZ1bmN0aW9uICh4bWxEb2N1bWVudHMsIGZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gX3RoaXM0LnppcC5maWxlc1tmaWxlTmFtZV0uYXNUZXh0KCk7XG4gICAgICAgIHhtbERvY3VtZW50c1tmaWxlTmFtZV0gPSBzdHIyeG1sKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4geG1sRG9jdW1lbnRzO1xuICAgICAgfSwge30pO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgemlwOiB0aGlzLnppcCxcbiAgICAgICAgeG1sRG9jdW1lbnRzOiB0aGlzLnhtbERvY3VtZW50c1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFRlbXBsYXRlZEZpbGVzKCk7XG4gICAgICAvLyBMb29wIGluc2lkZSBhbGwgdGVtcGxhdGVkRmlsZXMgKGllIHhtbCBmaWxlcyB3aXRoIGNvbnRlbnQpLlxuICAgICAgLy8gU29tZXRpbWVzIHRoZXkgZG9uJ3QgZXhpc3QgKGZvb3Rlci54bWwgZm9yIGV4YW1wbGUpXG4gICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIGlmIChfdGhpczQuemlwLmZpbGVzW2ZpbGVOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXM0LnByZWNvbXBpbGVGaWxlKGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIGlmIChfdGhpczQuemlwLmZpbGVzW2ZpbGVOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXM0LmNvbXBpbGVGaWxlKGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBjb21waWxlZDogdGhpcy5jb21waWxlZFxuICAgICAgfSk7XG4gICAgICB2ZXJpZnlFcnJvcnModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVsc1R5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbHNUeXBlcygpIHtcbiAgICAgIHZhciByb290UmVscyA9IHRoaXMuemlwLmZpbGVzW3JlbHNGaWxlXTtcbiAgICAgIHZhciByb290UmVsc1htbCA9IHJvb3RSZWxzID8gc3RyMnhtbChyb290UmVscy5hc1RleHQoKSkgOiBudWxsO1xuICAgICAgdmFyIHJvb3RSZWxhdGlvbnNoaXBzID0gcm9vdFJlbHNYbWwgPyByb290UmVsc1htbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlbGF0aW9uc2hpcFwiKSA6IFtdO1xuICAgICAgdmFyIHJlbHNUeXBlcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RSZWxhdGlvbnNoaXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciByID0gcm9vdFJlbGF0aW9uc2hpcHNbaV07XG4gICAgICAgIHJlbHNUeXBlc1tyLmdldEF0dHJpYnV0ZShcIlRhcmdldFwiKV0gPSByLmdldEF0dHJpYnV0ZShcIlR5cGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVsc1R5cGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZW50VHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVzKCkge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IHRoaXMuemlwLmZpbGVzW2N0WE1MXTtcbiAgICAgIHZhciBjb250ZW50VHlwZVhtbCA9IGNvbnRlbnRUeXBlcyA/IHN0cjJ4bWwoY29udGVudFR5cGVzLmFzVGV4dCgpKSA6IG51bGw7XG4gICAgICB2YXIgb3ZlcnJpZGVzID0gY29udGVudFR5cGVYbWwgPyBjb250ZW50VHlwZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk92ZXJyaWRlXCIpIDogbnVsbDtcbiAgICAgIHZhciBkZWZhdWx0cyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJEZWZhdWx0XCIpIDogbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG92ZXJyaWRlczogb3ZlcnJpZGVzLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGNvbnRlbnRUeXBlczogY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbDogY29udGVudFR5cGVYbWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZpbGVUeXBlQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZpbGVUeXBlQ29uZmlnKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgZmlsZVR5cGU7XG4gICAgICBpZiAodGhpcy56aXAuZmlsZXMubWltZXR5cGUpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBcIm9kdFwiO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWxzVHlwZXMgPSB0aGlzLmdldFJlbHNUeXBlcygpO1xuICAgICAgdmFyIF90aGlzJGdldENvbnRlbnRUeXBlcyA9IHRoaXMuZ2V0Q29udGVudFR5cGVzKCksXG4gICAgICAgIG92ZXJyaWRlcyA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5vdmVycmlkZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMkZ2V0Q29udGVudFR5cGVzLmRlZmF1bHRzLFxuICAgICAgICBjb250ZW50VHlwZXMgPSBfdGhpcyRnZXRDb250ZW50VHlwZXMuY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbCA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5jb250ZW50VHlwZVhtbDtcbiAgICAgIGlmIChjb250ZW50VHlwZVhtbCkge1xuICAgICAgICB0aGlzLmZpbGVzQ29udGVudFR5cGVzID0gY29sbGVjdENvbnRlbnRUeXBlcyhvdmVycmlkZXMsIGRlZmF1bHRzLCB0aGlzLnppcCk7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRDb250ZW50VHlwZXMgPSBEb2NVdGlscy5pbnZlcnRNYXAodGhpcy5maWxlc0NvbnRlbnRUeXBlcyk7XG4gICAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgY29udGVudFR5cGVzOiB0aGlzLmNvbnRlbnRUeXBlcyxcbiAgICAgICAgICBpbnZlcnRlZENvbnRlbnRUeXBlczogdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBtb2R1bGUuZ2V0RmlsZVR5cGUoe1xuICAgICAgICAgIHppcDogX3RoaXM1LnppcCxcbiAgICAgICAgICBjb250ZW50VHlwZXM6IGNvbnRlbnRUeXBlcyxcbiAgICAgICAgICBjb250ZW50VHlwZVhtbDogY29udGVudFR5cGVYbWwsXG4gICAgICAgICAgb3ZlcnJpZGVzOiBvdmVycmlkZXMsXG4gICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICAgIGRvYzogX3RoaXM1XG4gICAgICAgIH0pIHx8IGZpbGVUeXBlO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwib2R0XCIpIHtcbiAgICAgICAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQoZmlsZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWxlVHlwZSkge1xuICAgICAgICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh0aGlzLnppcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGVUeXBlID0gZmlsZVR5cGU7XG4gICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IHRoaXMub3B0aW9ucy5maWxlVHlwZUNvbmZpZyB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnIHx8IERvY3h0ZW1wbGF0ZXIuRmlsZVR5cGVDb25maWdbdGhpcy5maWxlVHlwZV0oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBc3luYyhkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVEYXRhKGRhdGEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZCkge1xuICAgICAgICB0aHJvd1JlbmRlclR3aWNlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgTGV4ZXI6IExleGVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwcGVyID0gdGhpcy5tYXBwZXIgfHwgdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmdldFJlbmRlcmVkTWFwKHZhbHVlKTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubWFwcGVyKS5mb3JFYWNoKGZ1bmN0aW9uICh0bykge1xuICAgICAgICB2YXIgX3RoaXM3JG1hcHBlciR0byA9IF90aGlzNy5tYXBwZXJbdG9dLFxuICAgICAgICAgIGZyb20gPSBfdGhpczckbWFwcGVyJHRvLmZyb20sXG4gICAgICAgICAgZGF0YSA9IF90aGlzNyRtYXBwZXIkdG8uZGF0YTtcbiAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gX3RoaXM3LmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIgPSBfdGhpczcuZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgZGF0YSk7XG4gICAgICAgIGN1cnJlbnRGaWxlLnJlbmRlcih0byk7XG4gICAgICAgIF90aGlzNy56aXAuZmlsZSh0bywgY3VycmVudEZpbGUuY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZlcmlmeUVycm9ycyh0aGlzKTtcbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwic3luY2luZy16aXBcIik7XG4gICAgICB0aGlzLnN5bmNaaXAoKTtcbiAgICAgIC8vIFRoZSBzeW5jZWQtemlwIGV2ZW50IGlzIHVzZWQgaW4gdGhlIHN1YnRlbXBsYXRlIG1vZHVsZSBmb3IgZXhhbXBsZVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJzeW5jZWQtemlwXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luY1ppcCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXModGhpcy54bWxEb2N1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIF90aGlzOC56aXAucmVtb3ZlKGZpbGVOYW1lKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB4bWwyc3RyKF90aGlzOC54bWxEb2N1bWVudHNbZmlsZU5hbWVdKTtcbiAgICAgICAgcmV0dXJuIF90aGlzOC56aXAuZmlsZShmaWxlTmFtZSwgY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WmlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFppcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVtcGxhdGVDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzKHBhdGgpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy56aXAuZmlsZXNbcGF0aF0uYXNUZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgcGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgZmlsZVBhdGgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIHhtbHRPcHRpb25zID0ge1xuICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmZpbGVzQ29udGVudFR5cGVzW2ZpbGVQYXRoXSxcbiAgICAgICAgcmVsc1R5cGU6IHRoaXMucmVsc1R5cGVzW2ZpbGVQYXRoXVxuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5jb25jYXQoW1wiZmlsZXNDb250ZW50VHlwZXNcIiwgXCJmaWxlVHlwZUNvbmZpZ1wiLCBcImZpbGVUeXBlXCIsIFwibW9kdWxlc1wiXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHhtbHRPcHRpb25zW2tleV0gPSBfdGhpczlba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlcihjb250ZW50LCB4bWx0T3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3MocGF0aCB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnLnRleHRQYXRoKHRoaXMpKS5nZXRGdWxsVGV4dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZW1wbGF0ZWRGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB0aGlzLmZpbGVUeXBlQ29uZmlnLmdldFRlbXBsYXRlZEZpbGVzKHRoaXMuemlwKTtcbiAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgX3RoaXMxMC50ZW1wbGF0ZWRGaWxlcy5wdXNoKHRhcmdldCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB1bmlxKHRoaXMudGVtcGxhdGVkRmlsZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVkRmlsZXM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiB2ZXJpZnlFcnJvcnMoZG9jKSB7XG4gIHZhciBjb21waWxlZCA9IGRvYy5jb21waWxlZDtcbiAgZG9jLmVycm9ycyA9IGNvbmNhdEFycmF5cyhPYmplY3Qua2V5cyhjb21waWxlZCkubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVkW25hbWVdLmFsbEVycm9ycztcbiAgfSkpO1xuICBpZiAoZG9jLmVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICBpZiAoZG9jLm9wdGlvbnMuZXJyb3JMb2dnaW5nKSB7XG4gICAgICBsb2dFcnJvcnMoZG9jLmVycm9ycywgZG9jLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICB9XG4gICAgdGhyb3dNdWx0aUVycm9yKGRvYy5lcnJvcnMpO1xuICB9XG59XG5Eb2N4dGVtcGxhdGVyLkRvY1V0aWxzID0gRG9jVXRpbHM7XG5Eb2N4dGVtcGxhdGVyLkVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbkRvY3h0ZW1wbGF0ZXIuWG1sVGVtcGxhdGVyID0gcmVxdWlyZShcIi4veG1sLXRlbXBsYXRlci5qc1wiKTtcbkRvY3h0ZW1wbGF0ZXIuRmlsZVR5cGVDb25maWcgPSByZXF1aXJlKFwiLi9maWxlLXR5cGUtY29uZmlnLmpzXCIpO1xuRG9jeHRlbXBsYXRlci5YbWxNYXRjaGVyID0gcmVxdWlyZShcIi4veG1sLW1hdGNoZXIuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IERvY3h0ZW1wbGF0ZXI7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEb2N4dGVtcGxhdGVyOyJdLCJuYW1lcyI6WyJfZXhjbHVkZWQiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwia2V5IiwiaSIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJsZW5ndGgiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiaGFzT3duUHJvcGVydHkiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwidCIsIl90b1ByaW1pdGl2ZSIsInIiLCJlIiwidG9QcmltaXRpdmUiLCJTdHJpbmciLCJOdW1iZXIiLCJEb2NVdGlscyIsInJlcXVpcmUiLCJ0cmFpdHMiLCJtb2R1bGVXcmFwcGVyIiwiY3JlYXRlU2NvcGUiLCJfcmVxdWlyZSIsInRocm93TXVsdGlFcnJvciIsInRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUiLCJ0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSIsInRocm93UmVuZGVyVHdpY2UiLCJsb2dFcnJvcnMiLCJjb2xsZWN0Q29udGVudFR5cGVzIiwiY3RYTUwiLCJyZWxzRmlsZSIsImNvbW1vbk1vZHVsZSIsIkxleGVyIiwiZGVmYXVsdHMiLCJzdHIyeG1sIiwieG1sMnN0ciIsImNvbmNhdEFycmF5cyIsInVuaXEiLCJnZXREdXBsaWNhdGVzIiwic3RhYmxlU29ydCIsIl9yZXF1aXJlMiIsIlhUSW50ZXJuYWxFcnJvciIsInRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkIiwidGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQiLCJ0aHJvd0FwaVZlcnNpb25FcnJvciIsImN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uIiwiZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyIsImR4IiwibW9kdWxlcyIsImZpbHRlciIsIm1vZHVsZSIsInN1cHBvcnRlZEZpbGVUeXBlcyIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiaXNTdXBwb3J0ZWRNb2R1bGUiLCJmaWxlVHlwZSIsIm9uIiwiRG9jeHRlbXBsYXRlciIsInppcCIsIl90aGlzIiwiX3JlZiIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIl9yZWYkbW9kdWxlcyIsIm9wdGlvbnMiLCJ0YXJnZXRzIiwicmVuZGVyZWQiLCJzY29wZU1hbmFnZXJzIiwiY29tcGlsZWQiLCJzZXRPcHRpb25zIiwiZm9yRWFjaCIsImF0dGFjaE1vZHVsZSIsImZpbGVzIiwiZmlsZSIsImxvYWRaaXAiLCJjb21waWxlIiwidjRDb25zdHJ1Y3RvciIsInZhbHVlIiwidmVyaWZ5QXBpVmVyc2lvbiIsIm5lZWRlZFZlcnNpb24iLCJzcGxpdCIsIm1hcCIsInBhcnNlSW50IiwiZXhwbGFuYXRpb24iLCJjb25jYXQiLCJqb2luIiwic2V0TW9kdWxlcyIsIm9iaiIsInNldCIsInNlbmRFdmVudCIsImV2ZW50TmFtZSIsIm1vZHVsZVR5cGUiLCJyZXF1aXJlZEFQSVZlcnNpb24iLCJhdHRhY2hlZCIsImNsb25lIiwibmFtZSIsIndyYXBwZWRNb2R1bGUiLCJwdXNoIiwiX3RoaXMyIiwia2V5cyIsImRlZmF1bHRWYWx1ZSIsImRlbGltaXRlcnMiLCJzdGFydCIsInV0ZjhUb1dvcmQiLCJlbmQiLCJsb2FkQXN5bmMiLCJ1cGRhdGVGaWxlVHlwZUNvbmZpZyIsImZpbGVUeXBlQ29uZmlnIiwiYmFzZU1vZHVsZXMiLCJtb2R1bGVGdW5jdGlvbiIsInByZWNvbXBpbGVGaWxlIiwiZmlsZU5hbWUiLCJjdXJyZW50RmlsZSIsImNyZWF0ZVRlbXBsYXRlQ2xhc3MiLCJwcmVwYXJzZSIsImNvbXBpbGVGaWxlIiwicGFyc2UiLCJnZXRTY29wZU1hbmFnZXIiLCJ0byIsInRhZ3MiLCJwYXJzZXIiLCJjYWNoZWRQYXJzZXJzIiwicmVzb2x2ZURhdGEiLCJkYXRhIiwiX3RoaXMzIiwiZXJyb3JzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwic2V0RGF0YSIsIm1hcHBlciIsInJlZHVjZSIsImdldFJlbmRlcmVkTWFwIiwiYWxsIiwiX3RoaXMzJG1hcHBlciR0byIsImZyb20iLCJmaWxlUGF0aCIsInNjb3BlTWFuYWdlciIsInJlc29sdmVUYWdzIiwicmVzdWx0IiwiZmluaXNoZWRSZXNvbHZpbmciLCJlcnJzIiwiYXBwbHkiLCJyZXNvbHZlZCIsImVycm9yTG9nZ2luZyIsInJlb3JkZXJNb2R1bGVzIiwibTEiLCJtMiIsInByaW9yaXR5IiwidGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXMiLCJkdXBsaWNhdGVzIiwiX3JlZjIiLCJfdGhpczQiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJ4bWxGaWxlTmFtZXMiLCJ4bWxEb2N1bWVudHMiLCJjb250ZW50IiwiYXNUZXh0IiwiZ2V0VGVtcGxhdGVkRmlsZXMiLCJ0ZW1wbGF0ZWRGaWxlcyIsInZlcmlmeUVycm9ycyIsImdldFJlbHNUeXBlcyIsInJvb3RSZWxzIiwicm9vdFJlbHNYbWwiLCJyb290UmVsYXRpb25zaGlwcyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicmVsc1R5cGVzIiwibGVuIiwiZ2V0QXR0cmlidXRlIiwiZ2V0Q29udGVudFR5cGVzIiwiY29udGVudFR5cGVzIiwiY29udGVudFR5cGVYbWwiLCJvdmVycmlkZXMiLCJfdGhpczUiLCJtaW1ldHlwZSIsIl90aGlzJGdldENvbnRlbnRUeXBlcyIsImZpbGVzQ29udGVudFR5cGVzIiwiaW52ZXJ0ZWRDb250ZW50VHlwZXMiLCJpbnZlcnRNYXAiLCJnZXRGaWxlVHlwZSIsImRvYyIsIkZpbGVUeXBlQ29uZmlnIiwicmVuZGVyQXN5bmMiLCJfdGhpczYiLCJyZW5kZXIiLCJfdGhpczciLCJfdGhpczckbWFwcGVyJHRvIiwiY3JlYXRlRm9sZGVycyIsInN5bmNaaXAiLCJfdGhpczgiLCJyZW1vdmUiLCJnZXRaaXAiLCJwYXRoIiwiY3JlYXRlVGVtcGxhdGVDbGFzc0Zyb21Db250ZW50IiwiX3RoaXM5IiwieG1sdE9wdGlvbnMiLCJjb250ZW50VHlwZSIsInJlbHNUeXBlIiwiWG1sVGVtcGxhdGVyIiwiZ2V0RnVsbFRleHQiLCJ0ZXh0UGF0aCIsIl90aGlzMTAiLCJhbGxFcnJvcnMiLCJFcnJvcnMiLCJYbWxNYXRjaGVyIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/error-logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/error-logger.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n    if (value instanceof Error) {\n        return Object.getOwnPropertyNames(value).concat(\"stack\").reduce(function(error, key) {\n            error[key] = value[key];\n            if (key === \"stack\") {\n                // This is used because in Firefox, stack is not an own property\n                error[key] = value[key].toString();\n            }\n            return error;\n        }, {});\n    }\n    return value;\n}\nfunction logger(error, logging) {\n    // eslint-disable-next-line no-console\n    console.log(JSON.stringify({\n        error: error\n    }, replaceErrors, logging === \"json\" ? 2 : null));\n    if (error.properties && error.properties.errors instanceof Array) {\n        var errorMessages = error.properties.errors.map(function(error) {\n            return error.properties.explanation;\n        }).join(\"\\n\");\n        // eslint-disable-next-line no-console\n        console.log(\"errorMessages\", errorMessages);\n    // errorMessages is a humanly readable message looking like this :\n    // 'The tag beginning with \"foobar\" is unopened'\n    }\n}\nmodule.exports = logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixvSkFBb0o7QUFDcEosU0FBU0EsY0FBY0MsR0FBRyxFQUFFQyxLQUFLO0lBQy9CLElBQUlBLGlCQUFpQkMsT0FBTztRQUMxQixPQUFPQyxPQUFPQyxtQkFBbUIsQ0FBQ0gsT0FBT0ksTUFBTSxDQUFDLFNBQVNDLE1BQU0sQ0FBQyxTQUFVQyxLQUFLLEVBQUVQLEdBQUc7WUFDbEZPLEtBQUssQ0FBQ1AsSUFBSSxHQUFHQyxLQUFLLENBQUNELElBQUk7WUFDdkIsSUFBSUEsUUFBUSxTQUFTO2dCQUNuQixnRUFBZ0U7Z0JBQ2hFTyxLQUFLLENBQUNQLElBQUksR0FBR0MsS0FBSyxDQUFDRCxJQUFJLENBQUNRLFFBQVE7WUFDbEM7WUFDQSxPQUFPRDtRQUNULEdBQUcsQ0FBQztJQUNOO0lBQ0EsT0FBT047QUFDVDtBQUNBLFNBQVNRLE9BQU9GLEtBQUssRUFBRUcsT0FBTztJQUM1QixzQ0FBc0M7SUFDdENDLFFBQVFDLEdBQUcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO1FBQ3pCUCxPQUFPQTtJQUNULEdBQUdSLGVBQWVXLFlBQVksU0FBUyxJQUFJO0lBQzNDLElBQUlILE1BQU1RLFVBQVUsSUFBSVIsTUFBTVEsVUFBVSxDQUFDQyxNQUFNLFlBQVlDLE9BQU87UUFDaEUsSUFBSUMsZ0JBQWdCWCxNQUFNUSxVQUFVLENBQUNDLE1BQU0sQ0FBQ0csR0FBRyxDQUFDLFNBQVVaLEtBQUs7WUFDN0QsT0FBT0EsTUFBTVEsVUFBVSxDQUFDSyxXQUFXO1FBQ3JDLEdBQUdDLElBQUksQ0FBQztRQUNSLHNDQUFzQztRQUN0Q1YsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQk07SUFDN0Isa0VBQWtFO0lBQ2xFLGdEQUFnRDtJQUNsRDtBQUNGO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanM/ZTc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhlIGVycm9yIHRocm93biBoZXJlIGNvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2hlbiBsb2dnZWQgd2l0aCBKU09OLnN0cmluZ2lmeSAoaXQgY29udGFpbnMgYSBwcm9wZXJ0aWVzIG9iamVjdCBjb250YWluaW5nIGFsbCBzdWJlcnJvcnMpLlxuZnVuY3Rpb24gcmVwbGFjZUVycm9ycyhrZXksIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5jb25jYXQoXCJzdGFja1wiKS5yZWR1Y2UoZnVuY3Rpb24gKGVycm9yLCBrZXkpIHtcbiAgICAgIGVycm9yW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKGtleSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBiZWNhdXNlIGluIEZpcmVmb3gsIHN0YWNrIGlzIG5vdCBhbiBvd24gcHJvcGVydHlcbiAgICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlW2tleV0udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbG9nZ2VyKGVycm9yLCBsb2dnaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHtcbiAgICBlcnJvcjogZXJyb3JcbiAgfSwgcmVwbGFjZUVycm9ycywgbG9nZ2luZyA9PT0gXCJqc29uXCIgPyAyIDogbnVsbCkpO1xuICBpZiAoZXJyb3IucHJvcGVydGllcyAmJiBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGVycm9yTWVzc2FnZXMgPSBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbjtcbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coXCJlcnJvck1lc3NhZ2VzXCIsIGVycm9yTWVzc2FnZXMpO1xuICAgIC8vIGVycm9yTWVzc2FnZXMgaXMgYSBodW1hbmx5IHJlYWRhYmxlIG1lc3NhZ2UgbG9va2luZyBsaWtlIHRoaXMgOlxuICAgIC8vICdUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFwiZm9vYmFyXCIgaXMgdW5vcGVuZWQnXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyOyJdLCJuYW1lcyI6WyJyZXBsYWNlRXJyb3JzIiwia2V5IiwidmFsdWUiLCJFcnJvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJyZWR1Y2UiLCJlcnJvciIsInRvU3RyaW5nIiwibG9nZ2VyIiwibG9nZ2luZyIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwicHJvcGVydGllcyIsImVycm9ycyIsIkFycmF5IiwiZXJyb3JNZXNzYWdlcyIsIm1hcCIsImV4cGxhbmF0aW9uIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/errors.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"), last = _require.last, first = _require.first;\nfunction XTError(message) {\n    this.name = \"GenericError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n    this.name = \"TemplateError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n    this.name = \"RenderingError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n    this.name = \"ScopeParserError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n    this.name = \"InternalError\";\n    this.properties = {\n        explanation: \"InternalError\"\n    };\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n    this.name = \"APIVersionError\";\n    this.properties = {\n        explanation: \"APIVersionError\"\n    };\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n    var err = new XTAPIVersionError(msg);\n    err.properties = _objectSpread({\n        id: \"api_version_error\"\n    }, properties);\n    throw err;\n}\nfunction throwMultiError(errors) {\n    var err = new XTTemplateError(\"Multi error\");\n    err.properties = {\n        errors: errors,\n        id: \"multi_error\",\n        explanation: \"The template has multiple errors\"\n    };\n    throw err;\n}\nfunction getUnopenedTagException(options) {\n    var err = new XTTemplateError(\"Unopened tag\");\n    err.properties = {\n        xtag: last(options.xtag.split(\" \")),\n        id: \"unopened_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" is unopened')\n    };\n    return err;\n}\nfunction getDuplicateOpenTagException(options) {\n    var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")),\n        id: \"duplicate_open_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" has duplicate open tags')\n    };\n    return err;\n}\nfunction getDuplicateCloseTagException(options) {\n    var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")),\n        id: \"duplicate_close_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag ending with \"'.concat(options.xtag.substr(0, 10), '\" has duplicate close tags')\n    };\n    return err;\n}\nfunction getUnclosedTagException(options) {\n    var err = new XTTemplateError(\"Unclosed tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")).substr(1),\n        id: \"unclosed_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" is unclosed')\n    };\n    return err;\n}\nfunction throwXmlTagNotFound(options) {\n    var err = new XTTemplateError('No tag \"'.concat(options.element, '\" was found at the ').concat(options.position));\n    var part = options.parsed[options.index];\n    err.properties = {\n        id: \"no_xml_tag_found_at_\".concat(options.position),\n        explanation: 'No tag \"'.concat(options.element, '\" was found at the ').concat(options.position),\n        offset: part.offset,\n        part: part,\n        parsed: options.parsed,\n        index: options.index,\n        element: options.element\n    };\n    throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n    var tag = _ref.tag, value = _ref.value, offset = _ref.offset;\n    var err = new XTRenderingError(\"There are some XML corrupt characters\");\n    err.properties = {\n        id: \"invalid_xml_characters\",\n        xtag: tag,\n        value: value,\n        offset: offset,\n        explanation: \"There are some corrupt characters for the field \".concat(tag)\n    };\n    return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n    var tag = _ref2.tag, value = _ref2.value, offset = _ref2.offset;\n    var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n    err.properties = {\n        id: \"invalid_raw_xml_value\",\n        xtag: tag,\n        value: value,\n        offset: offset,\n        explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n    };\n    return err;\n}\nfunction throwExpandNotFound(options) {\n    var _options$part = options.part, value = _options$part.value, offset = _options$part.offset, _options$id = options.id, id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id, _options$message = options.message, message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n    var part = options.part;\n    var _options$explanation = options.explanation, explanation = _options$explanation === void 0 ? 'The tag \"'.concat(value, '\" is not inside a paragraph') : _options$explanation;\n    if (typeof explanation === \"function\") {\n        explanation = explanation(part);\n    }\n    var err = new XTTemplateError(message);\n    err.properties = {\n        id: id,\n        explanation: explanation,\n        rootError: options.rootError,\n        xtag: value,\n        offset: offset,\n        postparsed: options.postparsed,\n        expandTo: options.expandTo,\n        index: options.index\n    };\n    throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n    var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n    var tag = options.part.value;\n    err.properties = {\n        id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n        explanation: 'The raw tag \"'.concat(tag, '\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.'),\n        xtag: tag,\n        offset: options.part.offset,\n        paragraphParts: options.paragraphParts\n    };\n    throw err;\n}\nfunction getUnmatchedLoopException(part) {\n    var location = part.location, offset = part.offset, square = part.square;\n    var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n    var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n    var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n    var tag = part.value;\n    err.properties = {\n        id: \"\".concat(t, \"_loop\"),\n        explanation: 'The loop with tag \"'.concat(tag, '\" is ').concat(t),\n        xtag: tag,\n        offset: offset\n    };\n    if (square) {\n        err.properties.square = square;\n    }\n    return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n    var err = new XTTemplateError(\"Unbalanced loop tag\");\n    var lastL = lastPair[0].part.value;\n    var lastR = lastPair[1].part.value;\n    var l = pair[0].part.value;\n    var r = pair[1].part.value;\n    err.properties = {\n        id: \"unbalanced_loop_tags\",\n        explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n        offset: [\n            lastPair[0].part.offset,\n            pair[1].part.offset\n        ],\n        lastPair: {\n            left: lastPair[0].part.value,\n            right: lastPair[1].part.value\n        },\n        pair: {\n            left: pair[0].part.value,\n            right: pair[1].part.value\n        }\n    };\n    return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n    var tags = _ref3.tags;\n    var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n    err.properties = {\n        id: \"closing_tag_does_not_match_opening_tag\",\n        explanation: 'The tag \"'.concat(tags[0].value, '\" is closed by the tag \"').concat(tags[1].value, '\"'),\n        openingtag: first(tags).value,\n        offset: [\n            first(tags).offset,\n            last(tags).offset\n        ],\n        closingtag: last(tags).value\n    };\n    return err;\n}\nfunction getScopeCompilationError(_ref4) {\n    var tag = _ref4.tag, rootError = _ref4.rootError, offset = _ref4.offset;\n    var err = new XTScopeParserError(\"Scope parser compilation failed\");\n    err.properties = {\n        id: \"scopeparser_compilation_failed\",\n        offset: offset,\n        xtag: tag,\n        explanation: 'The scope parser for the tag \"'.concat(tag, '\" failed to compile'),\n        rootError: rootError\n    };\n    return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n    var tag = _ref5.tag, scope = _ref5.scope, error = _ref5.error, offset = _ref5.offset;\n    var err = new XTScopeParserError(\"Scope parser execution failed\");\n    err.properties = {\n        id: \"scopeparser_execution_failed\",\n        explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n        scope: scope,\n        offset: offset,\n        xtag: tag,\n        rootError: error\n    };\n    return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n    var tag = _ref6.tag, offset = _ref6.offset;\n    var err = new XTTemplateError('The position of the loop tags \"'.concat(tag, '\" would produce invalid XML'));\n    err.properties = {\n        xtag: tag,\n        id: \"loop_position_invalid\",\n        explanation: 'The tags \"'.concat(tag, '\" are misplaced in the document, for example one of them is in a table and the other one outside the table'),\n        offset: offset\n    };\n    return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n    var errorMsg = 'Unimplemented tag type \"'.concat(part.type, '\"');\n    if (part.module) {\n        errorMsg += ' \"'.concat(part.module, '\"');\n    }\n    var err = new XTTemplateError(errorMsg);\n    err.properties = {\n        part: part,\n        index: index,\n        id: \"unimplemented_tag_type\"\n    };\n    throw err;\n}\nfunction throwMalformedXml() {\n    var err = new XTInternalError(\"Malformed xml\");\n    err.properties = {\n        explanation: \"The template contains malformed xml\",\n        id: \"malformed_xml\"\n    };\n    throw err;\n}\nfunction throwResolveBeforeCompile() {\n    var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n    err.properties = {\n        id: \"resolve_before_compile\",\n        explanation: \"You must run `.compile()` before running `.resolveData()`\"\n    };\n    throw err;\n}\nfunction throwRenderInvalidTemplate() {\n    var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n    err.properties = {\n        id: \"render_on_invalid_template\",\n        explanation: \"You should not call .render on a document that had compilation errors\"\n    };\n    throw err;\n}\nfunction throwRenderTwice() {\n    var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n    err.properties = {\n        id: \"render_twice\",\n        explanation: \"You should not call .render twice on the same docxtemplater instance\"\n    };\n    throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n    var files = Object.keys(zip.files).slice(0, 10);\n    var msg = \"\";\n    if (files.length === 0) {\n        msg = \"Empty zip file\";\n    } else {\n        msg = \"Zip file contains : \".concat(files.join(\",\"));\n    }\n    var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n    err.properties = {\n        id: \"filetype_not_identified\",\n        explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n    };\n    throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n    var err = new XTTemplateError(\"An XML file has invalid xml\");\n    err.properties = {\n        id: \"file_has_invalid_xml\",\n        content: content,\n        offset: offset,\n        explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n    };\n    throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n    var err = new XTInternalError('The filetype \"'.concat(fileType, '\" is not handled by docxtemplater'));\n    err.properties = {\n        id: \"filetype_not_handled\",\n        explanation: 'The file you are trying to generate is of type \"'.concat(fileType, '\", but only docx and pptx formats are handled'),\n        fileType: fileType\n    };\n    throw err;\n}\nmodule.exports = {\n    XTError: XTError,\n    XTTemplateError: XTTemplateError,\n    XTInternalError: XTInternalError,\n    XTScopeParserError: XTScopeParserError,\n    XTAPIVersionError: XTAPIVersionError,\n    // Remove this alias in v4\n    RenderingError: XTRenderingError,\n    XTRenderingError: XTRenderingError,\n    getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n    getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n    getScopeCompilationError: getScopeCompilationError,\n    getScopeParserExecutionError: getScopeParserExecutionError,\n    getUnclosedTagException: getUnclosedTagException,\n    getUnopenedTagException: getUnopenedTagException,\n    getUnmatchedLoopException: getUnmatchedLoopException,\n    getDuplicateCloseTagException: getDuplicateCloseTagException,\n    getDuplicateOpenTagException: getDuplicateOpenTagException,\n    getCorruptCharactersException: getCorruptCharactersException,\n    getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n    getUnbalancedLoopException: getUnbalancedLoopException,\n    throwApiVersionError: throwApiVersionError,\n    throwFileTypeNotHandled: throwFileTypeNotHandled,\n    throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n    throwMalformedXml: throwMalformedXml,\n    throwMultiError: throwMultiError,\n    throwExpandNotFound: throwExpandNotFound,\n    throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n    throwUnimplementedTagType: throwUnimplementedTagType,\n    throwXmlTagNotFound: throwXmlTagNotFound,\n    throwXmlInvalid: throwXmlInvalid,\n    throwResolveBeforeCompile: throwResolveBeforeCompile,\n    throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n    throwRenderTwice: throwRenderTwice\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSVgsSUFBSVMsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVZLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdDLEdBQUdPLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEVBQUVPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUyxjQUFjWCxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlXLFVBQVVDLE1BQU0sRUFBRVosSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVUsU0FBUyxDQUFDWCxFQUFFLEdBQUdXLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR1ksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSWMsZ0JBQWdCZixHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFL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ZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanM/MmE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZS5maXJzdDtcbmZ1bmN0aW9uIFhURXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkdlbmVyaWNFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5mdW5jdGlvbiBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlRlbXBsYXRlRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUVGVtcGxhdGVFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRSZW5kZXJpbmdFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUmVuZGVyaW5nRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUUmVuZGVyaW5nRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUU2NvcGVQYXJzZXJFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiU2NvcGVQYXJzZXJFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRTY29wZVBhcnNlckVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVEludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkludGVybmFsRXJyb3JcIjtcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIkludGVybmFsRXJyb3JcIlxuICB9O1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRJbnRlcm5hbEVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVEFQSVZlcnNpb25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiQVBJVmVyc2lvbkVycm9yXCI7XG4gIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICBleHBsYW5hdGlvbjogXCJBUElWZXJzaW9uRXJyb3JcIlxuICB9O1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRBUElWZXJzaW9uRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIHRocm93QXBpVmVyc2lvbkVycm9yKG1zZywgcHJvcGVydGllcykge1xuICB2YXIgZXJyID0gbmV3IFhUQVBJVmVyc2lvbkVycm9yKG1zZyk7XG4gIGVyci5wcm9wZXJ0aWVzID0gX29iamVjdFNwcmVhZCh7XG4gICAgaWQ6IFwiYXBpX3ZlcnNpb25fZXJyb3JcIlxuICB9LCBwcm9wZXJ0aWVzKTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dNdWx0aUVycm9yKGVycm9ycykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk11bHRpIGVycm9yXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICBpZDogXCJtdWx0aV9lcnJvclwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0ZW1wbGF0ZSBoYXMgbXVsdGlwbGUgZXJyb3JzXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlVub3BlbmVkIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogbGFzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJ1bm9wZW5lZF90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGlzIHVub3BlbmVkXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJEdXBsaWNhdGUgb3BlbiB0YWcsIGV4cGVjdGVkIG9uZSBvcGVuIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwiZHVwbGljYXRlX29wZW5fdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBoYXMgZHVwbGljYXRlIG9wZW4gdGFnc1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkR1cGxpY2F0ZSBjbG9zZSB0YWcsIGV4cGVjdGVkIG9uZSBjbG9zZSB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IGZpcnN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcImR1cGxpY2F0ZV9jbG9zZV90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgZW5kaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGhhcyBkdXBsaWNhdGUgY2xvc2UgdGFnc1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlVuY2xvc2VkIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSkuc3Vic3RyKDEpLFxuICAgIGlkOiBcInVuY2xvc2VkX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaXMgdW5jbG9zZWRcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93WG1sVGFnTm90Rm91bmQob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5vIHRhZyBcXFwiXCIuY29uY2F0KG9wdGlvbnMuZWxlbWVudCwgXCJcXFwiIHdhcyBmb3VuZCBhdCB0aGUgXCIpLmNvbmNhdChvcHRpb25zLnBvc2l0aW9uKSk7XG4gIHZhciBwYXJ0ID0gb3B0aW9ucy5wYXJzZWRbb3B0aW9ucy5pbmRleF07XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcIm5vX3htbF90YWdfZm91bmRfYXRfXCIuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgIGV4cGxhbmF0aW9uOiBcIk5vIHRhZyBcXFwiXCIuY29uY2F0KG9wdGlvbnMuZWxlbWVudCwgXCJcXFwiIHdhcyBmb3VuZCBhdCB0aGUgXCIpLmNvbmNhdChvcHRpb25zLnBvc2l0aW9uKSxcbiAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0LFxuICAgIHBhcnQ6IHBhcnQsXG4gICAgcGFyc2VkOiBvcHRpb25zLnBhcnNlZCxcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICBlbGVtZW50OiBvcHRpb25zLmVsZW1lbnRcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24oX3JlZikge1xuICB2YXIgdGFnID0gX3JlZi50YWcsXG4gICAgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUUmVuZGVyaW5nRXJyb3IoXCJUaGVyZSBhcmUgc29tZSBYTUwgY29ycnVwdCBjaGFyYWN0ZXJzXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJpbnZhbGlkX3htbF9jaGFyYWN0ZXJzXCIsXG4gICAgeHRhZzogdGFnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGVyZSBhcmUgc29tZSBjb3JydXB0IGNoYXJhY3RlcnMgZm9yIHRoZSBmaWVsZCBcIi5jb25jYXQodGFnKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uKF9yZWYyKSB7XG4gIHZhciB0YWcgPSBfcmVmMi50YWcsXG4gICAgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICBvZmZzZXQgPSBfcmVmMi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRSZW5kZXJpbmdFcnJvcihcIk5vbiBzdHJpbmcgdmFsdWVzIGFyZSBub3QgYWxsb3dlZCBmb3IgcmF3WE1MIHRhZ3NcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImludmFsaWRfcmF3X3htbF92YWx1ZVwiLFxuICAgIHh0YWc6IHRhZyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHZhbHVlIG9mIHRoZSByYXcgdGFnIDogJ1wiLmNvbmNhdCh0YWcsIFwiJyBpcyBub3QgYSBzdHJpbmdcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RXhwYW5kTm90Rm91bmQob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkcGFydCA9IG9wdGlvbnMucGFydCxcbiAgICB2YWx1ZSA9IF9vcHRpb25zJHBhcnQudmFsdWUsXG4gICAgb2Zmc2V0ID0gX29wdGlvbnMkcGFydC5vZmZzZXQsXG4gICAgX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkLFxuICAgIGlkID0gX29wdGlvbnMkaWQgPT09IHZvaWQgMCA/IFwicmF3X3RhZ19vdXRlcnhtbF9pbnZhbGlkXCIgOiBfb3B0aW9ucyRpZCxcbiAgICBfb3B0aW9ucyRtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgIG1lc3NhZ2UgPSBfb3B0aW9ucyRtZXNzYWdlID09PSB2b2lkIDAgPyBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiIDogX29wdGlvbnMkbWVzc2FnZTtcbiAgdmFyIHBhcnQgPSBvcHRpb25zLnBhcnQ7XG4gIHZhciBfb3B0aW9ucyRleHBsYW5hdGlvbiA9IG9wdGlvbnMuZXhwbGFuYXRpb24sXG4gICAgZXhwbGFuYXRpb24gPSBfb3B0aW9ucyRleHBsYW5hdGlvbiA9PT0gdm9pZCAwID8gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiBpcyBub3QgaW5zaWRlIGEgcGFyYWdyYXBoXCIpIDogX29wdGlvbnMkZXhwbGFuYXRpb247XG4gIGlmICh0eXBlb2YgZXhwbGFuYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb24ocGFydCk7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBpZCxcbiAgICBleHBsYW5hdGlvbjogZXhwbGFuYXRpb24sXG4gICAgcm9vdEVycm9yOiBvcHRpb25zLnJvb3RFcnJvcixcbiAgICB4dGFnOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBwb3N0cGFyc2VkOiBvcHRpb25zLnBvc3RwYXJzZWQsXG4gICAgZXhwYW5kVG86IG9wdGlvbnMuZXhwYW5kVG8sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXhcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlJhdyB0YWcgc2hvdWxkIGJlIHRoZSBvbmx5IHRleHQgaW4gcGFyYWdyYXBoXCIpO1xuICB2YXIgdGFnID0gb3B0aW9ucy5wYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyYXdfeG1sX3RhZ19zaG91bGRfYmVfb25seV90ZXh0X2luX3BhcmFncmFwaFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSByYXcgdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgc2hvdWxkIGJlIHRoZSBvbmx5IHRleHQgaW4gdGhpcyBwYXJhZ3JhcGguIFRoaXMgbWVhbnMgdGhhdCB0aGlzIHRhZyBzaG91bGQgbm90IGJlIHN1cnJvdW5kZWQgYnkgYW55IHRleHQgb3Igc3BhY2VzLlwiKSxcbiAgICB4dGFnOiB0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLnBhcnQub2Zmc2V0LFxuICAgIHBhcmFncmFwaFBhcnRzOiBvcHRpb25zLnBhcmFncmFwaFBhcnRzXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24ocGFydCkge1xuICB2YXIgbG9jYXRpb24gPSBwYXJ0LmxvY2F0aW9uLFxuICAgIG9mZnNldCA9IHBhcnQub2Zmc2V0LFxuICAgIHNxdWFyZSA9IHBhcnQuc3F1YXJlO1xuICB2YXIgdCA9IGxvY2F0aW9uID09PSBcInN0YXJ0XCIgPyBcInVuY2xvc2VkXCIgOiBcInVub3BlbmVkXCI7XG4gIHZhciBUID0gbG9jYXRpb24gPT09IFwic3RhcnRcIiA/IFwiVW5jbG9zZWRcIiA6IFwiVW5vcGVuZWRcIjtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJcIi5jb25jYXQoVCwgXCIgbG9vcFwiKSk7XG4gIHZhciB0YWcgPSBwYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJcIi5jb25jYXQodCwgXCJfbG9vcFwiKSxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgbG9vcCB3aXRoIHRhZyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGlzIFwiKS5jb25jYXQodCksXG4gICAgeHRhZzogdGFnLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIGlmIChzcXVhcmUpIHtcbiAgICBlcnIucHJvcGVydGllcy5zcXVhcmUgPSBzcXVhcmU7XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5iYWxhbmNlZCBsb29wIHRhZ1wiKTtcbiAgdmFyIGxhc3RMID0gbGFzdFBhaXJbMF0ucGFydC52YWx1ZTtcbiAgdmFyIGxhc3RSID0gbGFzdFBhaXJbMV0ucGFydC52YWx1ZTtcbiAgdmFyIGwgPSBwYWlyWzBdLnBhcnQudmFsdWU7XG4gIHZhciByID0gcGFpclsxXS5wYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJ1bmJhbGFuY2VkX2xvb3BfdGFnc1wiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlVuYmFsYW5jZWQgbG9vcCB0YWdzIHsjXCIuY29uY2F0KGxhc3RMLCBcIn17L1wiKS5jb25jYXQobGFzdFIsIFwifXsjXCIpLmNvbmNhdChsLCBcIn17L1wiKS5jb25jYXQociwgXCJ9XCIpLFxuICAgIG9mZnNldDogW2xhc3RQYWlyWzBdLnBhcnQub2Zmc2V0LCBwYWlyWzFdLnBhcnQub2Zmc2V0XSxcbiAgICBsYXN0UGFpcjoge1xuICAgICAgbGVmdDogbGFzdFBhaXJbMF0ucGFydC52YWx1ZSxcbiAgICAgIHJpZ2h0OiBsYXN0UGFpclsxXS5wYXJ0LnZhbHVlXG4gICAgfSxcbiAgICBwYWlyOiB7XG4gICAgICBsZWZ0OiBwYWlyWzBdLnBhcnQudmFsdWUsXG4gICAgICByaWdodDogcGFpclsxXS5wYXJ0LnZhbHVlXG4gICAgfVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyhfcmVmMykge1xuICB2YXIgdGFncyA9IF9yZWYzLnRhZ3M7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiQ2xvc2luZyB0YWcgZG9lcyBub3QgbWF0Y2ggb3BlbmluZyB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImNsb3NpbmdfdGFnX2RvZXNfbm90X21hdGNoX29wZW5pbmdfdGFnXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBcXFwiXCIuY29uY2F0KHRhZ3NbMF0udmFsdWUsIFwiXFxcIiBpcyBjbG9zZWQgYnkgdGhlIHRhZyBcXFwiXCIpLmNvbmNhdCh0YWdzWzFdLnZhbHVlLCBcIlxcXCJcIiksXG4gICAgb3BlbmluZ3RhZzogZmlyc3QodGFncykudmFsdWUsXG4gICAgb2Zmc2V0OiBbZmlyc3QodGFncykub2Zmc2V0LCBsYXN0KHRhZ3MpLm9mZnNldF0sXG4gICAgY2xvc2luZ3RhZzogbGFzdCh0YWdzKS52YWx1ZVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yKF9yZWY0KSB7XG4gIHZhciB0YWcgPSBfcmVmNC50YWcsXG4gICAgcm9vdEVycm9yID0gX3JlZjQucm9vdEVycm9yLFxuICAgIG9mZnNldCA9IF9yZWY0Lm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFNjb3BlUGFyc2VyRXJyb3IoXCJTY29wZSBwYXJzZXIgY29tcGlsYXRpb24gZmFpbGVkXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJzY29wZXBhcnNlcl9jb21waWxhdGlvbl9mYWlsZWRcIixcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB4dGFnOiB0YWcsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHNjb3BlIHBhcnNlciBmb3IgdGhlIHRhZyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGZhaWxlZCB0byBjb21waWxlXCIpLFxuICAgIHJvb3RFcnJvcjogcm9vdEVycm9yXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yKF9yZWY1KSB7XG4gIHZhciB0YWcgPSBfcmVmNS50YWcsXG4gICAgc2NvcGUgPSBfcmVmNS5zY29wZSxcbiAgICBlcnJvciA9IF9yZWY1LmVycm9yLFxuICAgIG9mZnNldCA9IF9yZWY1Lm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFNjb3BlUGFyc2VyRXJyb3IoXCJTY29wZSBwYXJzZXIgZXhlY3V0aW9uIGZhaWxlZFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwic2NvcGVwYXJzZXJfZXhlY3V0aW9uX2ZhaWxlZFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBzY29wZSBwYXJzZXIgZm9yIHRoZSB0YWcgXCIuY29uY2F0KHRhZywgXCIgZmFpbGVkIHRvIGV4ZWN1dGVcIiksXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHh0YWc6IHRhZyxcbiAgICByb290RXJyb3I6IGVycm9yXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcihfcmVmNikge1xuICB2YXIgdGFnID0gX3JlZjYudGFnLFxuICAgIG9mZnNldCA9IF9yZWY2Lm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxvb3AgdGFncyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIHdvdWxkIHByb2R1Y2UgaW52YWxpZCBYTUxcIikpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiB0YWcsXG4gICAgaWQ6IFwibG9vcF9wb3NpdGlvbl9pbnZhbGlkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZ3MgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBhcmUgbWlzcGxhY2VkIGluIHRoZSBkb2N1bWVudCwgZm9yIGV4YW1wbGUgb25lIG9mIHRoZW0gaXMgaW4gYSB0YWJsZSBhbmQgdGhlIG90aGVyIG9uZSBvdXRzaWRlIHRoZSB0YWJsZVwiKSxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZShwYXJ0LCBpbmRleCkge1xuICB2YXIgZXJyb3JNc2cgPSBcIlVuaW1wbGVtZW50ZWQgdGFnIHR5cGUgXFxcIlwiLmNvbmNhdChwYXJ0LnR5cGUsIFwiXFxcIlwiKTtcbiAgaWYgKHBhcnQubW9kdWxlKSB7XG4gICAgZXJyb3JNc2cgKz0gXCIgXFxcIlwiLmNvbmNhdChwYXJ0Lm1vZHVsZSwgXCJcXFwiXCIpO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKGVycm9yTXNnKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgcGFydDogcGFydCxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgaWQ6IFwidW5pbXBsZW1lbnRlZF90YWdfdHlwZVwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93TWFsZm9ybWVkWG1sKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIk1hbGZvcm1lZCB4bWxcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0ZW1wbGF0ZSBjb250YWlucyBtYWxmb3JtZWQgeG1sXCIsXG4gICAgaWQ6IFwibWFsZm9ybWVkX3htbFwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiWW91IG11c3QgcnVuIGAuY29tcGlsZSgpYCBiZWZvcmUgcnVubmluZyBgLnJlc29sdmVEYXRhKClgXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyZXNvbHZlX2JlZm9yZV9jb21waWxlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IG11c3QgcnVuIGAuY29tcGlsZSgpYCBiZWZvcmUgcnVubmluZyBgLnJlc29sdmVEYXRhKClgXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIG9uIGEgZG9jdW1lbnQgdGhhdCBoYWQgY29tcGlsYXRpb24gZXJyb3JzXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyZW5kZXJfb25faW52YWxpZF90ZW1wbGF0ZVwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciBvbiBhIGRvY3VtZW50IHRoYXQgaGFkIGNvbXBpbGF0aW9uIGVycm9yc1wiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93UmVuZGVyVHdpY2UoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIHR3aWNlIG9uIHRoZSBzYW1lIGRvY3h0ZW1wbGF0ZXIgaW5zdGFuY2VcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlbmRlcl90d2ljZVwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciB0d2ljZSBvbiB0aGUgc2FtZSBkb2N4dGVtcGxhdGVyIGluc3RhbmNlXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQoemlwKSB7XG4gIHZhciBmaWxlcyA9IE9iamVjdC5rZXlzKHppcC5maWxlcykuc2xpY2UoMCwgMTApO1xuICB2YXIgbXNnID0gXCJcIjtcbiAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIG1zZyA9IFwiRW1wdHkgemlwIGZpbGVcIjtcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBcIlppcCBmaWxlIGNvbnRhaW5zIDogXCIuY29uY2F0KGZpbGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIlRoZSBmaWxldHlwZSBmb3IgdGhpcyBmaWxlIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkLCBpcyB0aGlzIGZpbGUgY29ycnVwdGVkID8gXCIuY29uY2F0KG1zZykpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJmaWxldHlwZV9ub3RfaWRlbnRpZmllZFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBmaWxldHlwZSBmb3IgdGhpcyBmaWxlIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkLCBpcyB0aGlzIGZpbGUgY29ycnVwdGVkID8gXCIuY29uY2F0KG1zZylcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dYbWxJbnZhbGlkKGNvbnRlbnQsIG9mZnNldCkge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkFuIFhNTCBmaWxlIGhhcyBpbnZhbGlkIHhtbFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiZmlsZV9oYXNfaW52YWxpZF94bWxcIixcbiAgICBjb250ZW50OiBjb250ZW50LFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBkb2N4IGNvbnRhaW5zIGludmFsaWQgWE1MLCBpdCBpcyBtb3N0IGxpa2VseSBjb3JydXB0XCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQoZmlsZVR5cGUpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGUgZmlsZXR5cGUgXFxcIlwiLmNvbmNhdChmaWxlVHlwZSwgXCJcXFwiIGlzIG5vdCBoYW5kbGVkIGJ5IGRvY3h0ZW1wbGF0ZXJcIikpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJmaWxldHlwZV9ub3RfaGFuZGxlZFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBmaWxlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIGlzIG9mIHR5cGUgXFxcIlwiLmNvbmNhdChmaWxlVHlwZSwgXCJcXFwiLCBidXQgb25seSBkb2N4IGFuZCBwcHR4IGZvcm1hdHMgYXJlIGhhbmRsZWRcIiksXG4gICAgZmlsZVR5cGU6IGZpbGVUeXBlXG4gIH07XG4gIHRocm93IGVycjtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBYVEVycm9yOiBYVEVycm9yLFxuICBYVFRlbXBsYXRlRXJyb3I6IFhUVGVtcGxhdGVFcnJvcixcbiAgWFRJbnRlcm5hbEVycm9yOiBYVEludGVybmFsRXJyb3IsXG4gIFhUU2NvcGVQYXJzZXJFcnJvcjogWFRTY29wZVBhcnNlckVycm9yLFxuICBYVEFQSVZlcnNpb25FcnJvcjogWFRBUElWZXJzaW9uRXJyb3IsXG4gIC8vIFJlbW92ZSB0aGlzIGFsaWFzIGluIHY0XG4gIFJlbmRlcmluZ0Vycm9yOiBYVFJlbmRlcmluZ0Vycm9yLFxuICBYVFJlbmRlcmluZ0Vycm9yOiBYVFJlbmRlcmluZ0Vycm9yLFxuICBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnOiBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnLFxuICBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcjogZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IsXG4gIGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcjogZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yLFxuICBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yOiBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yLFxuICBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbjogZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24sXG4gIGdldFVub3BlbmVkVGFnRXhjZXB0aW9uOiBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbjogZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb246IGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uOiBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uLFxuICBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbjogZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24sXG4gIGdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbjogZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uLFxuICBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbjogZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24sXG4gIHRocm93QXBpVmVyc2lvbkVycm9yOiB0aHJvd0FwaVZlcnNpb25FcnJvcixcbiAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQ6IHRocm93RmlsZVR5cGVOb3RIYW5kbGVkLFxuICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZDogdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQsXG4gIHRocm93TWFsZm9ybWVkWG1sOiB0aHJvd01hbGZvcm1lZFhtbCxcbiAgdGhyb3dNdWx0aUVycm9yOiB0aHJvd011bHRpRXJyb3IsXG4gIHRocm93RXhwYW5kTm90Rm91bmQ6IHRocm93RXhwYW5kTm90Rm91bmQsXG4gIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoOiB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCxcbiAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZTogdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSxcbiAgdGhyb3dYbWxUYWdOb3RGb3VuZDogdGhyb3dYbWxUYWdOb3RGb3VuZCxcbiAgdGhyb3dYbWxJbnZhbGlkOiB0aHJvd1htbEludmFsaWQsXG4gIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGU6IHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUsXG4gIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlOiB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSxcbiAgdGhyb3dSZW5kZXJUd2ljZTogdGhyb3dSZW5kZXJUd2ljZVxufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImxhc3QiLCJmaXJzdCIsIlhURXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsInN0YWNrIiwiRXJyb3IiLCJYVFRlbXBsYXRlRXJyb3IiLCJYVFJlbmRlcmluZ0Vycm9yIiwiWFRTY29wZVBhcnNlckVycm9yIiwiWFRJbnRlcm5hbEVycm9yIiwicHJvcGVydGllcyIsImV4cGxhbmF0aW9uIiwiWFRBUElWZXJzaW9uRXJyb3IiLCJ0aHJvd0FwaVZlcnNpb25FcnJvciIsIm1zZyIsImVyciIsImlkIiwidGhyb3dNdWx0aUVycm9yIiwiZXJyb3JzIiwiZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24iLCJvcHRpb25zIiwieHRhZyIsInNwbGl0IiwiY29udGV4dCIsIm9mZnNldCIsImxJbmRleCIsImNvbmNhdCIsInN1YnN0ciIsImdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24iLCJnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbiIsImdldFVuY2xvc2VkVGFnRXhjZXB0aW9uIiwidGhyb3dYbWxUYWdOb3RGb3VuZCIsImVsZW1lbnQiLCJwb3NpdGlvbiIsInBhcnQiLCJwYXJzZWQiLCJpbmRleCIsImdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uIiwiX3JlZiIsInRhZyIsImdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbiIsIl9yZWYyIiwidGhyb3dFeHBhbmROb3RGb3VuZCIsIl9vcHRpb25zJHBhcnQiLCJfb3B0aW9ucyRpZCIsIl9vcHRpb25zJG1lc3NhZ2UiLCJfb3B0aW9ucyRleHBsYW5hdGlvbiIsInJvb3RFcnJvciIsInBvc3RwYXJzZWQiLCJleHBhbmRUbyIsInRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoIiwicGFyYWdyYXBoUGFydHMiLCJnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uIiwibG9jYXRpb24iLCJzcXVhcmUiLCJUIiwiZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24iLCJwYWlyIiwibGFzdFBhaXIiLCJsYXN0TCIsImxhc3RSIiwibCIsImxlZnQiLCJyaWdodCIsImdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWciLCJfcmVmMyIsInRhZ3MiLCJvcGVuaW5ndGFnIiwiY2xvc2luZ3RhZyIsImdldFNjb3BlQ29tcGlsYXRpb25FcnJvciIsIl9yZWY0IiwiZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvciIsIl9yZWY1Iiwic2NvcGUiLCJlcnJvciIsImdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yIiwiX3JlZjYiLCJ0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlIiwiZXJyb3JNc2ciLCJ0eXBlIiwibW9kdWxlIiwidGhyb3dNYWxmb3JtZWRYbWwiLCJ0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlIiwidGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUiLCJ0aHJvd1JlbmRlclR3aWNlIiwidGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQiLCJ6aXAiLCJmaWxlcyIsInNsaWNlIiwiam9pbiIsInRocm93WG1sSW52YWxpZCIsImNvbnRlbnQiLCJ0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCIsImZpbGVUeXBlIiwiZXhwb3J0cyIsIlJlbmRlcmluZ0Vycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/file-type-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/docxtemplater/js/file-type-config.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n    return {\n        getTemplatedFiles: function getTemplatedFiles() {\n            return [];\n        },\n        textPath: function textPath(doc) {\n            return doc.textTarget;\n        },\n        tagsXmlTextArray: [\n            \"Company\",\n            \"HyperlinkBase\",\n            \"Manager\",\n            \"cp:category\",\n            \"cp:keywords\",\n            \"dc:creator\",\n            \"dc:description\",\n            \"dc:subject\",\n            \"dc:title\",\n            \"cp:contentStatus\",\n            \"w:t\",\n            \"m:t\",\n            \"vt:lpstr\",\n            \"vt:lpwstr\"\n        ],\n        tagsXmlLexedArray: [\n            \"w:proofState\",\n            \"w:tc\",\n            \"w:tr\",\n            \"w:tbl\",\n            \"w:body\",\n            \"w:document\",\n            \"w:p\",\n            \"w:r\",\n            \"w:br\",\n            \"w:rPr\",\n            \"w:pPr\",\n            \"w:spacing\",\n            \"w:sdtContent\",\n            \"w:sdt\",\n            \"w:drawing\",\n            \"w:sectPr\",\n            \"w:type\",\n            \"w:headerReference\",\n            \"w:footerReference\",\n            \"w:bookmarkStart\",\n            \"w:bookmarkEnd\",\n            \"w:commentRangeStart\",\n            \"w:commentRangeEnd\",\n            \"w:commentReference\"\n        ],\n        droppedTagsInsidePlaceholder: [\n            \"w:p\",\n            \"w:br\",\n            \"w:bookmarkStart\",\n            \"w:bookmarkEnd\"\n        ],\n        expandTags: [\n            {\n                contains: \"w:tc\",\n                expand: \"w:tr\"\n            }\n        ],\n        onParagraphLoop: [\n            {\n                contains: \"w:p\",\n                expand: \"w:p\",\n                onlyTextInTag: true\n            }\n        ],\n        tagRawXml: \"w:p\",\n        baseModules: [\n            loopModule,\n            spacePreserveModule,\n            expandPairTrait,\n            rawXmlModule,\n            render\n        ],\n        tagShouldContain: [\n            {\n                tag: \"w:tbl\",\n                shouldContain: [\n                    \"w:tr\"\n                ],\n                drop: true\n            },\n            {\n                tag: \"w:tc\",\n                shouldContain: [\n                    \"w:p\"\n                ],\n                value: \"<w:p></w:p>\"\n            },\n            {\n                tag: \"w:sdtContent\",\n                shouldContain: [\n                    \"w:p\",\n                    \"w:r\",\n                    \"w:commentRangeStart\",\n                    \"w:sdt\"\n                ],\n                value: \"<w:p></w:p>\"\n            }\n        ]\n    };\n}\nfunction PptXFileTypeConfig() {\n    return {\n        getTemplatedFiles: function getTemplatedFiles() {\n            return [];\n        },\n        textPath: function textPath(doc) {\n            return doc.textTarget;\n        },\n        tagsXmlTextArray: [\n            \"Company\",\n            \"HyperlinkBase\",\n            \"Manager\",\n            \"cp:category\",\n            \"cp:keywords\",\n            \"dc:creator\",\n            \"dc:description\",\n            \"dc:subject\",\n            \"dc:title\",\n            \"a:t\",\n            \"m:t\",\n            \"vt:lpstr\",\n            \"vt:lpwstr\"\n        ],\n        tagsXmlLexedArray: [\n            \"p:sp\",\n            \"a:tc\",\n            \"a:tr\",\n            \"a:tbl\",\n            \"a:graphicData\",\n            \"a:p\",\n            \"a:r\",\n            \"a:rPr\",\n            \"p:txBody\",\n            \"a:txBody\",\n            \"a:off\",\n            \"a:ext\",\n            \"p:graphicFrame\",\n            \"p:xfrm\",\n            \"a16:rowId\",\n            \"a:endParaRPr\"\n        ],\n        droppedTagsInsidePlaceholder: [\n            \"a:p\",\n            \"a:endParaRPr\"\n        ],\n        expandTags: [\n            {\n                contains: \"a:tc\",\n                expand: \"a:tr\"\n            }\n        ],\n        onParagraphLoop: [\n            {\n                contains: \"a:p\",\n                expand: \"a:p\",\n                onlyTextInTag: true\n            }\n        ],\n        tagRawXml: \"p:sp\",\n        baseModules: [\n            loopModule,\n            expandPairTrait,\n            rawXmlModule,\n            render\n        ],\n        tagShouldContain: [\n            {\n                tag: \"a:tbl\",\n                shouldContain: [\n                    \"a:tr\"\n                ],\n                dropParent: \"p:graphicFrame\"\n            },\n            {\n                tag: \"p:txBody\",\n                shouldContain: [\n                    \"a:p\"\n                ],\n                value: \"<a:p></a:p>\"\n            },\n            {\n                tag: \"a:txBody\",\n                shouldContain: [\n                    \"a:p\"\n                ],\n                value: \"<a:p></a:p>\"\n            }\n        ]\n    };\n}\nmodule.exports = {\n    docx: DocXFileTypeConfig,\n    pptx: PptXFileTypeConfig\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxlLXR5cGUtY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQzVDLElBQUlDLHNCQUFzQkQsbUJBQU9BLENBQUMsb0dBQTZCO0FBQy9ELElBQUlFLGVBQWVGLG1CQUFPQSxDQUFDLG9GQUFxQjtBQUNoRCxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLDBHQUFnQztBQUM5RCxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQyxvRkFBcUI7QUFDMUMsU0FBU0s7SUFDUCxPQUFPO1FBQ0xDLG1CQUFtQixTQUFTQTtZQUMxQixPQUFPLEVBQUU7UUFDWDtRQUNBQyxVQUFVLFNBQVNBLFNBQVNDLEdBQUc7WUFDN0IsT0FBT0EsSUFBSUMsVUFBVTtRQUN2QjtRQUNBQyxrQkFBa0I7WUFBQztZQUFXO1lBQWlCO1lBQVc7WUFBZTtZQUFlO1lBQWM7WUFBa0I7WUFBYztZQUFZO1lBQW9CO1lBQU87WUFBTztZQUFZO1NBQVk7UUFDNU1DLG1CQUFtQjtZQUFDO1lBQWdCO1lBQVE7WUFBUTtZQUFTO1lBQVU7WUFBYztZQUFPO1lBQU87WUFBUTtZQUFTO1lBQVM7WUFBYTtZQUFnQjtZQUFTO1lBQWE7WUFBWTtZQUFVO1lBQXFCO1lBQXFCO1lBQW1CO1lBQWlCO1lBQXVCO1lBQXFCO1NBQXFCO1FBQ3JWQyw4QkFBOEI7WUFBQztZQUFPO1lBQVE7WUFBbUI7U0FBZ0I7UUFDakZDLFlBQVk7WUFBQztnQkFDWEMsVUFBVTtnQkFDVkMsUUFBUTtZQUNWO1NBQUU7UUFDRkMsaUJBQWlCO1lBQUM7Z0JBQ2hCRixVQUFVO2dCQUNWQyxRQUFRO2dCQUNSRSxlQUFlO1lBQ2pCO1NBQUU7UUFDRkMsV0FBVztRQUNYQyxhQUFhO1lBQUNwQjtZQUFZRTtZQUFxQkU7WUFBaUJEO1lBQWNFO1NBQU87UUFDckZnQixrQkFBa0I7WUFBQztnQkFDakJDLEtBQUs7Z0JBQ0xDLGVBQWU7b0JBQUM7aUJBQU87Z0JBQ3ZCQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsS0FBSztnQkFDTEMsZUFBZTtvQkFBQztpQkFBTTtnQkFDdEJFLE9BQU87WUFDVDtZQUFHO2dCQUNESCxLQUFLO2dCQUNMQyxlQUFlO29CQUFDO29CQUFPO29CQUFPO29CQUF1QjtpQkFBUTtnQkFDN0RFLE9BQU87WUFDVDtTQUFFO0lBQ0o7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsT0FBTztRQUNMbkIsbUJBQW1CLFNBQVNBO1lBQzFCLE9BQU8sRUFBRTtRQUNYO1FBQ0FDLFVBQVUsU0FBU0EsU0FBU0MsR0FBRztZQUM3QixPQUFPQSxJQUFJQyxVQUFVO1FBQ3ZCO1FBQ0FDLGtCQUFrQjtZQUFDO1lBQVc7WUFBaUI7WUFBVztZQUFlO1lBQWU7WUFBYztZQUFrQjtZQUFjO1lBQVk7WUFBTztZQUFPO1lBQVk7U0FBWTtRQUN4TEMsbUJBQW1CO1lBQUM7WUFBUTtZQUFRO1lBQVE7WUFBUztZQUFpQjtZQUFPO1lBQU87WUFBUztZQUFZO1lBQVk7WUFBUztZQUFTO1lBQWtCO1lBQVU7WUFBYTtTQUFlO1FBQy9MQyw4QkFBOEI7WUFBQztZQUFPO1NBQWU7UUFDckRDLFlBQVk7WUFBQztnQkFDWEMsVUFBVTtnQkFDVkMsUUFBUTtZQUNWO1NBQUU7UUFDRkMsaUJBQWlCO1lBQUM7Z0JBQ2hCRixVQUFVO2dCQUNWQyxRQUFRO2dCQUNSRSxlQUFlO1lBQ2pCO1NBQUU7UUFDRkMsV0FBVztRQUNYQyxhQUFhO1lBQUNwQjtZQUFZSTtZQUFpQkQ7WUFBY0U7U0FBTztRQUNoRWdCLGtCQUFrQjtZQUFDO2dCQUNqQkMsS0FBSztnQkFDTEMsZUFBZTtvQkFBQztpQkFBTztnQkFDdkJJLFlBQVk7WUFDZDtZQUFHO2dCQUNETCxLQUFLO2dCQUNMQyxlQUFlO29CQUFDO2lCQUFNO2dCQUN0QkUsT0FBTztZQUNUO1lBQUc7Z0JBQ0RILEtBQUs7Z0JBQ0xDLGVBQWU7b0JBQUM7aUJBQU07Z0JBQ3RCRSxPQUFPO1lBQ1Q7U0FBRTtJQUNKO0FBQ0Y7QUFDQUcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLE1BQU14QjtJQUNOeUIsTUFBTUw7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2ZpbGUtdHlwZS1jb25maWcuanM/NDFmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGxvb3BNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2xvb3AuanNcIik7XG52YXIgc3BhY2VQcmVzZXJ2ZU1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanNcIik7XG52YXIgcmF3WG1sTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9yYXd4bWwuanNcIik7XG52YXIgZXhwYW5kUGFpclRyYWl0ID0gcmVxdWlyZShcIi4vbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qc1wiKTtcbnZhciByZW5kZXIgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3JlbmRlci5qc1wiKTtcbmZ1bmN0aW9uIERvY1hGaWxlVHlwZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRUZW1wbGF0ZWRGaWxlczogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0ZXh0UGF0aDogZnVuY3Rpb24gdGV4dFBhdGgoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLnRleHRUYXJnZXQ7XG4gICAgfSxcbiAgICB0YWdzWG1sVGV4dEFycmF5OiBbXCJDb21wYW55XCIsIFwiSHlwZXJsaW5rQmFzZVwiLCBcIk1hbmFnZXJcIiwgXCJjcDpjYXRlZ29yeVwiLCBcImNwOmtleXdvcmRzXCIsIFwiZGM6Y3JlYXRvclwiLCBcImRjOmRlc2NyaXB0aW9uXCIsIFwiZGM6c3ViamVjdFwiLCBcImRjOnRpdGxlXCIsIFwiY3A6Y29udGVudFN0YXR1c1wiLCBcInc6dFwiLCBcIm06dFwiLCBcInZ0Omxwc3RyXCIsIFwidnQ6bHB3c3RyXCJdLFxuICAgIHRhZ3NYbWxMZXhlZEFycmF5OiBbXCJ3OnByb29mU3RhdGVcIiwgXCJ3OnRjXCIsIFwidzp0clwiLCBcInc6dGJsXCIsIFwidzpib2R5XCIsIFwidzpkb2N1bWVudFwiLCBcInc6cFwiLCBcInc6clwiLCBcInc6YnJcIiwgXCJ3OnJQclwiLCBcInc6cFByXCIsIFwidzpzcGFjaW5nXCIsIFwidzpzZHRDb250ZW50XCIsIFwidzpzZHRcIiwgXCJ3OmRyYXdpbmdcIiwgXCJ3OnNlY3RQclwiLCBcInc6dHlwZVwiLCBcInc6aGVhZGVyUmVmZXJlbmNlXCIsIFwidzpmb290ZXJSZWZlcmVuY2VcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCIsIFwidzpjb21tZW50UmFuZ2VTdGFydFwiLCBcInc6Y29tbWVudFJhbmdlRW5kXCIsIFwidzpjb21tZW50UmVmZXJlbmNlXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcInc6cFwiLCBcInc6YnJcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCJdLFxuICAgIGV4cGFuZFRhZ3M6IFt7XG4gICAgICBjb250YWluczogXCJ3OnRjXCIsXG4gICAgICBleHBhbmQ6IFwidzp0clwiXG4gICAgfV0sXG4gICAgb25QYXJhZ3JhcGhMb29wOiBbe1xuICAgICAgY29udGFpbnM6IFwidzpwXCIsXG4gICAgICBleHBhbmQ6IFwidzpwXCIsXG4gICAgICBvbmx5VGV4dEluVGFnOiB0cnVlXG4gICAgfV0sXG4gICAgdGFnUmF3WG1sOiBcInc6cFwiLFxuICAgIGJhc2VNb2R1bGVzOiBbbG9vcE1vZHVsZSwgc3BhY2VQcmVzZXJ2ZU1vZHVsZSwgZXhwYW5kUGFpclRyYWl0LCByYXdYbWxNb2R1bGUsIHJlbmRlcl0sXG4gICAgdGFnU2hvdWxkQ29udGFpbjogW3tcbiAgICAgIHRhZzogXCJ3OnRibFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzp0clwiXSxcbiAgICAgIGRyb3A6IHRydWVcbiAgICB9LCB7XG4gICAgICB0YWc6IFwidzp0Y1wiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzpwXCJdLFxuICAgICAgdmFsdWU6IFwiPHc6cD48L3c6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnNkdENvbnRlbnRcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6cFwiLCBcInc6clwiLCBcInc6Y29tbWVudFJhbmdlU3RhcnRcIiwgXCJ3OnNkdFwiXSxcbiAgICAgIHZhbHVlOiBcIjx3OnA+PC93OnA+XCJcbiAgICB9XVxuICB9O1xufVxuZnVuY3Rpb24gUHB0WEZpbGVUeXBlQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdldFRlbXBsYXRlZEZpbGVzOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MudGV4dFRhcmdldDtcbiAgICB9LFxuICAgIHRhZ3NYbWxUZXh0QXJyYXk6IFtcIkNvbXBhbnlcIiwgXCJIeXBlcmxpbmtCYXNlXCIsIFwiTWFuYWdlclwiLCBcImNwOmNhdGVnb3J5XCIsIFwiY3A6a2V5d29yZHNcIiwgXCJkYzpjcmVhdG9yXCIsIFwiZGM6ZGVzY3JpcHRpb25cIiwgXCJkYzpzdWJqZWN0XCIsIFwiZGM6dGl0bGVcIiwgXCJhOnRcIiwgXCJtOnRcIiwgXCJ2dDpscHN0clwiLCBcInZ0Omxwd3N0clwiXSxcbiAgICB0YWdzWG1sTGV4ZWRBcnJheTogW1wicDpzcFwiLCBcImE6dGNcIiwgXCJhOnRyXCIsIFwiYTp0YmxcIiwgXCJhOmdyYXBoaWNEYXRhXCIsIFwiYTpwXCIsIFwiYTpyXCIsIFwiYTpyUHJcIiwgXCJwOnR4Qm9keVwiLCBcImE6dHhCb2R5XCIsIFwiYTpvZmZcIiwgXCJhOmV4dFwiLCBcInA6Z3JhcGhpY0ZyYW1lXCIsIFwicDp4ZnJtXCIsIFwiYTE2OnJvd0lkXCIsIFwiYTplbmRQYXJhUlByXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcImE6cFwiLCBcImE6ZW5kUGFyYVJQclwiXSxcbiAgICBleHBhbmRUYWdzOiBbe1xuICAgICAgY29udGFpbnM6IFwiYTp0Y1wiLFxuICAgICAgZXhwYW5kOiBcImE6dHJcIlxuICAgIH1dLFxuICAgIG9uUGFyYWdyYXBoTG9vcDogW3tcbiAgICAgIGNvbnRhaW5zOiBcImE6cFwiLFxuICAgICAgZXhwYW5kOiBcImE6cFwiLFxuICAgICAgb25seVRleHRJblRhZzogdHJ1ZVxuICAgIH1dLFxuICAgIHRhZ1Jhd1htbDogXCJwOnNwXCIsXG4gICAgYmFzZU1vZHVsZXM6IFtsb29wTW9kdWxlLCBleHBhbmRQYWlyVHJhaXQsIHJhd1htbE1vZHVsZSwgcmVuZGVyXSxcbiAgICB0YWdTaG91bGRDb250YWluOiBbe1xuICAgICAgdGFnOiBcImE6dGJsXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnRyXCJdLFxuICAgICAgZHJvcFBhcmVudDogXCJwOmdyYXBoaWNGcmFtZVwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInA6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcImE6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfV1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkb2N4OiBEb2NYRmlsZVR5cGVDb25maWcsXG4gIHBwdHg6IFBwdFhGaWxlVHlwZUNvbmZpZ1xufTsiXSwibmFtZXMiOlsibG9vcE1vZHVsZSIsInJlcXVpcmUiLCJzcGFjZVByZXNlcnZlTW9kdWxlIiwicmF3WG1sTW9kdWxlIiwiZXhwYW5kUGFpclRyYWl0IiwicmVuZGVyIiwiRG9jWEZpbGVUeXBlQ29uZmlnIiwiZ2V0VGVtcGxhdGVkRmlsZXMiLCJ0ZXh0UGF0aCIsImRvYyIsInRleHRUYXJnZXQiLCJ0YWdzWG1sVGV4dEFycmF5IiwidGFnc1htbExleGVkQXJyYXkiLCJkcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIiwiZXhwYW5kVGFncyIsImNvbnRhaW5zIiwiZXhwYW5kIiwib25QYXJhZ3JhcGhMb29wIiwib25seVRleHRJblRhZyIsInRhZ1Jhd1htbCIsImJhc2VNb2R1bGVzIiwidGFnU2hvdWxkQ29udGFpbiIsInRhZyIsInNob3VsZENvbnRhaW4iLCJkcm9wIiwidmFsdWUiLCJQcHRYRmlsZVR5cGVDb25maWciLCJkcm9wUGFyZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsImRvY3giLCJwcHR4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/filetypes.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/filetypes.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar main = [\n    docxContentType,\n    docxmContentType,\n    dotxContentType,\n    dotmContentType\n];\nvar filetypes = {\n    main: main,\n    docx: [\n        headerContentType\n    ].concat(main, [\n        footerContentType,\n        footnotesContentType,\n        commentsContentType\n    ]),\n    pptx: [\n        pptxContentType,\n        pptxSlideMaster,\n        pptxSlideLayout,\n        pptxPresentationContentType\n    ]\n};\nmodule.exports = filetypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxldHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxrQkFBa0I7QUFDdEIsSUFBSUMsbUJBQW1CO0FBQ3ZCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyxzQkFBc0I7QUFDMUIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLDhCQUE4QjtBQUNsQyxJQUFJQyxPQUFPO0lBQUNaO0lBQWlCQztJQUFrQkM7SUFBaUJDO0NBQWdCO0FBQ2hGLElBQUlVLFlBQVk7SUFDZEQsTUFBTUE7SUFDTkUsTUFBTTtRQUFDVjtLQUFrQixDQUFDVyxNQUFNLENBQUNILE1BQU07UUFBQ0w7UUFBbUJGO1FBQXNCQztLQUFvQjtJQUNyR1UsTUFBTTtRQUFDUjtRQUFpQkM7UUFBaUJDO1FBQWlCQztLQUE0QjtBQUN4RjtBQUNBTSxPQUFPQyxPQUFPLEdBQUdMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzPzc1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkb2N4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lm1haW4reG1sXCI7XG52YXIgZG9jeG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9FbmFibGVkLm1haW4reG1sXCI7XG52YXIgZG90eENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZS5tYWluK3htbFwiO1xudmFyIGRvdG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9FbmFibGVkVGVtcGxhdGUubWFpbit4bWxcIjtcbnZhciBoZWFkZXJDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuaGVhZGVyK3htbFwiO1xudmFyIGZvb3Rub3Rlc0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290bm90ZXMreG1sXCI7XG52YXIgY29tbWVudHNDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuY29tbWVudHMreG1sXCI7XG52YXIgZm9vdGVyQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rlcit4bWxcIjtcbnZhciBwcHR4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZSt4bWxcIjtcbnZhciBwcHR4U2xpZGVNYXN0ZXIgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZU1hc3Rlcit4bWxcIjtcbnZhciBwcHR4U2xpZGVMYXlvdXQgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZUxheW91dCt4bWxcIjtcbnZhciBwcHR4UHJlc2VudGF0aW9uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24ubWFpbit4bWxcIjtcbnZhciBtYWluID0gW2RvY3hDb250ZW50VHlwZSwgZG9jeG1Db250ZW50VHlwZSwgZG90eENvbnRlbnRUeXBlLCBkb3RtQ29udGVudFR5cGVdO1xudmFyIGZpbGV0eXBlcyA9IHtcbiAgbWFpbjogbWFpbixcbiAgZG9jeDogW2hlYWRlckNvbnRlbnRUeXBlXS5jb25jYXQobWFpbiwgW2Zvb3RlckNvbnRlbnRUeXBlLCBmb290bm90ZXNDb250ZW50VHlwZSwgY29tbWVudHNDb250ZW50VHlwZV0pLFxuICBwcHR4OiBbcHB0eENvbnRlbnRUeXBlLCBwcHR4U2xpZGVNYXN0ZXIsIHBwdHhTbGlkZUxheW91dCwgcHB0eFByZXNlbnRhdGlvbkNvbnRlbnRUeXBlXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZmlsZXR5cGVzOyJdLCJuYW1lcyI6WyJkb2N4Q29udGVudFR5cGUiLCJkb2N4bUNvbnRlbnRUeXBlIiwiZG90eENvbnRlbnRUeXBlIiwiZG90bUNvbnRlbnRUeXBlIiwiaGVhZGVyQ29udGVudFR5cGUiLCJmb290bm90ZXNDb250ZW50VHlwZSIsImNvbW1lbnRzQ29udGVudFR5cGUiLCJmb290ZXJDb250ZW50VHlwZSIsInBwdHhDb250ZW50VHlwZSIsInBwdHhTbGlkZU1hc3RlciIsInBwdHhTbGlkZUxheW91dCIsInBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZSIsIm1haW4iLCJmaWxldHlwZXMiLCJkb2N4IiwiY29uY2F0IiwicHB0eCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js":
/*!**********************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nfunction getResolvedId(part, options) {\n    if (part.lIndex == null) {\n        return null;\n    }\n    var path = options.scopeManager.scopePathItem;\n    if (part.parentPart) {\n        path = path.slice(0, path.length - 1);\n    }\n    var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n    return res;\n}\nmodule.exports = getResolvedId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVzb2x2ZWQtaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxjQUFjQyxJQUFJLEVBQUVDLE9BQU87SUFDbEMsSUFBSUQsS0FBS0UsTUFBTSxJQUFJLE1BQU07UUFDdkIsT0FBTztJQUNUO0lBQ0EsSUFBSUMsT0FBT0YsUUFBUUcsWUFBWSxDQUFDQyxhQUFhO0lBQzdDLElBQUlMLEtBQUtNLFVBQVUsRUFBRTtRQUNuQkgsT0FBT0EsS0FBS0ksS0FBSyxDQUFDLEdBQUdKLEtBQUtLLE1BQU0sR0FBRztJQUNyQztJQUNBLElBQUlDLE1BQU1SLFFBQVFTLFFBQVEsR0FBRyxNQUFNVixLQUFLRSxNQUFNLENBQUNTLFFBQVEsS0FBSyxNQUFNUixLQUFLUyxJQUFJLENBQUM7SUFDNUUsT0FBT0g7QUFDVDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlc29sdmVkLWlkLmpzPzdmYjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucykge1xuICBpZiAocGFydC5sSW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwYXRoID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuc2NvcGVQYXRoSXRlbTtcbiAgaWYgKHBhcnQucGFyZW50UGFydCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgdmFyIHJlcyA9IG9wdGlvbnMuZmlsZVBhdGggKyBcIkBcIiArIHBhcnQubEluZGV4LnRvU3RyaW5nKCkgKyBcIi1cIiArIHBhdGguam9pbihcIi1cIik7XG4gIHJldHVybiByZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGdldFJlc29sdmVkSWQ7Il0sIm5hbWVzIjpbImdldFJlc29sdmVkSWQiLCJwYXJ0Iiwib3B0aW9ucyIsImxJbmRleCIsInBhdGgiLCJzY29wZU1hbmFnZXIiLCJzY29wZVBhdGhJdGVtIiwicGFyZW50UGFydCIsInNsaWNlIiwibGVuZ3RoIiwicmVzIiwiZmlsZVBhdGgiLCJ0b1N0cmluZyIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), startsWith = _require.startsWith, endsWith = _require.endsWith, isStarting = _require.isStarting, isEnding = _require.isEnding, isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n    var lastNonEmpty = \"\";\n    for(var i = 0, len = parts.length; i < len; i++){\n        var p = parts[i];\n        if (isWhiteSpace(p)) {\n            continue;\n        }\n        if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n            if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n                p = \"<w:p/>\".concat(p);\n            }\n        }\n        lastNonEmpty = p;\n        parts[i] = p;\n    }\n    return parts;\n}\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n    var contains = options.fileTypeConfig.tagShouldContain || [];\n    /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */ var collecting = \"\";\n    var currentlyCollecting = -1;\n    if (filetypes.docx.indexOf(options.contentType) !== -1) {\n        parts = addEmptyParagraphAfterTable(parts);\n    }\n    var startIndex = -1;\n    for(var i = 0, len = parts.length; i < len; i++){\n        var part = parts[i];\n        for(var j = 0, len2 = contains.length; j < len2; j++){\n            var _contains$j = contains[j], tag = _contains$j.tag, shouldContain = _contains$j.shouldContain, value = _contains$j.value, drop = _contains$j.drop, dropParent = _contains$j.dropParent;\n            if (currentlyCollecting === j) {\n                if (isEnding(part, tag)) {\n                    currentlyCollecting = -1;\n                    if (dropParent) {\n                        var start = void 0, end = void 0;\n                        for(var k = startIndex; k > 0; k--){\n                            if (isStarting(parts[k], dropParent)) {\n                                start = k;\n                                break;\n                            }\n                        }\n                        for(var _k = i; _k < parts.length; _k++){\n                            if (isEnding(parts[_k], dropParent)) {\n                                end = _k;\n                                break;\n                            }\n                        }\n                        for(var _k2 = start; _k2 <= end; _k2++){\n                            parts[_k2] = \"\";\n                        }\n                    } else if (drop) {\n                        for(var _k3 = startIndex; _k3 <= i; _k3++){\n                            parts[_k3] = \"\";\n                        }\n                    } else {\n                        for(var _k4 = startIndex; _k4 < i; _k4++){\n                            parts[_k4] = \"\";\n                        }\n                        parts[i] = collecting + value + part;\n                    }\n                    break;\n                }\n                collecting += part;\n                for(var _k5 = 0, len3 = shouldContain.length; _k5 < len3; _k5++){\n                    var sc = shouldContain[_k5];\n                    if (isStarting(part, sc)) {\n                        currentlyCollecting = -1;\n                        break;\n                    }\n                }\n                if (currentlyCollecting > -1) {\n                // parts[i] = \"\";\n                }\n                break;\n            }\n            if (currentlyCollecting === -1 && isStarting(part, tag) && // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n            part.substr(1).indexOf(\"<\") === -1) {\n                // self-closing tag such as <w:t/>\n                if (part[part.length - 2] === \"/\") {\n                    parts[i] = \"\";\n                    break;\n                } else {\n                    startIndex = i;\n                    currentlyCollecting = j;\n                    collecting = part;\n                    break;\n                }\n            }\n        }\n    }\n    return parts;\n}\nmodule.exports = joinUncorrupt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9qb2luLXVuY29ycnVwdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLDBFQUFnQixHQUNyQ0MsYUFBYUYsU0FBU0UsVUFBVSxFQUNoQ0MsV0FBV0gsU0FBU0csUUFBUSxFQUM1QkMsYUFBYUosU0FBU0ksVUFBVSxFQUNoQ0MsV0FBV0wsU0FBU0ssUUFBUSxFQUM1QkMsZUFBZU4sU0FBU00sWUFBWTtBQUN0QyxJQUFJQyxZQUFZTixtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDeEMsU0FBU08sNEJBQTRCQyxLQUFLO0lBQ3hDLElBQUlDLGVBQWU7SUFDbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1ILE1BQU1JLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUNoRCxJQUFJRyxJQUFJTCxLQUFLLENBQUNFLEVBQUU7UUFDaEIsSUFBSUwsYUFBYVEsSUFBSTtZQUNuQjtRQUNGO1FBQ0EsSUFBSVgsU0FBU08sY0FBYyxhQUFhO1lBQ3RDLElBQUksQ0FBQ1IsV0FBV1ksR0FBRyxXQUFXLENBQUNaLFdBQVdZLEdBQUcsYUFBYSxDQUFDWixXQUFXWSxHQUFHLGNBQWM7Z0JBQ3JGQSxJQUFJLFNBQVNDLE1BQU0sQ0FBQ0Q7WUFDdEI7UUFDRjtRQUNBSixlQUFlSTtRQUNmTCxLQUFLLENBQUNFLEVBQUUsR0FBR0c7SUFDYjtJQUNBLE9BQU9MO0FBQ1Q7QUFFQSxzQ0FBc0M7QUFDdEMsU0FBU08sY0FBY1AsS0FBSyxFQUFFUSxPQUFPO0lBQ25DLElBQUlDLFdBQVdELFFBQVFFLGNBQWMsQ0FBQ0MsZ0JBQWdCLElBQUksRUFBRTtJQUM1RDs7Ozs7OztHQU9DLEdBQ0QsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxzQkFBc0IsQ0FBQztJQUMzQixJQUFJZixVQUFVZ0IsSUFBSSxDQUFDQyxPQUFPLENBQUNQLFFBQVFRLFdBQVcsTUFBTSxDQUFDLEdBQUc7UUFDdERoQixRQUFRRCw0QkFBNEJDO0lBQ3RDO0lBQ0EsSUFBSWlCLGFBQWEsQ0FBQztJQUNsQixJQUFLLElBQUlmLElBQUksR0FBR0MsTUFBTUgsTUFBTUksTUFBTSxFQUFFRixJQUFJQyxLQUFLRCxJQUFLO1FBQ2hELElBQUlnQixPQUFPbEIsS0FBSyxDQUFDRSxFQUFFO1FBQ25CLElBQUssSUFBSWlCLElBQUksR0FBR0MsT0FBT1gsU0FBU0wsTUFBTSxFQUFFZSxJQUFJQyxNQUFNRCxJQUFLO1lBQ3JELElBQUlFLGNBQWNaLFFBQVEsQ0FBQ1UsRUFBRSxFQUMzQkcsTUFBTUQsWUFBWUMsR0FBRyxFQUNyQkMsZ0JBQWdCRixZQUFZRSxhQUFhLEVBQ3pDQyxRQUFRSCxZQUFZRyxLQUFLLEVBQ3pCQyxPQUFPSixZQUFZSSxJQUFJLEVBQ3ZCQyxhQUFhTCxZQUFZSyxVQUFVO1lBQ3JDLElBQUliLHdCQUF3Qk0sR0FBRztnQkFDN0IsSUFBSXZCLFNBQVNzQixNQUFNSSxNQUFNO29CQUN2QlQsc0JBQXNCLENBQUM7b0JBQ3ZCLElBQUlhLFlBQVk7d0JBQ2QsSUFBSUMsUUFBUSxLQUFLLEdBQ2ZDLE1BQU0sS0FBSzt3QkFDYixJQUFLLElBQUlDLElBQUlaLFlBQVlZLElBQUksR0FBR0EsSUFBSzs0QkFDbkMsSUFBSWxDLFdBQVdLLEtBQUssQ0FBQzZCLEVBQUUsRUFBRUgsYUFBYTtnQ0FDcENDLFFBQVFFO2dDQUNSOzRCQUNGO3dCQUNGO3dCQUNBLElBQUssSUFBSUMsS0FBSzVCLEdBQUc0QixLQUFLOUIsTUFBTUksTUFBTSxFQUFFMEIsS0FBTTs0QkFDeEMsSUFBSWxDLFNBQVNJLEtBQUssQ0FBQzhCLEdBQUcsRUFBRUosYUFBYTtnQ0FDbkNFLE1BQU1FO2dDQUNOOzRCQUNGO3dCQUNGO3dCQUNBLElBQUssSUFBSUMsTUFBTUosT0FBT0ksT0FBT0gsS0FBS0csTUFBTzs0QkFDdkMvQixLQUFLLENBQUMrQixJQUFJLEdBQUc7d0JBQ2Y7b0JBQ0YsT0FBTyxJQUFJTixNQUFNO3dCQUNmLElBQUssSUFBSU8sTUFBTWYsWUFBWWUsT0FBTzlCLEdBQUc4QixNQUFPOzRCQUMxQ2hDLEtBQUssQ0FBQ2dDLElBQUksR0FBRzt3QkFDZjtvQkFDRixPQUFPO3dCQUNMLElBQUssSUFBSUMsTUFBTWhCLFlBQVlnQixNQUFNL0IsR0FBRytCLE1BQU87NEJBQ3pDakMsS0FBSyxDQUFDaUMsSUFBSSxHQUFHO3dCQUNmO3dCQUNBakMsS0FBSyxDQUFDRSxFQUFFLEdBQUdVLGFBQWFZLFFBQVFOO29CQUNsQztvQkFDQTtnQkFDRjtnQkFDQU4sY0FBY007Z0JBQ2QsSUFBSyxJQUFJZ0IsTUFBTSxHQUFHQyxPQUFPWixjQUFjbkIsTUFBTSxFQUFFOEIsTUFBTUMsTUFBTUQsTUFBTztvQkFDaEUsSUFBSUUsS0FBS2IsYUFBYSxDQUFDVyxJQUFJO29CQUMzQixJQUFJdkMsV0FBV3VCLE1BQU1rQixLQUFLO3dCQUN4QnZCLHNCQUFzQixDQUFDO3dCQUV2QjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJQSxzQkFBc0IsQ0FBQyxHQUFHO2dCQUM1QixpQkFBaUI7Z0JBQ25CO2dCQUNBO1lBQ0Y7WUFDQSxJQUFJQSx3QkFBd0IsQ0FBQyxLQUFLbEIsV0FBV3VCLE1BQU1JLFFBQ25ELDBFQUEwRTtZQUMxRUosS0FBS21CLE1BQU0sQ0FBQyxHQUFHdEIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUNsQyxrQ0FBa0M7Z0JBQ2xDLElBQUlHLElBQUksQ0FBQ0EsS0FBS2QsTUFBTSxHQUFHLEVBQUUsS0FBSyxLQUFLO29CQUNqQ0osS0FBSyxDQUFDRSxFQUFFLEdBQUc7b0JBQ1g7Z0JBQ0YsT0FBTztvQkFDTGUsYUFBYWY7b0JBQ2JXLHNCQUFzQk07b0JBQ3RCUCxhQUFhTTtvQkFFYjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9sQjtBQUNUO0FBQ0FzQyxPQUFPQyxPQUFPLEdBQUdoQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2pvaW4tdW5jb3JydXB0LmpzP2Y2OTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGgsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIGlzU3RhcnRpbmcgPSBfcmVxdWlyZS5pc1N0YXJ0aW5nLFxuICBpc0VuZGluZyA9IF9yZXF1aXJlLmlzRW5kaW5nLFxuICBpc1doaXRlU3BhY2UgPSBfcmVxdWlyZS5pc1doaXRlU3BhY2U7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4vZmlsZXR5cGVzLmpzXCIpO1xuZnVuY3Rpb24gYWRkRW1wdHlQYXJhZ3JhcGhBZnRlclRhYmxlKHBhcnRzKSB7XG4gIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgIGlmIChpc1doaXRlU3BhY2UocCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZW5kc1dpdGgobGFzdE5vbkVtcHR5LCBcIjwvdzp0Ymw+XCIpKSB7XG4gICAgICBpZiAoIXN0YXJ0c1dpdGgocCwgXCI8dzpwXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6dGJsXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICAgIHAgPSBcIjx3OnAvPlwiLmNvbmNhdChwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdE5vbkVtcHR5ID0gcDtcbiAgICBwYXJ0c1tpXSA9IHA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gam9pblVuY29ycnVwdChwYXJ0cywgb3B0aW9ucykge1xuICB2YXIgY29udGFpbnMgPSBvcHRpb25zLmZpbGVUeXBlQ29uZmlnLnRhZ1Nob3VsZENvbnRhaW4gfHwgW107XG4gIC8qIEJlZm9yZSBkb2luZyB0aGlzIFwidW5jb3JydXB0aW9uXCIgbWV0aG9kIGhlcmUsIHRoaXMgd2FzIGRvbmUgd2l0aCB0aGVcbiAgICogYHBhcnQuZW1wdHlWYWx1ZWAgdHJpY2ssIGhvd2V2ZXIsIHRoZXJlIHdlcmUgc29tZSBjb3JydXB0aW9ucyB0aGF0IHdlcmVcbiAgICogbm90IGhhbmRsZWQsIGZvciBleGFtcGxlIHdpdGggYSB0ZW1wbGF0ZSBsaWtlIHRoaXMgOlxuICAgKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogfCB7LXc6cCBmYWxzeX1NeSBwYXJhey9mYWxzeX0gICB8ICAgICAgICAgICAgICB8XG4gICAqIHwgey13OnAgZmFsc3l9TXkgcGFyYXsvZmFsc3l9ICAgfCAgICAgICAgICAgICAgfFxuICAgKi9cbiAgdmFyIGNvbGxlY3RpbmcgPSBcIlwiO1xuICB2YXIgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICBpZiAoZmlsZXR5cGVzLmRvY3guaW5kZXhPZihvcHRpb25zLmNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICBwYXJ0cyA9IGFkZEVtcHR5UGFyYWdyYXBoQWZ0ZXJUYWJsZShwYXJ0cyk7XG4gIH1cbiAgdmFyIHN0YXJ0SW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IGNvbnRhaW5zLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgdmFyIF9jb250YWlucyRqID0gY29udGFpbnNbal0sXG4gICAgICAgIHRhZyA9IF9jb250YWlucyRqLnRhZyxcbiAgICAgICAgc2hvdWxkQ29udGFpbiA9IF9jb250YWlucyRqLnNob3VsZENvbnRhaW4sXG4gICAgICAgIHZhbHVlID0gX2NvbnRhaW5zJGoudmFsdWUsXG4gICAgICAgIGRyb3AgPSBfY29udGFpbnMkai5kcm9wLFxuICAgICAgICBkcm9wUGFyZW50ID0gX2NvbnRhaW5zJGouZHJvcFBhcmVudDtcbiAgICAgIGlmIChjdXJyZW50bHlDb2xsZWN0aW5nID09PSBqKSB7XG4gICAgICAgIGlmIChpc0VuZGluZyhwYXJ0LCB0YWcpKSB7XG4gICAgICAgICAgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICAgICAgICAgIGlmIChkcm9wUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIGVuZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBzdGFydEluZGV4OyBrID4gMDsgay0tKSB7XG4gICAgICAgICAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnRzW2tdLCBkcm9wUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2sgPSBpOyBfayA8IHBhcnRzLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICBpZiAoaXNFbmRpbmcocGFydHNbX2tdLCBkcm9wUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IF9rO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfazIgPSBzdGFydDsgX2syIDw9IGVuZDsgX2syKyspIHtcbiAgICAgICAgICAgICAgcGFydHNbX2syXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkcm9wKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfazMgPSBzdGFydEluZGV4OyBfazMgPD0gaTsgX2szKyspIHtcbiAgICAgICAgICAgICAgcGFydHNbX2szXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9rNCA9IHN0YXJ0SW5kZXg7IF9rNCA8IGk7IF9rNCsrKSB7XG4gICAgICAgICAgICAgIHBhcnRzW19rNF0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydHNbaV0gPSBjb2xsZWN0aW5nICsgdmFsdWUgKyBwYXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW5nICs9IHBhcnQ7XG4gICAgICAgIGZvciAodmFyIF9rNSA9IDAsIGxlbjMgPSBzaG91bGRDb250YWluLmxlbmd0aDsgX2s1IDwgbGVuMzsgX2s1KyspIHtcbiAgICAgICAgICB2YXIgc2MgPSBzaG91bGRDb250YWluW19rNV07XG4gICAgICAgICAgaWYgKGlzU3RhcnRpbmcocGFydCwgc2MpKSB7XG4gICAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gICAgICAgICAgICAvLyBwYXJ0c1tpXSA9IGNvbGxlY3Rpbmc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRseUNvbGxlY3RpbmcgPiAtMSkge1xuICAgICAgICAgIC8vIHBhcnRzW2ldID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50bHlDb2xsZWN0aW5nID09PSAtMSAmJiBpc1N0YXJ0aW5nKHBhcnQsIHRhZykgJiZcbiAgICAgIC8vIHRvIHZlcmlmeSB0aGF0IHRoZSBwYXJ0IGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSB0YWdzLCBzdWNoIGFzIDx3OnRjPjx3OnA+XG4gICAgICBwYXJ0LnN1YnN0cigxKS5pbmRleE9mKFwiPFwiKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2VsZi1jbG9zaW5nIHRhZyBzdWNoIGFzIDx3OnQvPlxuICAgICAgICBpZiAocGFydFtwYXJ0Lmxlbmd0aCAtIDJdID09PSBcIi9cIikge1xuICAgICAgICAgIHBhcnRzW2ldID0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gajtcbiAgICAgICAgICBjb2xsZWN0aW5nID0gcGFydDtcbiAgICAgICAgICAvLyBwYXJ0c1tpXSA9IFwiXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBqb2luVW5jb3JydXB0OyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpc1N0YXJ0aW5nIiwiaXNFbmRpbmciLCJpc1doaXRlU3BhY2UiLCJmaWxldHlwZXMiLCJhZGRFbXB0eVBhcmFncmFwaEFmdGVyVGFibGUiLCJwYXJ0cyIsImxhc3ROb25FbXB0eSIsImkiLCJsZW4iLCJsZW5ndGgiLCJwIiwiY29uY2F0Iiwiam9pblVuY29ycnVwdCIsIm9wdGlvbnMiLCJjb250YWlucyIsImZpbGVUeXBlQ29uZmlnIiwidGFnU2hvdWxkQ29udGFpbiIsImNvbGxlY3RpbmciLCJjdXJyZW50bHlDb2xsZWN0aW5nIiwiZG9jeCIsImluZGV4T2YiLCJjb250ZW50VHlwZSIsInN0YXJ0SW5kZXgiLCJwYXJ0IiwiaiIsImxlbjIiLCJfY29udGFpbnMkaiIsInRhZyIsInNob3VsZENvbnRhaW4iLCJ2YWx1ZSIsImRyb3AiLCJkcm9wUGFyZW50Iiwic3RhcnQiLCJlbmQiLCJrIiwiX2siLCJfazIiLCJfazMiLCJfazQiLCJfazUiLCJsZW4zIiwic2MiLCJzdWJzdHIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/lexer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), getUnclosedTagException = _require.getUnclosedTagException, getUnopenedTagException = _require.getUnopenedTagException, getDuplicateOpenTagException = _require.getDuplicateOpenTagException, getDuplicateCloseTagException = _require.getDuplicateCloseTagException, throwMalformedXml = _require.throwMalformedXml, throwXmlInvalid = _require.throwXmlInvalid, XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), isTextStart = _require2.isTextStart, isTextEnd = _require2.isTextEnd, wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0, DELIMITER_EQUAL = 1, DELIMITER_START = 2, DELIMITER_END = 3;\nfunction inRange(range, match) {\n    return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n    if (isTextStart(part)) {\n        if (inTextTag) {\n            throwMalformedXml();\n        }\n        return true;\n    }\n    if (isTextEnd(part)) {\n        if (!inTextTag) {\n            throwMalformedXml();\n        }\n        return false;\n    }\n    return inTextTag;\n}\nfunction getTag(tag) {\n    var position = \"\";\n    var start = 1;\n    var end = tag.indexOf(\" \");\n    if (tag[tag.length - 2] === \"/\") {\n        position = \"selfclosing\";\n        if (end === -1) {\n            end = tag.length - 2;\n        }\n    } else if (tag[1] === \"/\") {\n        start = 2;\n        position = \"end\";\n        if (end === -1) {\n            end = tag.length - 1;\n        }\n    } else {\n        position = \"start\";\n        if (end === -1) {\n            end = tag.length - 1;\n        }\n    }\n    return {\n        tag: tag.slice(start, end),\n        position: position\n    };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n    var cursor = 0;\n    var contentLength = content.length;\n    var allMatches = {};\n    for(var i = 0, len = textMatchArray.length; i < len; i++){\n        allMatches[textMatchArray[i]] = true;\n    }\n    for(var _i = 0, _len = othersMatchArray.length; _i < _len; _i++){\n        allMatches[othersMatchArray[_i]] = false;\n    }\n    var totalMatches = [];\n    while(cursor < contentLength){\n        cursor = content.indexOf(\"<\", cursor);\n        if (cursor === -1) {\n            break;\n        }\n        var offset = cursor;\n        var nextOpening = content.indexOf(\"<\", cursor + 1);\n        cursor = content.indexOf(\">\", cursor);\n        if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n            throwXmlInvalid(content, offset);\n        }\n        var tagText = content.slice(offset, cursor + 1);\n        var _getTag = getTag(tagText), tag = _getTag.tag, position = _getTag.position;\n        var text = allMatches[tag];\n        if (text == null) {\n            continue;\n        }\n        totalMatches.push({\n            type: \"tag\",\n            position: position,\n            text: text,\n            offset: offset,\n            value: tagText,\n            tag: tag\n        });\n    }\n    return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n    var errors = [];\n    var inDelimiter = false;\n    var lastDelimiterMatch = {\n        offset: 0\n    };\n    var xtag;\n    var delimiterWithErrors = delimiterMatches.reduce(function(delimiterAcc, currDelimiterMatch) {\n        var position = currDelimiterMatch.position;\n        var delimiterOffset = currDelimiterMatch.offset;\n        var lastDelimiterOffset = lastDelimiterMatch.offset;\n        var lastDelimiterLength = lastDelimiterMatch.length;\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n        if (inDelimiter && position === \"start\") {\n            if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n                xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n                errors.push(getDuplicateOpenTagException({\n                    xtag: xtag,\n                    offset: lastDelimiterOffset\n                }));\n                lastDelimiterMatch = currDelimiterMatch;\n                delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                    error: true\n                }));\n                return delimiterAcc;\n            }\n            errors.push(getUnclosedTagException({\n                xtag: wordToUtf8(xtag),\n                offset: lastDelimiterOffset\n            }));\n            lastDelimiterMatch = currDelimiterMatch;\n            delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                error: true\n            }));\n            return delimiterAcc;\n        }\n        if (!inDelimiter && position === \"end\") {\n            if (syntaxOptions.allowUnopenedTag) {\n                return delimiterAcc;\n            }\n            if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n                xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n                errors.push(getDuplicateCloseTagException({\n                    xtag: xtag,\n                    offset: lastDelimiterOffset\n                }));\n                lastDelimiterMatch = currDelimiterMatch;\n                delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                    error: true\n                }));\n                return delimiterAcc;\n            }\n            errors.push(getUnopenedTagException({\n                xtag: xtag,\n                offset: delimiterOffset\n            }));\n            lastDelimiterMatch = currDelimiterMatch;\n            delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                error: true\n            }));\n            return delimiterAcc;\n        }\n        inDelimiter = !inDelimiter;\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(currDelimiterMatch);\n        return delimiterAcc;\n    }, []);\n    if (inDelimiter) {\n        var lastDelimiterOffset = lastDelimiterMatch.offset;\n        xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n        errors.push(getUnclosedTagException({\n            xtag: wordToUtf8(xtag),\n            offset: lastDelimiterOffset\n        }));\n    }\n    return {\n        delimiterWithErrors: delimiterWithErrors,\n        errors: errors\n    };\n}\nfunction compareOffsets(startOffset, endOffset) {\n    if (startOffset === -1 && endOffset === -1) {\n        return DELIMITER_NONE;\n    }\n    if (startOffset === endOffset) {\n        return DELIMITER_EQUAL;\n    }\n    if (startOffset === -1 || endOffset === -1) {\n        return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n    }\n    return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n    var newDelimiters = inside.split(\" \");\n    if (newDelimiters.length !== 2) {\n        var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n        err.properties = {\n            id: \"change_delimiters_invalid\",\n            explanation: \"Cannot parser delimiters\"\n        };\n        throw err;\n    }\n    var _newDelimiters = _slicedToArray(newDelimiters, 2), start = _newDelimiters[0], end = _newDelimiters[1];\n    if (start.length === 0 || end.length === 0) {\n        var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n        _err.properties = {\n            id: \"change_delimiters_invalid\",\n            explanation: \"Cannot parser delimiters\"\n        };\n        throw _err;\n    }\n    return [\n        start,\n        end\n    ];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n    var indexes = [];\n    var start = delimiters.start, end = delimiters.end;\n    var offset = -1;\n    var insideTag = false;\n    while(true){\n        var startOffset = fullText.indexOf(start, offset + 1);\n        var endOffset = fullText.indexOf(end, offset + 1);\n        var position = null;\n        var len = void 0;\n        var compareResult = compareOffsets(startOffset, endOffset);\n        if (compareResult === DELIMITER_EQUAL) {\n            compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n        }\n        switch(compareResult){\n            case DELIMITER_NONE:\n                return indexes;\n            case DELIMITER_END:\n                insideTag = false;\n                offset = endOffset;\n                position = \"end\";\n                len = end.length;\n                break;\n            case DELIMITER_START:\n                insideTag = true;\n                offset = startOffset;\n                position = \"start\";\n                len = start.length;\n                break;\n        }\n        // if tag starts with =, such as {=[ ]=}\n        if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n            indexes.push({\n                offset: startOffset,\n                position: \"start\",\n                length: start.length,\n                changedelimiter: true\n            });\n            var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n            var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n            indexes.push({\n                offset: nextEndOffset,\n                position: \"end\",\n                length: end.length,\n                changedelimiter: true\n            });\n            var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n            var _splitDelimiters = splitDelimiters(_insideTag);\n            var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n            start = _splitDelimiters2[0];\n            end = _splitDelimiters2[1];\n            offset = nextEndOffset;\n            continue;\n        }\n        indexes.push({\n            offset: offset,\n            position: position,\n            length: len\n        });\n    }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n    var full = innerContentParts.map(function(p) {\n        return p.value;\n    }).join(\"\");\n    var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n    var offset = 0;\n    var ranges = innerContentParts.map(function(part) {\n        offset += part.value.length;\n        return {\n            offset: offset - part.value.length,\n            lIndex: part.lIndex\n        };\n    });\n    var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions), delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors, errors = _getDelimiterErrors.errors;\n    var cutNext = 0;\n    var delimiterIndex = 0;\n    var parsed = ranges.map(function(p, i) {\n        var offset = p.offset;\n        var range = [\n            offset,\n            offset + innerContentParts[i].value.length\n        ];\n        var partContent = innerContentParts[i].value;\n        var delimitersInOffset = [];\n        while(delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])){\n            delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n            delimiterIndex++;\n        }\n        var parts = [];\n        var cursor = 0;\n        if (cutNext > 0) {\n            cursor = cutNext;\n            cutNext = 0;\n        }\n        delimitersInOffset.forEach(function(delimiterInOffset) {\n            var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n            if (delimiterInOffset.changedelimiter) {\n                if (delimiterInOffset.position === \"start\") {\n                    if (value.length > 0) {\n                        parts.push({\n                            type: \"content\",\n                            value: value\n                        });\n                    }\n                } else {\n                    cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n                }\n                return;\n            }\n            if (value.length > 0) {\n                parts.push({\n                    type: \"content\",\n                    value: value\n                });\n                cursor += value.length;\n            }\n            var delimiterPart = {\n                type: \"delimiter\",\n                position: delimiterInOffset.position,\n                offset: cursor + offset\n            };\n            parts.push(delimiterPart);\n            cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        });\n        cutNext = cursor - partContent.length;\n        var value = partContent.substr(cursor);\n        if (value.length > 0) {\n            parts.push({\n                type: \"content\",\n                value: value\n            });\n        }\n        return parts;\n    }, this);\n    return {\n        parsed: parsed,\n        errors: errors\n    };\n}\nfunction isInsideContent(part) {\n    // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n    return part.type === \"content\" && part.position === \"insidetag\";\n// Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n    return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n    var inTextTag = false;\n    xmlparsed.forEach(function(part) {\n        inTextTag = updateInTextTag(part, inTextTag);\n        if (part.type === \"content\") {\n            part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n        }\n        if (fileType !== \"text\" && isInsideContent(part)) {\n            part.value = part.value.replace(/>/g, \"&gt;\");\n        }\n    });\n}\nmodule.exports = {\n    parseDelimiters: parseDelimiters,\n    parse: function parse(xmllexed, delimiters, syntax, fileType) {\n        decodeContentParts(xmllexed, fileType);\n        var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax), delimiterParsed = _parseDelimiters.parsed, errors = _parseDelimiters.errors;\n        var lexed = [];\n        var index = 0;\n        var lIndex = 0;\n        xmllexed.forEach(function(part) {\n            if (isInsideContent(part)) {\n                Array.prototype.push.apply(lexed, delimiterParsed[index].map(function(p) {\n                    if (p.type === \"content\") {\n                        p.position = \"insidetag\";\n                    }\n                    p.lIndex = lIndex++;\n                    return p;\n                }));\n                index++;\n            } else {\n                part.lIndex = lIndex++;\n                lexed.push(part);\n            }\n        });\n        return {\n            errors: errors,\n            lexed: lexed\n        };\n    },\n    xmlparse: function xmlparse(content, xmltags) {\n        var matches = tagMatcher(content, xmltags.text, xmltags.other);\n        var cursor = 0;\n        var parsed = matches.reduce(function(parsed, match) {\n            var value = content.substr(cursor, match.offset - cursor);\n            if (value.length > 0) {\n                parsed.push({\n                    type: \"content\",\n                    value: value\n                });\n            }\n            cursor = match.offset + match.value.length;\n            delete match.offset;\n            parsed.push(match);\n            return parsed;\n        }, []);\n        var value = content.substr(cursor);\n        if (value.length > 0) {\n            parsed.push({\n                type: \"content\",\n                value: value\n            });\n        }\n        return parsed;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxlQUFlQyxHQUFHLEVBQUVDLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JGLFFBQVFHLHNCQUFzQkgsS0FBS0MsTUFBTUcsNEJBQTRCSixLQUFLQyxNQUFNSTtBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCVixDQUFDLEVBQUVhLE1BQU07SUFBSSxJQUFJLENBQUNiLEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPYyxrQkFBa0JkLEdBQUdhO0lBQVMsSUFBSUUsSUFBSUMsT0FBT1osU0FBUyxDQUFDYSxRQUFRLENBQUNDLElBQUksQ0FBQ2xCLEdBQUdtQixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUosTUFBTSxZQUFZZixFQUFFRyxXQUFXLEVBQUVZLElBQUlmLEVBQUVHLFdBQVcsQ0FBQ2lCLElBQUk7SUFBRSxJQUFJTCxNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPTSxNQUFNQyxJQUFJLENBQUN0QjtJQUFJLElBQUllLE1BQU0sZUFBZSwyQ0FBMkNRLElBQUksQ0FBQ1IsSUFBSSxPQUFPRCxrQkFBa0JkLEdBQUdhO0FBQVM7QUFDL1osU0FBU0Msa0JBQWtCUixHQUFHLEVBQUVrQixHQUFHO0lBQUks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QUFRRSxLQUFLO1FBQzdELElBQUl4RixTQUFTO1FBQ2IsSUFBSWdFLFNBQVN1QixRQUFRbkUsTUFBTSxDQUFDLFNBQVU0QyxNQUFNLEVBQUUvRSxLQUFLO1lBQ2pELElBQUk1QyxRQUFRd0QsUUFBUTZCLE1BQU0sQ0FBQzFCLFFBQVFmLE1BQU1DLE1BQU0sR0FBR2M7WUFDbEQsSUFBSTNELE1BQU1aLE1BQU0sR0FBRyxHQUFHO2dCQUNwQnVJLE9BQU81SCxJQUFJLENBQUM7b0JBQ1ZzRSxNQUFNO29CQUNOckUsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUNBMkQsU0FBU2YsTUFBTUMsTUFBTSxHQUFHRCxNQUFNNUMsS0FBSyxDQUFDWixNQUFNO1lBQzFDLE9BQU93RCxNQUFNQyxNQUFNO1lBQ25COEUsT0FBTzVILElBQUksQ0FBQzZDO1lBQ1osT0FBTytFO1FBQ1QsR0FBRyxFQUFFO1FBQ0wsSUFBSTNILFFBQVF3RCxRQUFRNkIsTUFBTSxDQUFDMUI7UUFDM0IsSUFBSTNELE1BQU1aLE1BQU0sR0FBRyxHQUFHO1lBQ3BCdUksT0FBTzVILElBQUksQ0FBQztnQkFDVnNFLE1BQU07Z0JBQ05yRSxPQUFPQTtZQUNUO1FBQ0Y7UUFDQSxPQUFPMkg7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbGV4ZXIuanM/ZTI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgdGhyb3dNYWxmb3JtZWRYbWwgPSBfcmVxdWlyZS50aHJvd01hbGZvcm1lZFhtbCxcbiAgdGhyb3dYbWxJbnZhbGlkID0gX3JlcXVpcmUudGhyb3dYbWxJbnZhbGlkLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZS5YVFRlbXBsYXRlRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlMi5pc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kID0gX3JlcXVpcmUyLmlzVGV4dEVuZCxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlMi53b3JkVG9VdGY4O1xudmFyIERFTElNSVRFUl9OT05FID0gMCxcbiAgREVMSU1JVEVSX0VRVUFMID0gMSxcbiAgREVMSU1JVEVSX1NUQVJUID0gMixcbiAgREVMSU1JVEVSX0VORCA9IDM7XG5mdW5jdGlvbiBpblJhbmdlKHJhbmdlLCBtYXRjaCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gbWF0Y2gub2Zmc2V0ICYmIG1hdGNoLm9mZnNldCA8IHJhbmdlWzFdO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZykge1xuICBpZiAoaXNUZXh0U3RhcnQocGFydCkpIHtcbiAgICBpZiAoaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNUZXh0RW5kKHBhcnQpKSB7XG4gICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgIHRocm93TWFsZm9ybWVkWG1sKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaW5UZXh0VGFnO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHRhZykge1xuICB2YXIgcG9zaXRpb24gPSBcIlwiO1xuICB2YXIgc3RhcnQgPSAxO1xuICB2YXIgZW5kID0gdGFnLmluZGV4T2YoXCIgXCIpO1xuICBpZiAodGFnW3RhZy5sZW5ndGggLSAyXSA9PT0gXCIvXCIpIHtcbiAgICBwb3NpdGlvbiA9IFwic2VsZmNsb3NpbmdcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZ1sxXSA9PT0gXCIvXCIpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgcG9zaXRpb24gPSBcImVuZFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSBcInN0YXJ0XCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gdGFnTWF0Y2hlcihjb250ZW50LCB0ZXh0TWF0Y2hBcnJheSwgb3RoZXJzTWF0Y2hBcnJheSkge1xuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgdmFyIGFsbE1hdGNoZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRNYXRjaEFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYWxsTWF0Y2hlc1t0ZXh0TWF0Y2hBcnJheVtpXV0gPSB0cnVlO1xuICB9XG4gIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IG90aGVyc01hdGNoQXJyYXkubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBhbGxNYXRjaGVzW290aGVyc01hdGNoQXJyYXlbX2ldXSA9IGZhbHNlO1xuICB9XG4gIHZhciB0b3RhbE1hdGNoZXMgPSBbXTtcbiAgd2hpbGUgKGN1cnNvciA8IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBjdXJzb3IgPSBjb250ZW50LmluZGV4T2YoXCI8XCIsIGN1cnNvcik7XG4gICAgaWYgKGN1cnNvciA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gY3Vyc29yO1xuICAgIHZhciBuZXh0T3BlbmluZyA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiwgY3Vyc29yICsgMSk7XG4gICAgY3Vyc29yID0gY29udGVudC5pbmRleE9mKFwiPlwiLCBjdXJzb3IpO1xuICAgIGlmIChjdXJzb3IgPT09IC0xIHx8IG5leHRPcGVuaW5nICE9PSAtMSAmJiBjdXJzb3IgPiBuZXh0T3BlbmluZykge1xuICAgICAgdGhyb3dYbWxJbnZhbGlkKGNvbnRlbnQsIG9mZnNldCk7XG4gICAgfVxuICAgIHZhciB0YWdUZXh0ID0gY29udGVudC5zbGljZShvZmZzZXQsIGN1cnNvciArIDEpO1xuICAgIHZhciBfZ2V0VGFnID0gZ2V0VGFnKHRhZ1RleHQpLFxuICAgICAgdGFnID0gX2dldFRhZy50YWcsXG4gICAgICBwb3NpdGlvbiA9IF9nZXRUYWcucG9zaXRpb247XG4gICAgdmFyIHRleHQgPSBhbGxNYXRjaGVzW3RhZ107XG4gICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRvdGFsTWF0Y2hlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICB2YWx1ZTogdGFnVGV4dCxcbiAgICAgIHRhZzogdGFnXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRvdGFsTWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldERlbGltaXRlckVycm9ycyhkZWxpbWl0ZXJNYXRjaGVzLCBmdWxsVGV4dCwgc3ludGF4T3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBpbkRlbGltaXRlciA9IGZhbHNlO1xuICB2YXIgbGFzdERlbGltaXRlck1hdGNoID0ge1xuICAgIG9mZnNldDogMFxuICB9O1xuICB2YXIgeHRhZztcbiAgdmFyIGRlbGltaXRlcldpdGhFcnJvcnMgPSBkZWxpbWl0ZXJNYXRjaGVzLnJlZHVjZShmdW5jdGlvbiAoZGVsaW1pdGVyQWNjLCBjdXJyRGVsaW1pdGVyTWF0Y2gpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBjdXJyRGVsaW1pdGVyTWF0Y2gucG9zaXRpb247XG4gICAgdmFyIGRlbGltaXRlck9mZnNldCA9IGN1cnJEZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJPZmZzZXQgPSBsYXN0RGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHZhciBsYXN0RGVsaW1pdGVyTGVuZ3RoID0gbGFzdERlbGltaXRlck1hdGNoLmxlbmd0aDtcbiAgICB4dGFnID0gZnVsbFRleHQuc3Vic3RyKGxhc3REZWxpbWl0ZXJPZmZzZXQsIGRlbGltaXRlck9mZnNldCAtIGxhc3REZWxpbWl0ZXJPZmZzZXQpO1xuICAgIGlmIChpbkRlbGltaXRlciAmJiBwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBpZiAobGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggPT09IGRlbGltaXRlck9mZnNldCkge1xuICAgICAgICB4dGFnID0gZnVsbFRleHQuc3Vic3RyKGxhc3REZWxpbWl0ZXJPZmZzZXQsIGRlbGltaXRlck9mZnNldCAtIGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoICsgNCk7XG4gICAgICAgIGVycm9ycy5wdXNoKGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgIH0pKTtcbiAgICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgfVxuICAgIGlmICghaW5EZWxpbWl0ZXIgJiYgcG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgIGlmIChzeW50YXhPcHRpb25zLmFsbG93VW5vcGVuZWRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCA9PT0gZGVsaW1pdGVyT2Zmc2V0KSB7XG4gICAgICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCAtIDQsIGRlbGltaXRlck9mZnNldCAtIGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoICsgNCk7XG4gICAgICAgIGVycm9ycy5wdXNoKGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgICB4dGFnOiB4dGFnLFxuICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICB9KSk7XG4gICAgICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgIH1cbiAgICAgIGVycm9ycy5wdXNoKGdldFVub3BlbmVkVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgb2Zmc2V0OiBkZWxpbWl0ZXJPZmZzZXRcbiAgICAgIH0pKTtcbiAgICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgfVxuICAgIGluRGVsaW1pdGVyID0gIWluRGVsaW1pdGVyO1xuICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICBkZWxpbWl0ZXJBY2MucHVzaChjdXJyRGVsaW1pdGVyTWF0Y2gpO1xuICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gIH0sIFtdKTtcbiAgaWYgKGluRGVsaW1pdGVyKSB7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJPZmZzZXQgPSBsYXN0RGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZnVsbFRleHQubGVuZ3RoIC0gbGFzdERlbGltaXRlck9mZnNldCk7XG4gICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgeHRhZzogd29yZFRvVXRmOCh4dGFnKSxcbiAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlbGltaXRlcldpdGhFcnJvcnM6IGRlbGltaXRlcldpdGhFcnJvcnMsXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVPZmZzZXRzKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAtMSAmJiBlbmRPZmZzZXQgPT09IC0xKSB7XG4gICAgcmV0dXJuIERFTElNSVRFUl9OT05FO1xuICB9XG4gIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgcmV0dXJuIERFTElNSVRFUl9FUVVBTDtcbiAgfVxuICBpZiAoc3RhcnRPZmZzZXQgPT09IC0xIHx8IGVuZE9mZnNldCA9PT0gLTEpIHtcbiAgICByZXR1cm4gZW5kT2Zmc2V0IDwgc3RhcnRPZmZzZXQgPyBERUxJTUlURVJfU1RBUlQgOiBERUxJTUlURVJfRU5EO1xuICB9XG4gIHJldHVybiBzdGFydE9mZnNldCA8IGVuZE9mZnNldCA/IERFTElNSVRFUl9TVEFSVCA6IERFTElNSVRFUl9FTkQ7XG59XG5mdW5jdGlvbiBzcGxpdERlbGltaXRlcnMoaW5zaWRlKSB7XG4gIHZhciBuZXdEZWxpbWl0ZXJzID0gaW5zaWRlLnNwbGl0KFwiIFwiKTtcbiAgaWYgKG5ld0RlbGltaXRlcnMubGVuZ3RoICE9PSAyKSB7XG4gICAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJOZXcgRGVsaW1pdGVycyBjYW5ub3QgYmUgcGFyc2VkXCIpO1xuICAgIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgaWQ6IFwiY2hhbmdlX2RlbGltaXRlcnNfaW52YWxpZFwiLFxuICAgICAgZXhwbGFuYXRpb246IFwiQ2Fubm90IHBhcnNlciBkZWxpbWl0ZXJzXCJcbiAgICB9O1xuICAgIHRocm93IGVycjtcbiAgfVxuICB2YXIgX25ld0RlbGltaXRlcnMgPSBfc2xpY2VkVG9BcnJheShuZXdEZWxpbWl0ZXJzLCAyKSxcbiAgICBzdGFydCA9IF9uZXdEZWxpbWl0ZXJzWzBdLFxuICAgIGVuZCA9IF9uZXdEZWxpbWl0ZXJzWzFdO1xuICBpZiAoc3RhcnQubGVuZ3RoID09PSAwIHx8IGVuZC5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgX2VyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJOZXcgRGVsaW1pdGVycyBjYW5ub3QgYmUgcGFyc2VkXCIpO1xuICAgIF9lcnIucHJvcGVydGllcyA9IHtcbiAgICAgIGlkOiBcImNoYW5nZV9kZWxpbWl0ZXJzX2ludmFsaWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIkNhbm5vdCBwYXJzZXIgZGVsaW1pdGVyc1wiXG4gICAgfTtcbiAgICB0aHJvdyBfZXJyO1xuICB9XG4gIHJldHVybiBbc3RhcnQsIGVuZF07XG59XG5mdW5jdGlvbiBnZXRBbGxEZWxpbWl0ZXJJbmRleGVzKGZ1bGxUZXh0LCBkZWxpbWl0ZXJzKSB7XG4gIHZhciBpbmRleGVzID0gW107XG4gIHZhciBzdGFydCA9IGRlbGltaXRlcnMuc3RhcnQsXG4gICAgZW5kID0gZGVsaW1pdGVycy5lbmQ7XG4gIHZhciBvZmZzZXQgPSAtMTtcbiAgdmFyIGluc2lkZVRhZyA9IGZhbHNlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2Yoc3RhcnQsIG9mZnNldCArIDEpO1xuICAgIHZhciBlbmRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKGVuZCwgb2Zmc2V0ICsgMSk7XG4gICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgIHZhciBjb21wYXJlUmVzdWx0ID0gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9FUVVBTCkge1xuICAgICAgY29tcGFyZVJlc3VsdCA9IGluc2lkZVRhZyA/IERFTElNSVRFUl9FTkQgOiBERUxJTUlURVJfU1RBUlQ7XG4gICAgfVxuICAgIHN3aXRjaCAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgY2FzZSBERUxJTUlURVJfTk9ORTpcbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICBjYXNlIERFTElNSVRFUl9FTkQ6XG4gICAgICAgIGluc2lkZVRhZyA9IGZhbHNlO1xuICAgICAgICBvZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICAgICAgbGVuID0gZW5kLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFTElNSVRFUl9TVEFSVDpcbiAgICAgICAgaW5zaWRlVGFnID0gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgICAgICBsZW4gPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBpZiB0YWcgc3RhcnRzIHdpdGggPSwgc3VjaCBhcyB7PVsgXT19XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9TVEFSVCAmJiBmdWxsVGV4dFtvZmZzZXQgKyBzdGFydC5sZW5ndGhdID09PSBcIj1cIikge1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwic3RhcnRcIixcbiAgICAgICAgbGVuZ3RoOiBzdGFydC5sZW5ndGgsXG4gICAgICAgIGNoYW5nZWRlbGltaXRlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgbmV4dEVxdWFsID0gZnVsbFRleHQuaW5kZXhPZihcIj1cIiwgb2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSk7XG4gICAgICB2YXIgbmV4dEVuZE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2YoZW5kLCBuZXh0RXF1YWwgKyAxKTtcbiAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgIG9mZnNldDogbmV4dEVuZE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCIsXG4gICAgICAgIGxlbmd0aDogZW5kLmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBfaW5zaWRlVGFnID0gZnVsbFRleHQuc3Vic3RyKG9mZnNldCArIHN0YXJ0Lmxlbmd0aCArIDEsIG5leHRFcXVhbCAtIG9mZnNldCAtIHN0YXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIF9zcGxpdERlbGltaXRlcnMgPSBzcGxpdERlbGltaXRlcnMoX2luc2lkZVRhZyk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVyczIgPSBfc2xpY2VkVG9BcnJheShfc3BsaXREZWxpbWl0ZXJzLCAyKTtcbiAgICAgIHN0YXJ0ID0gX3NwbGl0RGVsaW1pdGVyczJbMF07XG4gICAgICBlbmQgPSBfc3BsaXREZWxpbWl0ZXJzMlsxXTtcbiAgICAgIG9mZnNldCA9IG5leHRFbmRPZmZzZXQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VEZWxpbWl0ZXJzKGlubmVyQ29udGVudFBhcnRzLCBkZWxpbWl0ZXJzLCBzeW50YXhPcHRpb25zKSB7XG4gIHZhciBmdWxsID0gaW5uZXJDb250ZW50UGFydHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAudmFsdWU7XG4gIH0pLmpvaW4oXCJcIik7XG4gIHZhciBkZWxpbWl0ZXJNYXRjaGVzID0gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsLCBkZWxpbWl0ZXJzKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciByYW5nZXMgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICBvZmZzZXQgKz0gcGFydC52YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0IC0gcGFydC52YWx1ZS5sZW5ndGgsXG4gICAgICBsSW5kZXg6IHBhcnQubEluZGV4XG4gICAgfTtcbiAgfSk7XG4gIHZhciBfZ2V0RGVsaW1pdGVyRXJyb3JzID0gZ2V0RGVsaW1pdGVyRXJyb3JzKGRlbGltaXRlck1hdGNoZXMsIGZ1bGwsIHN5bnRheE9wdGlvbnMpLFxuICAgIGRlbGltaXRlcldpdGhFcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmRlbGltaXRlcldpdGhFcnJvcnMsXG4gICAgZXJyb3JzID0gX2dldERlbGltaXRlckVycm9ycy5lcnJvcnM7XG4gIHZhciBjdXROZXh0ID0gMDtcbiAgdmFyIGRlbGltaXRlckluZGV4ID0gMDtcbiAgdmFyIHBhcnNlZCA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gcC5vZmZzZXQ7XG4gICAgdmFyIHJhbmdlID0gW29mZnNldCwgb2Zmc2V0ICsgaW5uZXJDb250ZW50UGFydHNbaV0udmFsdWUubGVuZ3RoXTtcbiAgICB2YXIgcGFydENvbnRlbnQgPSBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZTtcbiAgICB2YXIgZGVsaW1pdGVyc0luT2Zmc2V0ID0gW107XG4gICAgd2hpbGUgKGRlbGltaXRlckluZGV4IDwgZGVsaW1pdGVyV2l0aEVycm9ycy5sZW5ndGggJiYgaW5SYW5nZShyYW5nZSwgZGVsaW1pdGVyV2l0aEVycm9yc1tkZWxpbWl0ZXJJbmRleF0pKSB7XG4gICAgICBkZWxpbWl0ZXJzSW5PZmZzZXQucHVzaChkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSk7XG4gICAgICBkZWxpbWl0ZXJJbmRleCsrO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgY3Vyc29yID0gMDtcbiAgICBpZiAoY3V0TmV4dCA+IDApIHtcbiAgICAgIGN1cnNvciA9IGN1dE5leHQ7XG4gICAgICBjdXROZXh0ID0gMDtcbiAgICB9XG4gICAgZGVsaW1pdGVyc0luT2Zmc2V0LmZvckVhY2goZnVuY3Rpb24gKGRlbGltaXRlckluT2Zmc2V0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0Q29udGVudC5zdWJzdHIoY3Vyc29yLCBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgLSBjdXJzb3IpO1xuICAgICAgaWYgKGRlbGltaXRlckluT2Zmc2V0LmNoYW5nZWRlbGltaXRlcikge1xuICAgICAgICBpZiAoZGVsaW1pdGVySW5PZmZzZXQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnNvciArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgZGVsaW1pdGVyUGFydCA9IHtcbiAgICAgICAgdHlwZTogXCJkZWxpbWl0ZXJcIixcbiAgICAgICAgcG9zaXRpb246IGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uLFxuICAgICAgICBvZmZzZXQ6IGN1cnNvciArIG9mZnNldFxuICAgICAgfTtcbiAgICAgIHBhcnRzLnB1c2goZGVsaW1pdGVyUGFydCk7XG4gICAgICBjdXJzb3IgPSBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgKyBkZWxpbWl0ZXJJbk9mZnNldC5sZW5ndGg7XG4gICAgfSk7XG4gICAgY3V0TmV4dCA9IGN1cnNvciAtIHBhcnRDb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0Q29udGVudC5zdWJzdHIoY3Vyc29yKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBpc0luc2lkZUNvbnRlbnQocGFydCkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGUgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIiB3b3VsZCBiZSBlbm91Z2ggYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICByZXR1cm4gcGFydC50eXBlID09PSBcImNvbnRlbnRcIiAmJiBwYXJ0LnBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5mdW5jdGlvbiBnZXRDb250ZW50UGFydHMoeG1scGFyc2VkKSB7XG4gIHJldHVybiB4bWxwYXJzZWQuZmlsdGVyKGlzSW5zaWRlQ29udGVudCk7XG59XG5mdW5jdGlvbiBkZWNvZGVDb250ZW50UGFydHMoeG1scGFyc2VkLCBmaWxlVHlwZSkge1xuICB2YXIgaW5UZXh0VGFnID0gZmFsc2U7XG4gIHhtbHBhcnNlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgaW5UZXh0VGFnID0gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZyk7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHBhcnQucG9zaXRpb24gPSBpblRleHRUYWcgPyBcImluc2lkZXRhZ1wiIDogXCJvdXRzaWRldGFnXCI7XG4gICAgfVxuICAgIGlmIChmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIgJiYgaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICBwYXJ0LnZhbHVlID0gcGFydC52YWx1ZS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlRGVsaW1pdGVyczogcGFyc2VEZWxpbWl0ZXJzLFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoeG1sbGV4ZWQsIGRlbGltaXRlcnMsIHN5bnRheCwgZmlsZVR5cGUpIHtcbiAgICBkZWNvZGVDb250ZW50UGFydHMoeG1sbGV4ZWQsIGZpbGVUeXBlKTtcbiAgICB2YXIgX3BhcnNlRGVsaW1pdGVycyA9IHBhcnNlRGVsaW1pdGVycyhnZXRDb250ZW50UGFydHMoeG1sbGV4ZWQpLCBkZWxpbWl0ZXJzLCBzeW50YXgpLFxuICAgICAgZGVsaW1pdGVyUGFyc2VkID0gX3BhcnNlRGVsaW1pdGVycy5wYXJzZWQsXG4gICAgICBlcnJvcnMgPSBfcGFyc2VEZWxpbWl0ZXJzLmVycm9ycztcbiAgICB2YXIgbGV4ZWQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsSW5kZXggPSAwO1xuICAgIHhtbGxleGVkLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIGlmIChpc0luc2lkZUNvbnRlbnQocGFydCkpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGV4ZWQsIGRlbGltaXRlclBhcnNlZFtpbmRleF0ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAgIHAucG9zaXRpb24gPSBcImluc2lkZXRhZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0LmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICBsZXhlZC5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIGxleGVkOiBsZXhlZFxuICAgIH07XG4gIH0sXG4gIHhtbHBhcnNlOiBmdW5jdGlvbiB4bWxwYXJzZShjb250ZW50LCB4bWx0YWdzKSB7XG4gICAgdmFyIG1hdGNoZXMgPSB0YWdNYXRjaGVyKGNvbnRlbnQsIHhtbHRhZ3MudGV4dCwgeG1sdGFncy5vdGhlcik7XG4gICAgdmFyIGN1cnNvciA9IDA7XG4gICAgdmFyIHBhcnNlZCA9IG1hdGNoZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJzZWQsIG1hdGNoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjb250ZW50LnN1YnN0cihjdXJzb3IsIG1hdGNoLm9mZnNldCAtIGN1cnNvcik7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY3Vyc29yID0gbWF0Y2gub2Zmc2V0ICsgbWF0Y2gudmFsdWUubGVuZ3RoO1xuICAgICAgZGVsZXRlIG1hdGNoLm9mZnNldDtcbiAgICAgIHBhcnNlZC5wdXNoKG1hdGNoKTtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSwgW10pO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRlbnQuc3Vic3RyKGN1cnNvcik7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsInIiLCJsIiwidCIsImUiLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImlzQXJyYXkiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImdldFVuY2xvc2VkVGFnRXhjZXB0aW9uIiwiZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24iLCJnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uIiwiZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24iLCJ0aHJvd01hbGZvcm1lZFhtbCIsInRocm93WG1sSW52YWxpZCIsIlhUVGVtcGxhdGVFcnJvciIsIl9yZXF1aXJlMiIsImlzVGV4dFN0YXJ0IiwiaXNUZXh0RW5kIiwid29yZFRvVXRmOCIsIkRFTElNSVRFUl9OT05FIiwiREVMSU1JVEVSX0VRVUFMIiwiREVMSU1JVEVSX1NUQVJUIiwiREVMSU1JVEVSX0VORCIsImluUmFuZ2UiLCJyYW5nZSIsIm1hdGNoIiwib2Zmc2V0IiwidXBkYXRlSW5UZXh0VGFnIiwicGFydCIsImluVGV4dFRhZyIsImdldFRhZyIsInRhZyIsInBvc2l0aW9uIiwic3RhcnQiLCJlbmQiLCJpbmRleE9mIiwidGFnTWF0Y2hlciIsImNvbnRlbnQiLCJ0ZXh0TWF0Y2hBcnJheSIsIm90aGVyc01hdGNoQXJyYXkiLCJjdXJzb3IiLCJjb250ZW50TGVuZ3RoIiwiYWxsTWF0Y2hlcyIsIl9pIiwiX2xlbiIsInRvdGFsTWF0Y2hlcyIsIm5leHRPcGVuaW5nIiwidGFnVGV4dCIsIl9nZXRUYWciLCJ0ZXh0IiwidHlwZSIsImdldERlbGltaXRlckVycm9ycyIsImRlbGltaXRlck1hdGNoZXMiLCJmdWxsVGV4dCIsInN5bnRheE9wdGlvbnMiLCJlcnJvcnMiLCJpbkRlbGltaXRlciIsImxhc3REZWxpbWl0ZXJNYXRjaCIsInh0YWciLCJkZWxpbWl0ZXJXaXRoRXJyb3JzIiwicmVkdWNlIiwiZGVsaW1pdGVyQWNjIiwiY3VyckRlbGltaXRlck1hdGNoIiwiZGVsaW1pdGVyT2Zmc2V0IiwibGFzdERlbGltaXRlck9mZnNldCIsImxhc3REZWxpbWl0ZXJMZW5ndGgiLCJzdWJzdHIiLCJlcnJvciIsImFsbG93VW5vcGVuZWRUYWciLCJjb21wYXJlT2Zmc2V0cyIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0Iiwic3BsaXREZWxpbWl0ZXJzIiwiaW5zaWRlIiwibmV3RGVsaW1pdGVycyIsInNwbGl0IiwiZXJyIiwicHJvcGVydGllcyIsImlkIiwiZXhwbGFuYXRpb24iLCJfbmV3RGVsaW1pdGVycyIsIl9lcnIiLCJnZXRBbGxEZWxpbWl0ZXJJbmRleGVzIiwiZGVsaW1pdGVycyIsImluZGV4ZXMiLCJpbnNpZGVUYWciLCJjb21wYXJlUmVzdWx0IiwiY2hhbmdlZGVsaW1pdGVyIiwibmV4dEVxdWFsIiwibmV4dEVuZE9mZnNldCIsIl9pbnNpZGVUYWciLCJfc3BsaXREZWxpbWl0ZXJzIiwiX3NwbGl0RGVsaW1pdGVyczIiLCJwYXJzZURlbGltaXRlcnMiLCJpbm5lckNvbnRlbnRQYXJ0cyIsImZ1bGwiLCJtYXAiLCJwIiwiam9pbiIsInJhbmdlcyIsImxJbmRleCIsIl9nZXREZWxpbWl0ZXJFcnJvcnMiLCJjdXROZXh0IiwiZGVsaW1pdGVySW5kZXgiLCJwYXJzZWQiLCJwYXJ0Q29udGVudCIsImRlbGltaXRlcnNJbk9mZnNldCIsInBhcnRzIiwiZGVsaW1pdGVySW5PZmZzZXQiLCJkZWxpbWl0ZXJQYXJ0IiwiaXNJbnNpZGVDb250ZW50IiwiZ2V0Q29udGVudFBhcnRzIiwieG1scGFyc2VkIiwiZGVjb2RlQ29udGVudFBhcnRzIiwiZmlsZVR5cGUiLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlIiwieG1sbGV4ZWQiLCJzeW50YXgiLCJfcGFyc2VEZWxpbWl0ZXJzIiwiZGVsaW1pdGVyUGFyc2VkIiwibGV4ZWQiLCJpbmRleCIsInhtbHBhcnNlIiwieG1sdGFncyIsIm1hdGNoZXMiLCJvdGhlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/merge-sort.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/merge-sort.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nfunction getMinFromArrays(arrays, state) {\n    var minIndex = -1;\n    for(var i = 0, l = arrays.length; i < l; i++){\n        if (state[i] >= arrays[i].length) {\n            continue;\n        }\n        if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}\nmodule.exports = function(arrays) {\n    var totalLength = arrays.reduce(function(sum, array) {\n        return sum + array.length;\n    }, 0);\n    arrays = arrays.filter(function(array) {\n        return array.length > 0;\n    });\n    var resultArray = new Array(totalLength);\n    var state = arrays.map(function() {\n        return 0;\n    });\n    for(var i = 0; i < totalLength; i++){\n        var arrayIndex = getMinFromArrays(arrays, state);\n        resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n        state[arrayIndex]++;\n    }\n    return resultArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tZXJnZS1zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsaUJBQWlCQyxNQUFNLEVBQUVDLEtBQUs7SUFDckMsSUFBSUMsV0FBVyxDQUFDO0lBQ2hCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJSixPQUFPSyxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQUs7UUFDN0MsSUFBSUYsS0FBSyxDQUFDRSxFQUFFLElBQUlILE1BQU0sQ0FBQ0csRUFBRSxDQUFDRSxNQUFNLEVBQUU7WUFDaEM7UUFDRjtRQUNBLElBQUlILGFBQWEsQ0FBQyxLQUFLRixNQUFNLENBQUNHLEVBQUUsQ0FBQ0YsS0FBSyxDQUFDRSxFQUFFLENBQUMsQ0FBQ0csTUFBTSxHQUFHTixNQUFNLENBQUNFLFNBQVMsQ0FBQ0QsS0FBSyxDQUFDQyxTQUFTLENBQUMsQ0FBQ0ksTUFBTSxFQUFFO1lBQzVGSixXQUFXQztRQUNiO0lBQ0Y7SUFDQSxPQUFPRDtBQUNUO0FBQ0FLLE9BQU9DLE9BQU8sR0FBRyxTQUFVUixNQUFNO0lBQy9CLElBQUlTLGNBQWNULE9BQU9VLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLEtBQUs7UUFDbEQsT0FBT0QsTUFBTUMsTUFBTVAsTUFBTTtJQUMzQixHQUFHO0lBQ0hMLFNBQVNBLE9BQU9hLE1BQU0sQ0FBQyxTQUFVRCxLQUFLO1FBQ3BDLE9BQU9BLE1BQU1QLE1BQU0sR0FBRztJQUN4QjtJQUNBLElBQUlTLGNBQWMsSUFBSUMsTUFBTU47SUFDNUIsSUFBSVIsUUFBUUQsT0FBT2dCLEdBQUcsQ0FBQztRQUNyQixPQUFPO0lBQ1Q7SUFDQSxJQUFLLElBQUliLElBQUksR0FBR0EsSUFBSU0sYUFBYU4sSUFBSztRQUNwQyxJQUFJYyxhQUFhbEIsaUJBQWlCQyxRQUFRQztRQUMxQ2EsV0FBVyxDQUFDWCxFQUFFLEdBQUdILE1BQU0sQ0FBQ2lCLFdBQVcsQ0FBQ2hCLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQztRQUN0RGhCLEtBQUssQ0FBQ2dCLFdBQVc7SUFDbkI7SUFDQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWVyZ2Utc29ydC5qcz83MTY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpIHtcbiAgdmFyIG1pbkluZGV4ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZVtpXSA+PSBhcnJheXNbaV0ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1pbkluZGV4ID09PSAtMSB8fCBhcnJheXNbaV1bc3RhdGVbaV1dLm9mZnNldCA8IGFycmF5c1ttaW5JbmRleF1bc3RhdGVbbWluSW5kZXhdXS5vZmZzZXQpIHtcbiAgICAgIG1pbkluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkluZGV4O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlzKSB7XG4gIHZhciB0b3RhbExlbmd0aCA9IGFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgYXJyYXkpIHtcbiAgICByZXR1cm4gc3VtICsgYXJyYXkubGVuZ3RoO1xuICB9LCAwKTtcbiAgYXJyYXlzID0gYXJyYXlzLmZpbHRlcihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMDtcbiAgfSk7XG4gIHZhciByZXN1bHRBcnJheSA9IG5ldyBBcnJheSh0b3RhbExlbmd0aCk7XG4gIHZhciBzdGF0ZSA9IGFycmF5cy5tYXAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbExlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFycmF5SW5kZXggPSBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpO1xuICAgIHJlc3VsdEFycmF5W2ldID0gYXJyYXlzW2FycmF5SW5kZXhdW3N0YXRlW2FycmF5SW5kZXhdXTtcbiAgICBzdGF0ZVthcnJheUluZGV4XSsrO1xuICB9XG4gIHJldHVybiByZXN1bHRBcnJheTtcbn07Il0sIm5hbWVzIjpbImdldE1pbkZyb21BcnJheXMiLCJhcnJheXMiLCJzdGF0ZSIsIm1pbkluZGV4IiwiaSIsImwiLCJsZW5ndGgiLCJvZmZzZXQiLCJtb2R1bGUiLCJleHBvcnRzIiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJzdW0iLCJhcnJheSIsImZpbHRlciIsInJlc3VsdEFycmF5IiwiQXJyYXkiLCJtYXAiLCJhcnJheUluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/module-wrapper.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/module-wrapper.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n    return i;\n}\nmodule.exports = function(module1) {\n    var defaults = {\n        set: emptyFun,\n        matchers: function matchers() {\n            return [];\n        },\n        parse: emptyFun,\n        render: emptyFun,\n        getTraits: emptyFun,\n        getFileType: emptyFun,\n        nullGetter: emptyFun,\n        optionsTransformer: identity,\n        postrender: identity,\n        errorsTransformer: identity,\n        getRenderedMap: identity,\n        preparse: identity,\n        postparse: identity,\n        on: emptyFun,\n        resolve: emptyFun,\n        preResolve: emptyFun\n    };\n    if (Object.keys(defaults).every(function(key) {\n        return !module1[key];\n    })) {\n        var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n        err.properties = {\n            id: \"module_cannot_be_wrapped\",\n            explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n        };\n        throw err;\n    }\n    Object.keys(defaults).forEach(function(key) {\n        module1[key] = module1[key] || defaults[key];\n    });\n    return module1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLG9FQUFhLEdBQ2xDQyxrQkFBa0JGLFNBQVNFLGVBQWU7QUFDNUMsU0FBU0MsWUFBWTtBQUNyQixTQUFTQyxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9BO0FBQ1Q7QUFDQUMsT0FBT0MsT0FBTyxHQUFHLFNBQVVELE9BQU07SUFDL0IsSUFBSUUsV0FBVztRQUNiQyxLQUFLTjtRQUNMTyxVQUFVLFNBQVNBO1lBQ2pCLE9BQU8sRUFBRTtRQUNYO1FBQ0FDLE9BQU9SO1FBQ1BTLFFBQVFUO1FBQ1JVLFdBQVdWO1FBQ1hXLGFBQWFYO1FBQ2JZLFlBQVlaO1FBQ1phLG9CQUFvQlo7UUFDcEJhLFlBQVliO1FBQ1pjLG1CQUFtQmQ7UUFDbkJlLGdCQUFnQmY7UUFDaEJnQixVQUFVaEI7UUFDVmlCLFdBQVdqQjtRQUNYa0IsSUFBSW5CO1FBQ0pvQixTQUFTcEI7UUFDVHFCLFlBQVlyQjtJQUNkO0lBQ0EsSUFBSXNCLE9BQU9DLElBQUksQ0FBQ2xCLFVBQVVtQixLQUFLLENBQUMsU0FBVUMsR0FBRztRQUMzQyxPQUFPLENBQUN0QixPQUFNLENBQUNzQixJQUFJO0lBQ3JCLElBQUk7UUFDRixJQUFJQyxNQUFNLElBQUkzQixnQkFBZ0I7UUFDOUIyQixJQUFJQyxVQUFVLEdBQUc7WUFDZkMsSUFBSTtZQUNKQyxhQUFhO1FBQ2Y7UUFDQSxNQUFNSDtJQUNSO0lBQ0FKLE9BQU9DLElBQUksQ0FBQ2xCLFVBQVV5QixPQUFPLENBQUMsU0FBVUwsR0FBRztRQUN6Q3RCLE9BQU0sQ0FBQ3NCLElBQUksR0FBR3RCLE9BQU0sQ0FBQ3NCLElBQUksSUFBSXBCLFFBQVEsQ0FBQ29CLElBQUk7SUFDNUM7SUFDQSxPQUFPdEI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZS13cmFwcGVyLmpzPzAzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRJbnRlcm5hbEVycm9yID0gX3JlcXVpcmUuWFRJbnRlcm5hbEVycm9yO1xuZnVuY3Rpb24gZW1wdHlGdW4oKSB7fVxuZnVuY3Rpb24gaWRlbnRpdHkoaSkge1xuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgc2V0OiBlbXB0eUZ1bixcbiAgICBtYXRjaGVyczogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBwYXJzZTogZW1wdHlGdW4sXG4gICAgcmVuZGVyOiBlbXB0eUZ1bixcbiAgICBnZXRUcmFpdHM6IGVtcHR5RnVuLFxuICAgIGdldEZpbGVUeXBlOiBlbXB0eUZ1bixcbiAgICBudWxsR2V0dGVyOiBlbXB0eUZ1bixcbiAgICBvcHRpb25zVHJhbnNmb3JtZXI6IGlkZW50aXR5LFxuICAgIHBvc3RyZW5kZXI6IGlkZW50aXR5LFxuICAgIGVycm9yc1RyYW5zZm9ybWVyOiBpZGVudGl0eSxcbiAgICBnZXRSZW5kZXJlZE1hcDogaWRlbnRpdHksXG4gICAgcHJlcGFyc2U6IGlkZW50aXR5LFxuICAgIHBvc3RwYXJzZTogaWRlbnRpdHksXG4gICAgb246IGVtcHR5RnVuLFxuICAgIHJlc29sdmU6IGVtcHR5RnVuLFxuICAgIHByZVJlc29sdmU6IGVtcHR5RnVuXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhkZWZhdWx0cykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhbW9kdWxlW2tleV07XG4gIH0pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGlzIG1vZHVsZSBjYW5ub3QgYmUgd3JhcHBlZCwgYmVjYXVzZSBpdCBkb2Vzbid0IGRlZmluZSBhbnkgb2YgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbnNcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJtb2R1bGVfY2Fubm90X2JlX3dyYXBwZWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIlRoaXMgbW9kdWxlIGNhbm5vdCBiZSB3cmFwcGVkLCBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVmaW5lIGFueSBvZiB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIG1vZHVsZVtrZXldID0gbW9kdWxlW2tleV0gfHwgZGVmYXVsdHNba2V5XTtcbiAgfSk7XG4gIHJldHVybiBtb2R1bGU7XG59OyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJYVEludGVybmFsRXJyb3IiLCJlbXB0eUZ1biIsImlkZW50aXR5IiwiaSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0cyIsInNldCIsIm1hdGNoZXJzIiwicGFyc2UiLCJyZW5kZXIiLCJnZXRUcmFpdHMiLCJnZXRGaWxlVHlwZSIsIm51bGxHZXR0ZXIiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJwb3N0cmVuZGVyIiwiZXJyb3JzVHJhbnNmb3JtZXIiLCJnZXRSZW5kZXJlZE1hcCIsInByZXBhcnNlIiwicG9zdHBhcnNlIiwib24iLCJyZXNvbHZlIiwicHJlUmVzb2x2ZSIsIk9iamVjdCIsImtleXMiLCJldmVyeSIsImtleSIsImVyciIsInByb3BlcnRpZXMiLCJpZCIsImV4cGxhbmF0aW9uIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/common.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nvar _require = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/content-types.js\"), settingsContentType = _require.settingsContentType, coreContentType = _require.coreContentType, appContentType = _require.appContentType, customContentType = _require.customContentType;\nvar commonContentTypes = [\n    settingsContentType,\n    coreContentType,\n    appContentType,\n    customContentType\n];\nvar Common = /*#__PURE__*/ function() {\n    function Common() {\n        _classCallCheck(this, Common);\n        this.name = \"Common\";\n    }\n    return _createClass(Common, [\n        {\n            key: \"getFileType\",\n            value: function getFileType(_ref) {\n                var doc = _ref.doc;\n                var invertedContentTypes = doc.invertedContentTypes;\n                if (!invertedContentTypes) {\n                    return;\n                }\n                for(var j = 0, len2 = commonContentTypes.length; j < len2; j++){\n                    var ct = commonContentTypes[j];\n                    if (invertedContentTypes[ct]) {\n                        Array.prototype.push.apply(doc.targets, invertedContentTypes[ct]);\n                    }\n                }\n                var keys = [\n                    \"docx\",\n                    \"pptx\"\n                ];\n                var ftCandidate;\n                for(var i = 0, len = keys.length; i < len; i++){\n                    var contentTypes = filetypes[keys[i]];\n                    for(var _j = 0, _len = contentTypes.length; _j < _len; _j++){\n                        var _ct = contentTypes[_j];\n                        if (invertedContentTypes[_ct]) {\n                            for(var k = 0, _len2 = invertedContentTypes[_ct].length; k < _len2; k++){\n                                var target = invertedContentTypes[_ct][k];\n                                if (doc.relsTypes[target] && [\n                                    \"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\",\n                                    \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"\n                                ].indexOf(doc.relsTypes[target]) === -1) {\n                                    continue;\n                                }\n                                ftCandidate = keys[i];\n                                if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                                    doc.textTarget || (doc.textTarget = target);\n                                }\n                                doc.targets.push(target);\n                            }\n                        }\n                    }\n                    if (ftCandidate) {\n                        return ftCandidate;\n                    }\n                }\n                return ftCandidate;\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new Common());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUN4SixTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFBRUUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTUMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRVSxlQUFlTixXQUFXTyxHQUFHLEdBQUdQO0lBQWE7QUFBRTtBQUM1VSxTQUFTUSxhQUFhZixXQUFXLEVBQUVnQixVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZZCxrQkFBa0JGLFlBQVlILFNBQVMsRUFBRW1CO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCRixhQUFhaUI7SUFBY04sT0FBT0MsY0FBYyxDQUFDWixhQUFhLGFBQWE7UUFBRVUsVUFBVTtJ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RjtnQ0FDQStDLGNBQWNELElBQUksQ0FBQzVDLEVBQUU7Z0NBQ3JCLElBQUl1QixVQUFVZ0MsSUFBSSxDQUFDRCxPQUFPLENBQUNKLFNBQVMsQ0FBQyxLQUFLQSxRQUFRM0IsVUFBVWlDLElBQUksQ0FBQyxFQUFFLEVBQUU7b0NBQ25FckIsSUFBSXNCLFVBQVUsSUFBS3RCLENBQUFBLElBQUlzQixVQUFVLEdBQUczRCxNQUFLO2dDQUMzQztnQ0FDQXFDLElBQUlRLE9BQU8sQ0FBQ0YsSUFBSSxDQUFDM0M7NEJBQ25CO3dCQUNGO29CQUNGO29CQUNBLElBQUkrQyxhQUFhO3dCQUNmLE9BQU9BO29CQUNUO2dCQUNGO2dCQUNBLE9BQU9BO1lBQ1Q7UUFDRjtLQUFFO0FBQ0o7QUFDQWEsT0FBT0MsT0FBTyxHQUFHO0lBQ2YsT0FBT3RDLFFBQVEsSUFBSVM7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcz8wM2IyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4uL2ZpbGV0eXBlcy5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUuc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlID0gX3JlcXVpcmUuY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZSA9IF9yZXF1aXJlLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlLmN1c3RvbUNvbnRlbnRUeXBlO1xudmFyIGNvbW1vbkNvbnRlbnRUeXBlcyA9IFtzZXR0aW5nc0NvbnRlbnRUeXBlLCBjb3JlQ29udGVudFR5cGUsIGFwcENvbnRlbnRUeXBlLCBjdXN0b21Db250ZW50VHlwZV07XG52YXIgQ29tbW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tbW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21tb24pO1xuICAgIHRoaXMubmFtZSA9IFwiQ29tbW9uXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb21tb24sIFt7XG4gICAga2V5OiBcImdldEZpbGVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVUeXBlKF9yZWYpIHtcbiAgICAgIHZhciBkb2MgPSBfcmVmLmRvYztcbiAgICAgIHZhciBpbnZlcnRlZENvbnRlbnRUeXBlcyA9IGRvYy5pbnZlcnRlZENvbnRlbnRUeXBlcztcbiAgICAgIGlmICghaW52ZXJ0ZWRDb250ZW50VHlwZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBjb21tb25Db250ZW50VHlwZXMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIHZhciBjdCA9IGNvbW1vbkNvbnRlbnRUeXBlc1tqXTtcbiAgICAgICAgaWYgKGludmVydGVkQ29udGVudFR5cGVzW2N0XSkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy50YXJnZXRzLCBpbnZlcnRlZENvbnRlbnRUeXBlc1tjdF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IFtcImRvY3hcIiwgXCJwcHR4XCJdO1xuICAgICAgdmFyIGZ0Q2FuZGlkYXRlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IGZpbGV0eXBlc1trZXlzW2ldXTtcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfbGVuID0gY29udGVudFR5cGVzLmxlbmd0aDsgX2ogPCBfbGVuOyBfaisrKSB7XG4gICAgICAgICAgdmFyIF9jdCA9IGNvbnRlbnRUeXBlc1tfal07XG4gICAgICAgICAgaWYgKGludmVydGVkQ29udGVudFR5cGVzW19jdF0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBfbGVuMiA9IGludmVydGVkQ29udGVudFR5cGVzW19jdF0ubGVuZ3RoOyBrIDwgX2xlbjI7IGsrKykge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XVtrXTtcbiAgICAgICAgICAgICAgaWYgKGRvYy5yZWxzVHlwZXNbdGFyZ2V0XSAmJiBbXCJodHRwOi8vcHVybC5vY2xjLm9yZy9vb3htbC9vZmZpY2VEb2N1bWVudC9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50XCIsIFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiXS5pbmRleE9mKGRvYy5yZWxzVHlwZXNbdGFyZ2V0XSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnRDYW5kaWRhdGUgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihfY3QpICE9PSAtMSB8fCBfY3QgPT09IGZpbGV0eXBlcy5wcHR4WzBdKSB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHRUYXJnZXQgfHwgKGRvYy50ZXh0VGFyZ2V0ID0gdGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb2MudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmdENhbmRpZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBmdENhbmRpZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ0Q2FuZGlkYXRlO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBDb21tb24oKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInQiLCJfdG9QcmltaXRpdmUiLCJyIiwiZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsIndyYXBwZXIiLCJyZXF1aXJlIiwiZmlsZXR5cGVzIiwiX3JlcXVpcmUiLCJzZXR0aW5nc0NvbnRlbnRUeXBlIiwiY29yZUNvbnRlbnRUeXBlIiwiYXBwQ29udGVudFR5cGUiLCJjdXN0b21Db250ZW50VHlwZSIsImNvbW1vbkNvbnRlbnRUeXBlcyIsIkNvbW1vbiIsIm5hbWUiLCJ2YWx1ZSIsImdldEZpbGVUeXBlIiwiX3JlZiIsImRvYyIsImludmVydGVkQ29udGVudFR5cGVzIiwiaiIsImxlbjIiLCJjdCIsIkFycmF5IiwicHVzaCIsImFwcGx5IiwidGFyZ2V0cyIsImtleXMiLCJmdENhbmRpZGF0ZSIsImxlbiIsImNvbnRlbnRUeXBlcyIsIl9qIiwiX2xlbiIsIl9jdCIsImsiLCJfbGVuMiIsInJlbHNUeXBlcyIsImluZGV4T2YiLCJtYWluIiwicHB0eCIsInRleHRUYXJnZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!********************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(ssr)/./node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), getLeft = _require.getLeft, getRight = _require.getRight;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\"), getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), getUnmatchedLoopException = _require3.getUnmatchedLoopException, getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag, getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n    switch(part.location){\n        case \"start\":\n            return 1;\n        case \"end\":\n            return -1;\n    }\n}\nfunction match(start, end) {\n    return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n    var i = 0;\n    var errors = [];\n    while(i < traits.length){\n        var part = traits[i].part;\n        if (part.location === \"end\") {\n            if (i === 0) {\n                traits.splice(0, 1);\n                errors.push(getUnmatchedLoopException(part));\n                return {\n                    traits: traits,\n                    errors: errors\n                };\n            }\n            var endIndex = i;\n            var startIndex = i - 1;\n            var offseter = 1;\n            if (match(traits[startIndex], traits[endIndex])) {\n                traits.splice(endIndex, 1);\n                traits.splice(startIndex, 1);\n                return {\n                    errors: errors,\n                    traits: traits\n                };\n            }\n            while(offseter < 50){\n                var startCandidate = traits[startIndex - offseter];\n                var endCandidate = traits[endIndex + offseter];\n                if (match(startCandidate, traits[endIndex])) {\n                    traits.splice(endIndex, 1);\n                    traits.splice(startIndex - offseter, 1);\n                    return {\n                        errors: errors,\n                        traits: traits\n                    };\n                }\n                if (match(traits[startIndex], endCandidate)) {\n                    traits.splice(endIndex + offseter, 1);\n                    traits.splice(startIndex, 1);\n                    return {\n                        errors: errors,\n                        traits: traits\n                    };\n                }\n                offseter++;\n            }\n            errors.push(getClosingTagNotMatchOpeningTag({\n                tags: [\n                    traits[startIndex].part,\n                    traits[endIndex].part\n                ]\n            }));\n            traits.splice(endIndex, 1);\n            traits.splice(startIndex, 1);\n            return {\n                traits: traits,\n                errors: errors\n            };\n        }\n        i++;\n    }\n    traits.forEach(function(_ref) {\n        var part = _ref.part;\n        errors.push(getUnmatchedLoopException(part));\n    });\n    return {\n        traits: [],\n        errors: errors\n    };\n}\nfunction getPairs(traits) {\n    var levelTraits = {};\n    var errors = [];\n    var pairs = [];\n    var transformedTraits = [];\n    for(var i = 0; i < traits.length; i++){\n        transformedTraits.push(traits[i]);\n    }\n    while(transformedTraits.length > 0){\n        var result = transformer(transformedTraits);\n        errors = errors.concat(result.errors);\n        transformedTraits = result.traits;\n    }\n    // Stryker disable all : because this check makes the function return quicker\n    if (errors.length > 0) {\n        return {\n            pairs: pairs,\n            errors: errors\n        };\n    }\n    // Stryker restore all\n    var countOpen = 0;\n    for(var _i = 0; _i < traits.length; _i++){\n        var currentTrait = traits[_i];\n        var part = currentTrait.part;\n        var change = getOpenCountChange(part);\n        countOpen += change;\n        if (change === 1) {\n            levelTraits[countOpen] = currentTrait;\n        } else {\n            var startTrait = levelTraits[countOpen + 1];\n            if (countOpen === 0) {\n                pairs = pairs.concat([\n                    [\n                        startTrait,\n                        currentTrait\n                    ]\n                ]);\n            }\n        }\n        countOpen = countOpen >= 0 ? countOpen : 0;\n    }\n    return {\n        pairs: pairs,\n        errors: errors\n    };\n}\nvar ExpandPairTrait = /*#__PURE__*/ function() {\n    function ExpandPairTrait() {\n        _classCallCheck(this, ExpandPairTrait);\n        this.name = \"ExpandPairTrait\";\n    }\n    return _createClass(ExpandPairTrait, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                this.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);\n                return options;\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, _ref2) {\n                var _this = this;\n                var getTraits = _ref2.getTraits, _postparse = _ref2.postparse, fileType = _ref2.fileType;\n                var traits = getTraits(traitName, postparsed);\n                traits = traits.map(function(trait) {\n                    return trait || [];\n                });\n                traits = mergeSort(traits);\n                var _getPairs = getPairs(traits), pairs = _getPairs.pairs, errors = _getPairs.errors;\n                var lastRight = 0;\n                var lastPair = null;\n                var expandedPairs = pairs.map(function(pair) {\n                    var expandTo = pair[0].part.expandTo;\n                    if (expandTo === \"auto\" && fileType !== \"text\") {\n                        var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n                        if (result.error) {\n                            errors.push(result.error);\n                        }\n                        expandTo = result.value;\n                    }\n                    if (!expandTo || fileType === \"text\") {\n                        var _left = pair[0].offset;\n                        var _right = pair[1].offset;\n                        if (_left < lastRight) {\n                            errors.push(getUnbalancedLoopException(pair, lastPair));\n                        }\n                        lastPair = pair;\n                        lastRight = _right;\n                        return [\n                            _left,\n                            _right\n                        ];\n                    }\n                    var left, right;\n                    try {\n                        left = getLeft(postparsed, expandTo, pair[0].offset);\n                    } catch (e) {\n                        errors.push(e);\n                    }\n                    try {\n                        right = getRight(postparsed, expandTo, pair[1].offset);\n                    } catch (e) {\n                        errors.push(e);\n                    }\n                    if (left < lastRight) {\n                        errors.push(getUnbalancedLoopException(pair, lastPair));\n                    }\n                    lastRight = right;\n                    lastPair = pair;\n                    return [\n                        left,\n                        right\n                    ];\n                });\n                // Stryker disable all : because this check makes the function return quicker\n                if (errors.length > 0) {\n                    return {\n                        postparsed: postparsed,\n                        errors: errors\n                    };\n                }\n                // Stryker restore all\n                var currentPairIndex = 0;\n                var innerParts;\n                var newParsed = postparsed.reduce(function(newParsed, part, i) {\n                    var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n                    var pair = pairs[currentPairIndex];\n                    var expandedPair = expandedPairs[currentPairIndex];\n                    if (!inPair) {\n                        newParsed.push(part);\n                        return newParsed;\n                    }\n                    if (expandedPair[0] === i) {\n                        innerParts = [];\n                    }\n                    if (pair[0].offset !== i && pair[1].offset !== i) {\n                        innerParts.push(part);\n                    }\n                    if (expandedPair[1] === i) {\n                        var basePart = postparsed[pair[0].offset];\n                        basePart.subparsed = _postparse(innerParts, {\n                            basePart: basePart\n                        });\n                        basePart.endLindex = pair[1].part.lIndex;\n                        delete basePart.location;\n                        delete basePart.expandTo;\n                        newParsed.push(basePart);\n                        currentPairIndex++;\n                    }\n                    return newParsed;\n                }, []);\n                return {\n                    postparsed: newParsed,\n                    errors: errors\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new ExpandPairTrait());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFVLGVBQWVOLFdBQVdPLEdBQUcsR0FBR1A7SUFBYTtBQUFFO0FBQzVVLFNBQVNRLGFBQWFmLFdBQVcsRUFBRWdCLFVBQVUsRUFBRUMsV0FBVztJQUFJLElBQUlELFlBQVlkLGtCQUFrQkYsWUFBWUgsU0FBUyxFQUFFbUI7SUFBYSxJQUFJQyxhQUFhZixrQkFBa0JGLGFBQWFpQjtJQUFjTixPQUFPQyxjQUFjLENBQUNaLGFBQWEsYUFBYTtR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L3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvZXhwYW5kLXBhaXItdHJhaXQuanM/MmY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdE5hbWUgPSBcImV4cGFuZFBhaXJcIjtcbnZhciBtZXJnZVNvcnQgPSByZXF1aXJlKFwiLi4vbWVyZ2Utc29ydC5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0O1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uL3RyYWl0cy5qc1wiKSxcbiAgZ2V0RXhwYW5kVG9EZWZhdWx0ID0gX3JlcXVpcmUyLmdldEV4cGFuZFRvRGVmYXVsdDtcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uID0gX3JlcXVpcmUzLmdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24sXG4gIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcgPSBfcmVxdWlyZTMuZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyxcbiAgZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb247XG5mdW5jdGlvbiBnZXRPcGVuQ291bnRDaGFuZ2UocGFydCkge1xuICBzd2l0Y2ggKHBhcnQubG9jYXRpb24pIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIHJldHVybiAtMTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2goc3RhcnQsIGVuZCkge1xuICByZXR1cm4gc3RhcnQgIT0gbnVsbCAmJiBlbmQgIT0gbnVsbCAmJiAoc3RhcnQucGFydC5sb2NhdGlvbiA9PT0gXCJzdGFydFwiICYmIGVuZC5wYXJ0LmxvY2F0aW9uID09PSBcImVuZFwiICYmIHN0YXJ0LnBhcnQudmFsdWUgPT09IGVuZC5wYXJ0LnZhbHVlIHx8IGVuZC5wYXJ0LnZhbHVlID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKHRyYWl0cykge1xuICB2YXIgaSA9IDA7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgd2hpbGUgKGkgPCB0cmFpdHMubGVuZ3RoKSB7XG4gICAgdmFyIHBhcnQgPSB0cmFpdHNbaV0ucGFydDtcbiAgICBpZiAocGFydC5sb2NhdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdHJhaXRzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhaXRzOiB0cmFpdHMsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRJbmRleCA9IGk7XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGkgLSAxO1xuICAgICAgdmFyIG9mZnNldGVyID0gMTtcbiAgICAgIGlmIChtYXRjaCh0cmFpdHNbc3RhcnRJbmRleF0sIHRyYWl0c1tlbmRJbmRleF0pKSB7XG4gICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB3aGlsZSAob2Zmc2V0ZXIgPCA1MCkge1xuICAgICAgICB2YXIgc3RhcnRDYW5kaWRhdGUgPSB0cmFpdHNbc3RhcnRJbmRleCAtIG9mZnNldGVyXTtcbiAgICAgICAgdmFyIGVuZENhbmRpZGF0ZSA9IHRyYWl0c1tlbmRJbmRleCArIG9mZnNldGVyXTtcbiAgICAgICAgaWYgKG1hdGNoKHN0YXJ0Q2FuZGlkYXRlLCB0cmFpdHNbZW5kSW5kZXhdKSkge1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCAtIG9mZnNldGVyLCAxKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB0cmFpdHM6IHRyYWl0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKHRyYWl0c1tzdGFydEluZGV4XSwgZW5kQ2FuZGlkYXRlKSkge1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXggKyBvZmZzZXRlciwgMSk7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB0cmFpdHM6IHRyYWl0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ZXIrKztcbiAgICAgIH1cbiAgICAgIGVycm9ycy5wdXNoKGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcoe1xuICAgICAgICB0YWdzOiBbdHJhaXRzW3N0YXJ0SW5kZXhdLnBhcnQsIHRyYWl0c1tlbmRJbmRleF0ucGFydF1cbiAgICAgIH0pKTtcbiAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWl0czogdHJhaXRzLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHRyYWl0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHBhcnQgPSBfcmVmLnBhcnQ7XG4gICAgZXJyb3JzLnB1c2goZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRyYWl0czogW10sXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhaXJzKHRyYWl0cykge1xuICB2YXIgbGV2ZWxUcmFpdHMgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgdmFyIHRyYW5zZm9ybWVkVHJhaXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdHJhbnNmb3JtZWRUcmFpdHMucHVzaCh0cmFpdHNbaV0pO1xuICB9XG4gIHdoaWxlICh0cmFuc2Zvcm1lZFRyYWl0cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybWVyKHRyYW5zZm9ybWVkVHJhaXRzKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHJlc3VsdC5lcnJvcnMpO1xuICAgIHRyYW5zZm9ybWVkVHJhaXRzID0gcmVzdWx0LnRyYWl0cztcbiAgfVxuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYWlyczogcGFpcnMsXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICB2YXIgY291bnRPcGVuID0gMDtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWl0cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgY3VycmVudFRyYWl0ID0gdHJhaXRzW19pXTtcbiAgICB2YXIgcGFydCA9IGN1cnJlbnRUcmFpdC5wYXJ0O1xuICAgIHZhciBjaGFuZ2UgPSBnZXRPcGVuQ291bnRDaGFuZ2UocGFydCk7XG4gICAgY291bnRPcGVuICs9IGNoYW5nZTtcbiAgICBpZiAoY2hhbmdlID09PSAxKSB7XG4gICAgICBsZXZlbFRyYWl0c1tjb3VudE9wZW5dID0gY3VycmVudFRyYWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnRUcmFpdCA9IGxldmVsVHJhaXRzW2NvdW50T3BlbiArIDFdO1xuICAgICAgaWYgKGNvdW50T3BlbiA9PT0gMCkge1xuICAgICAgICBwYWlycyA9IHBhaXJzLmNvbmNhdChbW3N0YXJ0VHJhaXQsIGN1cnJlbnRUcmFpdF1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY291bnRPcGVuID0gY291bnRPcGVuID49IDAgPyBjb3VudE9wZW4gOiAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGFpcnM6IHBhaXJzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG52YXIgRXhwYW5kUGFpclRyYWl0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwYW5kUGFpclRyYWl0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBhbmRQYWlyVHJhaXQpO1xuICAgIHRoaXMubmFtZSA9IFwiRXhwYW5kUGFpclRyYWl0XCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFeHBhbmRQYWlyVHJhaXQsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5leHBhbmRUYWdzID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5leHBhbmRUYWdzLmNvbmNhdChkb2N4dGVtcGxhdGVyLm9wdGlvbnMucGFyYWdyYXBoTG9vcCA/IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWcub25QYXJhZ3JhcGhMb29wIDogW10pO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgX3JlZjIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZ2V0VHJhaXRzID0gX3JlZjIuZ2V0VHJhaXRzLFxuICAgICAgICBfcG9zdHBhcnNlID0gX3JlZjIucG9zdHBhcnNlLFxuICAgICAgICBmaWxlVHlwZSA9IF9yZWYyLmZpbGVUeXBlO1xuICAgICAgdmFyIHRyYWl0cyA9IGdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQpO1xuICAgICAgdHJhaXRzID0gdHJhaXRzLm1hcChmdW5jdGlvbiAodHJhaXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWl0IHx8IFtdO1xuICAgICAgfSk7XG4gICAgICB0cmFpdHMgPSBtZXJnZVNvcnQodHJhaXRzKTtcbiAgICAgIHZhciBfZ2V0UGFpcnMgPSBnZXRQYWlycyh0cmFpdHMpLFxuICAgICAgICBwYWlycyA9IF9nZXRQYWlycy5wYWlycyxcbiAgICAgICAgZXJyb3JzID0gX2dldFBhaXJzLmVycm9ycztcbiAgICAgIHZhciBsYXN0UmlnaHQgPSAwO1xuICAgICAgdmFyIGxhc3RQYWlyID0gbnVsbDtcbiAgICAgIHZhciBleHBhbmRlZFBhaXJzID0gcGFpcnMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBleHBhbmRUbyA9IHBhaXJbMF0ucGFydC5leHBhbmRUbztcbiAgICAgICAgaWYgKGV4cGFuZFRvID09PSBcImF1dG9cIiAmJiBmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0RXhwYW5kVG9EZWZhdWx0KHBvc3RwYXJzZWQsIHBhaXIsIF90aGlzLmV4cGFuZFRhZ3MpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cGFuZFRvID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwYW5kVG8gfHwgZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdmFyIF9sZWZ0ID0gcGFpclswXS5vZmZzZXQ7XG4gICAgICAgICAgdmFyIF9yaWdodCA9IHBhaXJbMV0ub2Zmc2V0O1xuICAgICAgICAgIGlmIChfbGVmdCA8IGxhc3RSaWdodCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFBhaXIgPSBwYWlyO1xuICAgICAgICAgIGxhc3RSaWdodCA9IF9yaWdodDtcbiAgICAgICAgICByZXR1cm4gW19sZWZ0LCBfcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByaWdodCA9IGdldFJpZ2h0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IGxhc3RSaWdodCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIGxhc3RQYWlyID0gcGFpcjtcbiAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBjaGVjayBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuIHF1aWNrZXJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuICAgICAgdmFyIGN1cnJlbnRQYWlySW5kZXggPSAwO1xuICAgICAgdmFyIGlubmVyUGFydHM7XG4gICAgICB2YXIgbmV3UGFyc2VkID0gcG9zdHBhcnNlZC5yZWR1Y2UoZnVuY3Rpb24gKG5ld1BhcnNlZCwgcGFydCwgaSkge1xuICAgICAgICB2YXIgaW5QYWlyID0gY3VycmVudFBhaXJJbmRleCA8IHBhaXJzLmxlbmd0aCAmJiBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdWzBdIDw9IGkgJiYgaSA8PSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdWzFdO1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICB2YXIgZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgaWYgKCFpblBhaXIpIHtcbiAgICAgICAgICBuZXdQYXJzZWQucHVzaChwYXJ0KTtcbiAgICAgICAgICByZXR1cm4gbmV3UGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMF0gPT09IGkpIHtcbiAgICAgICAgICBpbm5lclBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhaXJbMF0ub2Zmc2V0ICE9PSBpICYmIHBhaXJbMV0ub2Zmc2V0ICE9PSBpKSB7XG4gICAgICAgICAgaW5uZXJQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMV0gPT09IGkpIHtcbiAgICAgICAgICB2YXIgYmFzZVBhcnQgPSBwb3N0cGFyc2VkW3BhaXJbMF0ub2Zmc2V0XTtcbiAgICAgICAgICBiYXNlUGFydC5zdWJwYXJzZWQgPSBfcG9zdHBhcnNlKGlubmVyUGFydHMsIHtcbiAgICAgICAgICAgIGJhc2VQYXJ0OiBiYXNlUGFydFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhc2VQYXJ0LmVuZExpbmRleCA9IHBhaXJbMV0ucGFydC5sSW5kZXg7XG4gICAgICAgICAgZGVsZXRlIGJhc2VQYXJ0LmxvY2F0aW9uO1xuICAgICAgICAgIGRlbGV0ZSBiYXNlUGFydC5leHBhbmRUbztcbiAgICAgICAgICBuZXdQYXJzZWQucHVzaChiYXNlUGFydCk7XG4gICAgICAgICAgY3VycmVudFBhaXJJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0cGFyc2VkOiBuZXdQYXJzZWQsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBFeHBhbmRQYWlyVHJhaXQoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInQiLCJfdG9QcmltaXRpdmUiLCJyIiwiZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsInRyYWl0TmFtZSIsIm1lcmdlU29ydCIsInJlcXVpcmUiLCJfcmVxdWlyZSIsImdldExlZnQiLCJnZXRSaWdodCIsIndyYXBwZXIiLCJfcmVxdWlyZTIiLCJnZXRFeHBhbmRUb0RlZmF1bHQiLCJfcmVxdWlyZTMiLCJnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uIiwiZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyIsImdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uIiwiZ2V0T3BlbkNvdW50Q2hhbmdlIiwicGFydCIsImxvY2F0aW9uIiwibWF0Y2giLCJzdGFydCIsImVuZCIsInZhbHVlIiwidHJhbnNmb3JtZXIiLCJ0cmFpdHMiLCJlcnJvcnMiLCJzcGxpY2UiLCJwdXNoIiwiZW5kSW5kZXgiLCJzdGFydEluZGV4Iiwib2Zmc2V0ZXIiLCJzdGFydENhbmRpZGF0ZSIsImVuZENhbmRpZGF0ZSIsInRhZ3MiLCJmb3JFYWNoIiwiX3JlZiIsImdldFBhaXJzIiwibGV2ZWxUcmFpdHMiLCJwYWlycyIsInRyYW5zZm9ybWVkVHJhaXRzIiwicmVzdWx0IiwiY29uY2F0IiwiY291bnRPcGVuIiwiX2kiLCJjdXJyZW50VHJhaXQiLCJjaGFuZ2UiLCJzdGFydFRyYWl0IiwiRXhwYW5kUGFpclRyYWl0IiwibmFtZSIsIm9wdGlvbnNUcmFuc2Zvcm1lciIsIm9wdGlvbnMiLCJkb2N4dGVtcGxhdGVyIiwiZXhwYW5kVGFncyIsImZpbGVUeXBlQ29uZmlnIiwicGFyYWdyYXBoTG9vcCIsIm9uUGFyYWdyYXBoTG9vcCIsInBvc3RwYXJzZSIsInBvc3RwYXJzZWQiLCJfcmVmMiIsIl90aGlzIiwiZ2V0VHJhaXRzIiwiX3Bvc3RwYXJzZSIsImZpbGVUeXBlIiwibWFwIiwidHJhaXQiLCJfZ2V0UGFpcnMiLCJsYXN0UmlnaHQiLCJsYXN0UGFpciIsImV4cGFuZGVkUGFpcnMiLCJwYWlyIiwiZXhwYW5kVG8iLCJlcnJvciIsIl9sZWZ0Iiwib2Zmc2V0IiwiX3JpZ2h0IiwibGVmdCIsInJpZ2h0IiwiY3VycmVudFBhaXJJbmRleCIsImlubmVyUGFydHMiLCJuZXdQYXJzZWQiLCJyZWR1Y2UiLCJpblBhaXIiLCJleHBhbmRlZFBhaXIiLCJiYXNlUGFydCIsInN1YnBhcnNlZCIsImVuZExpbmRleCIsImxJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/loop.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/loop.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), chunkBy = _require.chunkBy, last = _require.last, isParagraphStart = _require.isParagraphStart, isModule = _require.isModule, isParagraphEnd = _require.isParagraphEnd, isContent = _require.isContent, startsWith = _require.startsWith, isTagEnd = _require.isTagEnd, isTagStart = _require.isTagStart, getSingleAttribute = _require.getSingleAttribute, setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n    return parts.some(function(part) {\n        return isContent(part);\n    });\n}\nfunction getFirstMeaningFulPart(parsed) {\n    for(var i = 0, len = parsed.length; i < len; i++){\n        if (parsed[i].type !== \"content\") {\n            return parsed[i];\n        }\n    }\n    return null;\n}\nfunction isInsideParagraphLoop(part) {\n    var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n    return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n    return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n    return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n    return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n    var j = subRendered.parts.length - 1;\n    if (subRendered.parts[j] === \"</w:p>\") {\n        subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n    } else {\n        subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n    }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n    subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n    return parts.some(function(part) {\n        return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n    });\n}\nfunction isNextPage(parts) {\n    return parts.some(function(part) {\n        return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n    });\n}\nfunction addSectionBefore(parts, sect) {\n    return [\n        \"<w:p><w:pPr>\".concat(sect.map(function(_ref) {\n            var value = _ref.value;\n            return value;\n        }).join(\"\"), \"</w:pPr></w:p>\")\n    ].concat(parts);\n}\nfunction addContinuousType(parts) {\n    var stop = false;\n    var inSectPr = false;\n    return parts.reduce(function(result, part) {\n        if (stop === false && startsWith(part, \"<w:sectPr\")) {\n            inSectPr = true;\n        }\n        if (inSectPr) {\n            if (startsWith(part, \"<w:type\")) {\n                stop = true;\n            }\n            if (stop === false && startsWith(part, \"</w:sectPr\")) {\n                result.push('<w:type w:val=\"continuous\"/>');\n            }\n        }\n        result.push(part);\n        return result;\n    }, []);\n}\nfunction dropHeaderFooterRefs(parts) {\n    return parts.filter(function(text) {\n        return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n    });\n}\nfunction hasPageBreak(chunk) {\n    return chunk.some(function(part) {\n        return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n    });\n}\nfunction hasImage(chunk) {\n    return chunk.some(function(_ref2) {\n        var tag = _ref2.tag;\n        return tag === \"w:drawing\";\n    });\n}\nfunction getSectPr(chunks) {\n    var collectSectPr = false;\n    var sectPrs = [];\n    chunks.forEach(function(part) {\n        if (isTagStart(\"w:sectPr\", part)) {\n            sectPrs.push([]);\n            collectSectPr = true;\n        }\n        if (collectSectPr) {\n            sectPrs[sectPrs.length - 1].push(part);\n        }\n        if (isTagEnd(\"w:sectPr\", part)) {\n            collectSectPr = false;\n        }\n    });\n    return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n    var collectSectPr = false;\n    var sectPrCount = 0;\n    chunks.forEach(function(part) {\n        if (isTagStart(\"w:sectPr\", part)) {\n            collectSectPr = true;\n        }\n        if (collectSectPr) {\n            if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n                sectPrCount++;\n                collectSectPr = false;\n            }\n        }\n        if (isTagEnd(\"w:sectPr\", part)) {\n            collectSectPr = false;\n        }\n    });\n    return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n    var sectPr = [];\n    var inSectPr = false;\n    for(var i = parsed.length - 1; i >= 0; i--){\n        var part = parsed[i];\n        if (isTagEnd(\"w:sectPr\", part)) {\n            inSectPr = true;\n        }\n        if (isTagStart(\"w:sectPr\", part)) {\n            sectPr.unshift(part.value);\n            inSectPr = false;\n        }\n        if (inSectPr) {\n            sectPr.unshift(part.value);\n        }\n        if (isParagraphStart(part)) {\n            if (sectPr.length > 0) {\n                return sectPr.join(\"\");\n            }\n            break;\n        }\n    }\n    return \"\";\n}\nvar LoopModule = /*#__PURE__*/ function() {\n    function LoopModule() {\n        _classCallCheck(this, LoopModule);\n        this.name = \"LoopModule\";\n        this.inXfrm = false;\n        this.totalSectPr = 0;\n        this.prefix = {\n            start: \"#\",\n            end: \"/\",\n            dash: /^-([^\\s]+)\\s(.+)/,\n            inverted: \"^\"\n        };\n    }\n    return _createClass(LoopModule, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(opts, docxtemplater) {\n                this.docxtemplater = docxtemplater;\n                return opts;\n            }\n        },\n        {\n            key: \"preparse\",\n            value: function preparse(parsed, _ref3) {\n                var contentType = _ref3.contentType;\n                if (filetypes.main.indexOf(contentType) !== -1) {\n                    this.sects = getSectPr(parsed);\n                }\n            }\n        },\n        {\n            key: \"matchers\",\n            value: function matchers() {\n                var module1 = moduleName;\n                return [\n                    [\n                        this.prefix.start,\n                        module1,\n                        {\n                            expandTo: \"auto\",\n                            location: \"start\",\n                            inverted: false\n                        }\n                    ],\n                    [\n                        this.prefix.inverted,\n                        module1,\n                        {\n                            expandTo: \"auto\",\n                            location: \"start\",\n                            inverted: true\n                        }\n                    ],\n                    [\n                        this.prefix.end,\n                        module1,\n                        {\n                            location: \"end\"\n                        }\n                    ],\n                    [\n                        this.prefix.dash,\n                        module1,\n                        function(_ref4) {\n                            var _ref5 = _slicedToArray(_ref4, 3), expandTo = _ref5[1], value = _ref5[2];\n                            return {\n                                location: \"start\",\n                                inverted: false,\n                                expandTo: expandTo,\n                                value: value\n                            };\n                        }\n                    ]\n                ];\n            }\n        },\n        {\n            key: \"getTraits\",\n            value: function getTraits(traitName, parsed) {\n                // Stryker disable all : because getTraits should disappear in v4\n                if (traitName !== \"expandPair\") {\n                    return;\n                }\n                // Stryker restore all\n                return parsed.reduce(function(tags, part, offset) {\n                    if (isModule(part, moduleName) && part.subparsed == null) {\n                        tags.push({\n                            part: part,\n                            offset: offset\n                        });\n                    }\n                    return tags;\n                }, []);\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(parsed, _ref6) {\n                var basePart = _ref6.basePart;\n                if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n                    basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n                    this.totalSectPr += basePart.sectPrCount;\n                    var sects = this.sects;\n                    sects.some(function(sect, index) {\n                        if (basePart.lIndex < sect[0].lIndex) {\n                            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n                                basePart.addContinuousType = true;\n                            }\n                            return true;\n                        }\n                        if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n                            if (isNextPage(sects[index])) {\n                                basePart.addNextPage = {\n                                    index: index\n                                };\n                            }\n                            return true;\n                        }\n                    });\n                    basePart.lastParagrapSectPr = getLastSectPr(parsed);\n                }\n                if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n                    return parsed;\n                }\n                basePart.paragraphLoop = true;\n                var level = 0;\n                var chunks = chunkBy(parsed, function(p) {\n                    if (isParagraphStart(p)) {\n                        level++;\n                        if (level === 1) {\n                            return \"start\";\n                        }\n                    }\n                    if (isParagraphEnd(p)) {\n                        level--;\n                        if (level === 0) {\n                            return \"end\";\n                        }\n                    }\n                    return null;\n                });\n                var firstChunk = chunks[0];\n                var lastChunk = last(chunks);\n                var firstOffset = getOffset(firstChunk);\n                var lastOffset = getOffset(lastChunk);\n                basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n                basePart.hasPageBreak = hasPageBreak(lastChunk);\n                if (hasImage(firstChunk)) {\n                    firstOffset = 0;\n                }\n                if (hasImage(lastChunk)) {\n                    lastOffset = 0;\n                }\n                return parsed.slice(firstOffset, parsed.length - lastOffset);\n            }\n        },\n        {\n            key: \"resolve\",\n            value: function resolve(part, options) {\n                if (!isModule(part, moduleName)) {\n                    return null;\n                }\n                var sm = options.scopeManager;\n                var promisedValue = sm.getValueAsync(part.value, {\n                    part: part\n                });\n                var promises = [];\n                function loopOver(scope, i, length) {\n                    var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n                    promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n                        compiled: part.subparsed,\n                        tags: {},\n                        scopeManager: scopeManager\n                    })));\n                }\n                var errorList = [];\n                return promisedValue.then(function(values) {\n                    return new Promise(function(resolve) {\n                        if (values instanceof Array) {\n                            Promise.all(values).then(resolve);\n                        } else {\n                            resolve(values);\n                        }\n                    }).then(function(values) {\n                        sm.loopOverValue(values, loopOver, part.inverted);\n                        return Promise.all(promises).then(function(r) {\n                            return r.map(function(_ref7) {\n                                var resolved = _ref7.resolved, errors = _ref7.errors;\n                                errorList.push.apply(errorList, _toConsumableArray(errors));\n                                return resolved;\n                            });\n                        }).then(function(value) {\n                            if (errorList.length > 0) {\n                                throw errorList;\n                            }\n                            return value;\n                        });\n                    });\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, options) {\n                if (part.tag === \"p:xfrm\") {\n                    this.inXfrm = part.position === \"start\";\n                }\n                if (part.tag === \"a:ext\" && this.inXfrm) {\n                    this.lastExt = part;\n                    return part;\n                }\n                if (!isModule(part, moduleName)) {\n                    return null;\n                }\n                var totalValue = [];\n                var errors = [];\n                var heightOffset = 0;\n                var self = this;\n                var firstTag = part.subparsed[0];\n                var tagHeight = 0;\n                if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n                    tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n                }\n                heightOffset -= tagHeight;\n                var a16RowIdOffset = 0;\n                var insideParagraphLoop = isInsideParagraphLoop(part);\n                // eslint-disable-next-line complexity\n                function loopOver(scope, i, length) {\n                    heightOffset += tagHeight;\n                    var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n                    part.subparsed.forEach(function(pp) {\n                        if (isTagStart(\"a16:rowId\", pp)) {\n                            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n                            a16RowIdOffset = 1;\n                            pp.value = setSingleAttribute(pp.value, \"val\", val);\n                        }\n                    });\n                    var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n                        compiled: part.subparsed,\n                        tags: {},\n                        scopeManager: scopeManager\n                    }));\n                    if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n                        addPageBreakAtEnd(subRendered);\n                    }\n                    var isNotFirst = scopeManager.scopePathItem.some(function(i) {\n                        return i !== 0;\n                    });\n                    if (isNotFirst) {\n                        if (part.sectPrCount === 1) {\n                            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n                        }\n                        if (part.addContinuousType) {\n                            subRendered.parts = addContinuousType(subRendered.parts);\n                        }\n                    } else if (part.addNextPage) {\n                        subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n                    }\n                    if (part.addNextPage) {\n                        addPageBreakAtEnd(subRendered);\n                    }\n                    if (part.hasPageBreakBeginning && insideParagraphLoop) {\n                        addPageBreakAtBeginning(subRendered);\n                    }\n                    for(var _i = 0, len = subRendered.parts.length; _i < len; _i++){\n                        totalValue.push(subRendered.parts[_i]);\n                    }\n                    Array.prototype.push.apply(errors, subRendered.errors);\n                }\n                var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n                    part: part\n                });\n                // if the loop is showing empty content\n                if (result === false) {\n                    if (part.lastParagrapSectPr) {\n                        if (part.paragraphLoop) {\n                            return {\n                                value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n                            };\n                        }\n                        return {\n                            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n                        };\n                    }\n                    return {\n                        value: getPageBreakIfApplies(part) || \"\",\n                        errors: errors\n                    };\n                }\n                if (heightOffset !== 0) {\n                    var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n                    this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n                }\n                return {\n                    value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n                        basePart: part\n                    })),\n                    errors: errors\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new LoopModule());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssbUJBQW1CQyxHQUFHO0lBQUksT0FBT0MsbUJBQW1CRCxRQUFRRSxpQkFBaUJGLFFBQVFHLDRCQUE0QkgsUUFBUUk7QUFBc0I7QUFDeEosU0FBU0E7SUFBdUIsTUFBTSxJQUFJQyxVQUFVO0FBQXlJO0FBQzdMLFNBQVNILGlCQUFpQkksSUFBSTtJQUFJLElBQUksT0FBT1gsV0FBVyxlQUFlVyxJQUFJLENBQUNYLE9BQU9DLFFBQVEsQ0FBQyxJQUFJLFFBQVFVLElBQUksQ0FBQyxhQUFhLElBQUksTUFBTSxPQUFPQyxNQUFNQyxJQUFJLENBQUNGO0FBQU87QUFDN0osU0FBU0wsbUJBQW1CRCxHQUFHO0lBQUksSUFBSU8sTUFBTUUsT0FBTyxDQUFDVCxNQUFNLE9BQU9VLGtCQUFrQlY7QUFBTTtBQUMxRixTQUFTVyxRQUFRQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNKO0lBQUksSUFBSUcsT0FBT0UscUJBQXFCLEVBQUU7UUFBRSxJQUFJdkIsSUFBSXFCLE9BQU9FLHFCQUFxQixDQUFDTDtRQUFJQyxLQUFNbkIsQ0FBQUEsSUFBSUEsRUFBRXdCLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQ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RCxRQUFRLEVBQUU7b0JBQzlFcEQsTUFBTUE7Z0JBQ1I7Z0JBQ0EsdUNBQXVDO2dCQUN2QyxJQUFJZ0MsV0FBVyxPQUFPO29CQUNwQixJQUFJaEMsS0FBSzhFLGtCQUFrQixFQUFFO3dCQUMzQixJQUFJOUUsS0FBSytFLGFBQWEsRUFBRTs0QkFDdEIsT0FBTztnQ0FDTHhJLE9BQU8sZUFBZWlGLE1BQU0sQ0FBQ3hCLEtBQUs4RSxrQkFBa0IsRUFBRTs0QkFDeEQ7d0JBQ0Y7d0JBQ0EsT0FBTzs0QkFDTHZJLE9BQU8saUNBQWlDaUYsTUFBTSxDQUFDeEIsS0FBSzhFLGtCQUFrQixFQUFFO3dCQUMxRTtvQkFDRjtvQkFDQSxPQUFPO3dCQUNMdkksT0FBT2lFLHNCQUFzQlIsU0FBUzt3QkFDdEMwRyxRQUFRQTtvQkFDVjtnQkFDRjtnQkFDQSxJQUFJSyxpQkFBaUIsR0FBRztvQkFDdEIsSUFBSVcsS0FBSyxDQUFDbEksbUJBQW1CLElBQUksQ0FBQ3FILE9BQU8sQ0FBQ3RLLEtBQUssRUFBRTtvQkFDakQsSUFBSSxDQUFDc0ssT0FBTyxDQUFDdEssS0FBSyxHQUFHa0QsbUJBQW1CLElBQUksQ0FBQ29ILE9BQU8sQ0FBQ3RLLEtBQUssRUFBRSxNQUFNbUwsS0FBS1g7Z0JBQ3pFO2dCQUNBLE9BQU87b0JBQ0x4SyxPQUFPaUosUUFBUW1DLGFBQWEsQ0FBQ2IsWUFBWWpMLGNBQWNBLGNBQWMsQ0FBQyxHQUFHMkosVUFBVSxDQUFDLEdBQUc7d0JBQ3JGZixVQUFVekU7b0JBQ1o7b0JBQ0EwRyxRQUFRQTtnQkFDVjtZQUNGO1FBQ0Y7S0FBRTtBQUNKO0FBQ0E1QyxPQUFPOEQsT0FBTyxHQUFHO0lBQ2YsT0FBT2pJLFFBQVEsSUFBSWtEO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9sb29wLmpzP2E5ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBjaHVua0J5ID0gX3JlcXVpcmUuY2h1bmtCeSxcbiAgbGFzdCA9IF9yZXF1aXJlLmxhc3QsXG4gIGlzUGFyYWdyYXBoU3RhcnQgPSBfcmVxdWlyZS5pc1BhcmFncmFwaFN0YXJ0LFxuICBpc01vZHVsZSA9IF9yZXF1aXJlLmlzTW9kdWxlLFxuICBpc1BhcmFncmFwaEVuZCA9IF9yZXF1aXJlLmlzUGFyYWdyYXBoRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc1RhZ1N0YXJ0ID0gX3JlcXVpcmUuaXNUYWdTdGFydCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlID0gX3JlcXVpcmUuZ2V0U2luZ2xlQXR0cmlidXRlLFxuICBzZXRTaW5nbGVBdHRyaWJ1dGUgPSBfcmVxdWlyZS5zZXRTaW5nbGVBdHRyaWJ1dGU7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4uL2ZpbGV0eXBlcy5qc1wiKTtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIG1vZHVsZU5hbWUgPSBcImxvb3BcIjtcbmZ1bmN0aW9uIGhhc0NvbnRlbnQocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gaXNDb250ZW50KHBhcnQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0TWVhbmluZ0Z1bFBhcnQocGFyc2VkKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocGFyc2VkW2ldLnR5cGUgIT09IFwiY29udGVudFwiKSB7XG4gICAgICByZXR1cm4gcGFyc2VkW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KSB7XG4gIHZhciBmaXJzdE1lYW5pbmdmdWxQYXJ0ID0gZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydChwYXJ0LnN1YnBhcnNlZCk7XG4gIHJldHVybiBmaXJzdE1lYW5pbmdmdWxQYXJ0ICE9IG51bGwgJiYgZmlyc3RNZWFuaW5nZnVsUGFydC50YWcgIT09IFwidzp0XCI7XG59XG5mdW5jdGlvbiBnZXRQYWdlQnJlYWtJZkFwcGxpZXMocGFydCkge1xuICByZXR1cm4gcGFydC5oYXNQYWdlQnJlYWsgJiYgaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpID8gJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicgOiBcIlwiO1xufVxuZnVuY3Rpb24gaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpIHtcbiAgcmV0dXJuIHBhcnNlZC5sZW5ndGggJiYgaXNQYXJhZ3JhcGhTdGFydChwYXJzZWRbMF0pICYmIGlzUGFyYWdyYXBoRW5kKGxhc3QocGFyc2VkKSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoY2h1bmspIHtcbiAgcmV0dXJuIGhhc0NvbnRlbnQoY2h1bmspID8gMCA6IGNodW5rLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKSB7XG4gIHZhciBqID0gc3ViUmVuZGVyZWQucGFydHMubGVuZ3RoIC0gMTtcbiAgaWYgKHN1YlJlbmRlcmVkLnBhcnRzW2pdID09PSBcIjwvdzpwPlwiKSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMuc3BsaWNlKGosIDAsICc8dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+Jyk7XG4gIH0gZWxzZSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMucHVzaCgnPHc6cD48dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+PC93OnA+Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0QmVnaW5uaW5nKHN1YlJlbmRlcmVkKSB7XG4gIHN1YlJlbmRlcmVkLnBhcnRzLnVuc2hpZnQoJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicpO1xufVxuZnVuY3Rpb24gaXNDb250aW51b3VzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzVGFnU3RhcnQoXCJ3OnR5cGVcIiwgcGFydCkgJiYgcGFydC52YWx1ZS5pbmRleE9mKFwiY29udGludW91c1wiKSAhPT0gLTE7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOZXh0UGFnZShwYXJ0cykge1xuICByZXR1cm4gcGFydHMuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp2YWw9XCJuZXh0UGFnZVwiJykgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb25CZWZvcmUocGFydHMsIHNlY3QpIHtcbiAgcmV0dXJuIFtcIjx3OnA+PHc6cFByPlwiLmNvbmNhdChzZWN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KS5qb2luKFwiXCIpLCBcIjwvdzpwUHI+PC93OnA+XCIpXS5jb25jYXQocGFydHMpO1xufVxuZnVuY3Rpb24gYWRkQ29udGludW91c1R5cGUocGFydHMpIHtcbiAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGFydCkge1xuICAgIGlmIChzdG9wID09PSBmYWxzZSAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICBpblNlY3RQciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgocGFydCwgXCI8dzp0eXBlXCIpKSB7XG4gICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3AgPT09IGZhbHNlICYmIHN0YXJ0c1dpdGgocGFydCwgXCI8L3c6c2VjdFByXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCc8dzp0eXBlIHc6dmFsPVwiY29udGludW91c1wiLz4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gZHJvcEhlYWRlckZvb3RlclJlZnMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihmdW5jdGlvbiAodGV4dCkge1xuICAgIHJldHVybiAhc3RhcnRzV2l0aCh0ZXh0LCBcIjx3OmhlYWRlclJlZmVyZW5jZVwiKSAmJiAhc3RhcnRzV2l0aCh0ZXh0LCBcIjx3OmZvb3RlclJlZmVyZW5jZVwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNQYWdlQnJlYWsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC50YWcgPT09IFwidzpiclwiICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp0eXBlPVwicGFnZVwiJykgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0ltYWdlKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay5zb21lKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0YWcgPSBfcmVmMi50YWc7XG4gICAgcmV0dXJuIHRhZyA9PT0gXCJ3OmRyYXdpbmdcIjtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWN0UHIoY2h1bmtzKSB7XG4gIHZhciBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gIHZhciBzZWN0UHJzID0gW107XG4gIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFBycy5wdXNoKFtdKTtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgc2VjdFByc1tzZWN0UHJzLmxlbmd0aCAtIDFdLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlY3RQcnM7XG59XG5mdW5jdGlvbiBnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudChjaHVua3MpIHtcbiAgdmFyIGNvbGxlY3RTZWN0UHIgPSBmYWxzZTtcbiAgdmFyIHNlY3RQckNvdW50ID0gMDtcbiAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3RTZWN0UHIpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJ3OmhlYWRlclJlZmVyZW5jZVwiIHx8IHBhcnQudGFnID09PSBcInc6Zm9vdGVyUmVmZXJlbmNlXCIpIHtcbiAgICAgICAgc2VjdFByQ291bnQrKztcbiAgICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWN0UHJDb3VudDtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWN0UHIocGFyc2VkKSB7XG4gIHZhciBzZWN0UHIgPSBbXTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBwYXJzZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgaW5TZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBzZWN0UHIudW5zaGlmdChwYXJ0LnZhbHVlKTtcbiAgICAgIGluU2VjdFByID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHBhcnQpKSB7XG4gICAgICBpZiAoc2VjdFByLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlY3RQci5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIExvb3BNb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb29wTW9kdWxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb29wTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkxvb3BNb2R1bGVcIjtcbiAgICB0aGlzLmluWGZybSA9IGZhbHNlO1xuICAgIHRoaXMudG90YWxTZWN0UHIgPSAwO1xuICAgIHRoaXMucHJlZml4ID0ge1xuICAgICAgc3RhcnQ6IFwiI1wiLFxuICAgICAgZW5kOiBcIi9cIixcbiAgICAgIGRhc2g6IC9eLShbXlxcc10rKVxccyguKykvLFxuICAgICAgaW52ZXJ0ZWQ6IFwiXlwiXG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExvb3BNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0cywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5kb2N4dGVtcGxhdGVyID0gZG9jeHRlbXBsYXRlcjtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJzZShwYXJzZWQsIF9yZWYzKSB7XG4gICAgICB2YXIgY29udGVudFR5cGUgPSBfcmVmMy5jb250ZW50VHlwZTtcbiAgICAgIGlmIChmaWxldHlwZXMubWFpbi5pbmRleE9mKGNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZWN0cyA9IGdldFNlY3RQcihwYXJzZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVycygpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVOYW1lO1xuICAgICAgcmV0dXJuIFtbdGhpcy5wcmVmaXguc3RhcnQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiBmYWxzZVxuICAgICAgfV0sIFt0aGlzLnByZWZpeC5pbnZlcnRlZCwgbW9kdWxlLCB7XG4gICAgICAgIGV4cGFuZFRvOiBcImF1dG9cIixcbiAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgaW52ZXJ0ZWQ6IHRydWVcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguZW5kLCBtb2R1bGUsIHtcbiAgICAgICAgbG9jYXRpb246IFwiZW5kXCJcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguZGFzaCwgbW9kdWxlLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDMpLFxuICAgICAgICAgIGV4cGFuZFRvID0gX3JlZjVbMV0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmNVsyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICAgIGludmVydGVkOiBmYWxzZSxcbiAgICAgICAgICBleHBhbmRUbzogZXhwYW5kVG8sXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRyYWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFpdHModHJhaXROYW1lLCBwYXJzZWQpIHtcbiAgICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIGdldFRyYWl0cyBzaG91bGQgZGlzYXBwZWFyIGluIHY0XG4gICAgICBpZiAodHJhaXROYW1lICE9PSBcImV4cGFuZFBhaXJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbiAgICAgIHJldHVybiBwYXJzZWQucmVkdWNlKGZ1bmN0aW9uICh0YWdzLCBwYXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGlzTW9kdWxlKHBhcnQsIG1vZHVsZU5hbWUpICYmIHBhcnQuc3VicGFyc2VkID09IG51bGwpIHtcbiAgICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocGFyc2VkLCBfcmVmNikge1xuICAgICAgdmFyIGJhc2VQYXJ0ID0gX3JlZjYuYmFzZVBhcnQ7XG4gICAgICBpZiAoYmFzZVBhcnQgJiYgdGhpcy5kb2N4dGVtcGxhdGVyLmZpbGVUeXBlID09PSBcImRvY3hcIiAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBiYXNlUGFydC5zZWN0UHJDb3VudCA9IGdldFNlY3RQckhlYWRlckZvb3RlckNoYW5nZUNvdW50KHBhcnNlZCk7XG4gICAgICAgIHRoaXMudG90YWxTZWN0UHIgKz0gYmFzZVBhcnQuc2VjdFByQ291bnQ7XG4gICAgICAgIHZhciBzZWN0cyA9IHRoaXMuc2VjdHM7XG4gICAgICAgIHNlY3RzLnNvbWUoZnVuY3Rpb24gKHNlY3QsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGJhc2VQYXJ0LmxJbmRleCA8IHNlY3RbMF0ubEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgc2VjdHMubGVuZ3RoICYmIGlzQ29udGludW91cyhzZWN0c1tpbmRleCArIDFdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGRDb250aW51b3VzVHlwZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFswXS5sSW5kZXggPCBzZWN0WzBdLmxJbmRleCAmJiBzZWN0WzBdLmxJbmRleCA8IGJhc2VQYXJ0LmxJbmRleCkge1xuICAgICAgICAgICAgaWYgKGlzTmV4dFBhZ2Uoc2VjdHNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGROZXh0UGFnZSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VQYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciA9IGdldExhc3RTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnQgfHwgYmFzZVBhcnQuZXhwYW5kVG8gIT09IFwiYXV0b1wiIHx8IGJhc2VQYXJ0Lm1vZHVsZSAhPT0gbW9kdWxlTmFtZSB8fCAhaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBiYXNlUGFydC5wYXJhZ3JhcGhMb29wID0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbCA9IDA7XG4gICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwYXJzZWQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHApKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcmFncmFwaEVuZChwKSkge1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaXJzdENodW5rID0gY2h1bmtzWzBdO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICAgIHZhciBmaXJzdE9mZnNldCA9IGdldE9mZnNldChmaXJzdENodW5rKTtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gZ2V0T2Zmc2V0KGxhc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWtCZWdpbm5pbmcgPSBoYXNQYWdlQnJlYWsoZmlyc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWsgPSBoYXNQYWdlQnJlYWsobGFzdENodW5rKTtcbiAgICAgIGlmIChoYXNJbWFnZShmaXJzdENodW5rKSkge1xuICAgICAgICBmaXJzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW1hZ2UobGFzdENodW5rKSkge1xuICAgICAgICBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQuc2xpY2UoZmlyc3RPZmZzZXQsIHBhcnNlZC5sZW5ndGggLSBsYXN0T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc20gPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgICAgIHZhciBwcm9taXNlZFZhbHVlID0gc20uZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICBmdW5jdGlvbiBsb29wT3ZlcihzY29wZSwgaSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY29wZU1hbmFnZXIgPSBzbS5jcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHBhcnQudmFsdWUsIGksIHBhcnQsIGxlbmd0aCk7XG4gICAgICAgIHByb21pc2VzLnB1c2gob3B0aW9ucy5yZXNvbHZlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JMaXN0ID0gW107XG4gICAgICByZXR1cm4gcHJvbWlzZWRWYWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbCh2YWx1ZXMpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgIHNtLmxvb3BPdmVyVmFsdWUodmFsdWVzLCBsb29wT3ZlciwgcGFydC5pbnZlcnRlZCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5tYXAoZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWY3LnJlc29sdmVkLFxuICAgICAgICAgICAgICAgIGVycm9ycyA9IF9yZWY3LmVycm9ycztcbiAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2guYXBwbHkoZXJyb3JMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoZXJyb3JzKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhcnQudGFnID09PSBcInA6eGZybVwiKSB7XG4gICAgICAgIHRoaXMuaW5YZnJtID0gcGFydC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQudGFnID09PSBcImE6ZXh0XCIgJiYgdGhpcy5pblhmcm0pIHtcbiAgICAgICAgdGhpcy5sYXN0RXh0ID0gcGFydDtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTW9kdWxlKHBhcnQsIG1vZHVsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRvdGFsVmFsdWUgPSBbXTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciBoZWlnaHRPZmZzZXQgPSAwO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGZpcnN0VGFnID0gcGFydC5zdWJwYXJzZWRbMF07XG4gICAgICB2YXIgdGFnSGVpZ2h0ID0gMDtcbiAgICAgIGlmICgoZmlyc3RUYWcgPT09IG51bGwgfHwgZmlyc3RUYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0VGFnLnRhZykgPT09IFwiYTp0clwiKSB7XG4gICAgICAgIHRhZ0hlaWdodCA9ICtnZXRTaW5nbGVBdHRyaWJ1dGUoZmlyc3RUYWcudmFsdWUsIFwiaFwiKTtcbiAgICAgIH1cbiAgICAgIGhlaWdodE9mZnNldCAtPSB0YWdIZWlnaHQ7XG4gICAgICB2YXIgYTE2Um93SWRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGluc2lkZVBhcmFncmFwaExvb3AgPSBpc0luc2lkZVBhcmFncmFwaExvb3AocGFydCk7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgICBmdW5jdGlvbiBsb29wT3ZlcihzY29wZSwgaSwgbGVuZ3RoKSB7XG4gICAgICAgIGhlaWdodE9mZnNldCArPSB0YWdIZWlnaHQ7XG4gICAgICAgIHZhciBzY29wZU1hbmFnZXIgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5jcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHBhcnQudmFsdWUsIGksIHBhcnQsIGxlbmd0aCk7XG4gICAgICAgIHBhcnQuc3VicGFyc2VkLmZvckVhY2goZnVuY3Rpb24gKHBwKSB7XG4gICAgICAgICAgaWYgKGlzVGFnU3RhcnQoXCJhMTY6cm93SWRcIiwgcHApKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gK2dldFNpbmdsZUF0dHJpYnV0ZShwcC52YWx1ZSwgXCJ2YWxcIikgKyBhMTZSb3dJZE9mZnNldDtcbiAgICAgICAgICAgIGExNlJvd0lkT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIHBwLnZhbHVlID0gc2V0U2luZ2xlQXR0cmlidXRlKHBwLnZhbHVlLCBcInZhbFwiLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdWJSZW5kZXJlZCA9IG9wdGlvbnMucmVuZGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBhcnQuaGFzUGFnZUJyZWFrICYmIGkgPT09IGxlbmd0aCAtIDEgJiYgaW5zaWRlUGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOb3RGaXJzdCA9IHNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vdEZpcnN0KSB7XG4gICAgICAgICAgaWYgKHBhcnQuc2VjdFByQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHN1YlJlbmRlcmVkLnBhcnRzID0gZHJvcEhlYWRlckZvb3RlclJlZnMoc3ViUmVuZGVyZWQucGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5hZGRDb250aW51b3VzVHlwZSkge1xuICAgICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBhZGRDb250aW51b3VzVHlwZShzdWJSZW5kZXJlZC5wYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcnQuYWRkTmV4dFBhZ2UpIHtcbiAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGFkZFNlY3Rpb25CZWZvcmUoc3ViUmVuZGVyZWQucGFydHMsIHNlbGYuc2VjdHNbcGFydC5hZGROZXh0UGFnZS5pbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVha0JlZ2lubmluZyAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbGVuID0gc3ViUmVuZGVyZWQucGFydHMubGVuZ3RoOyBfaSA8IGxlbjsgX2krKykge1xuICAgICAgICAgIHRvdGFsVmFsdWUucHVzaChzdWJSZW5kZXJlZC5wYXJ0c1tfaV0pO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVycm9ycywgc3ViUmVuZGVyZWQuZXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5sb29wT3ZlcihwYXJ0LnZhbHVlLCBsb29wT3ZlciwgcGFydC5pbnZlcnRlZCwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIHRoZSBsb29wIGlzIHNob3dpbmcgZW1wdHkgY29udGVudFxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhcnQubGFzdFBhcmFncmFwU2VjdFByKSB7XG4gICAgICAgICAgaWYgKHBhcnQucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiPHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PC93OnA+XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IFwiPC93OnQ+PC93OnI+PC93OnA+PHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PHc6cj48dzp0PlwiKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZ2V0UGFnZUJyZWFrSWZBcHBsaWVzKHBhcnQpIHx8IFwiXCIsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFyIGN5ID0gK2dldFNpbmdsZUF0dHJpYnV0ZSh0aGlzLmxhc3RFeHQudmFsdWUsIFwiY3lcIik7XG4gICAgICAgIHRoaXMubGFzdEV4dC52YWx1ZSA9IHNldFNpbmdsZUF0dHJpYnV0ZSh0aGlzLmxhc3RFeHQudmFsdWUsIFwiY3lcIiwgY3kgKyBoZWlnaHRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMuam9pblVuY29ycnVwdCh0b3RhbFZhbHVlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGJhc2VQYXJ0OiBwYXJ0XG4gICAgICAgIH0pKSxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IExvb3BNb2R1bGUoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwiaXRlciIsIkFycmF5IiwiZnJvbSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9zbGljZWRUb0FycmF5IiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsImxlbiIsImFycjIiLCJsIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImNodW5rQnkiLCJsYXN0IiwiaXNQYXJhZ3JhcGhTdGFydCIsImlzTW9kdWxlIiwiaXNQYXJhZ3JhcGhFbmQiLCJpc0NvbnRlbnQiLCJzdGFydHNXaXRoIiwiaXNUYWdFbmQiLCJpc1RhZ1N0YXJ0IiwiZ2V0U2luZ2xlQXR0cmlidXRlIiwic2V0U2luZ2xlQXR0cmlidXRlIiwiZmlsZXR5cGVzIiwid3JhcHBlciIsIm1vZHVsZU5hbWUiLCJoYXNDb250ZW50IiwicGFydHMiLCJzb21lIiwicGFydCIsImdldEZpcnN0TWVhbmluZ0Z1bFBhcnQiLCJwYXJzZWQiLCJ0eXBlIiwiaXNJbnNpZGVQYXJhZ3JhcGhMb29wIiwiZmlyc3RNZWFuaW5nZnVsUGFydCIsInN1YnBhcnNlZCIsInRhZyIsImdldFBhZ2VCcmVha0lmQXBwbGllcyIsImhhc1BhZ2VCcmVhayIsImlzRW5jbG9zZWRCeVBhcmFncmFwaHMiLCJnZXRPZmZzZXQiLCJjaHVuayIsImFkZFBhZ2VCcmVha0F0RW5kIiwic3ViUmVuZGVyZWQiLCJqIiwic3BsaWNlIiwiYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmciLCJ1bnNoaWZ0IiwiaXNDb250aW51b3VzIiwiaW5kZXhPZiIsImlzTmV4dFBhZ2UiLCJhZGRTZWN0aW9uQmVmb3JlIiwic2VjdCIsImNvbmNhdCIsIm1hcCIsIl9yZWYiLCJqb2luIiwiYWRkQ29udGludW91c1R5cGUiLCJzdG9wIiwiaW5TZWN0UHIiLCJyZWR1Y2UiLCJyZXN1bHQiLCJkcm9wSGVhZGVyRm9vdGVyUmVmcyIsInRleHQiLCJoYXNJbWFnZSIsIl9yZWYyIiwiZ2V0U2VjdFByIiwiY2h1bmtzIiwiY29sbGVjdFNlY3RQciIsInNlY3RQcnMiLCJnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudCIsInNlY3RQckNvdW50IiwiZ2V0TGFzdFNlY3RQciIsInNlY3RQciIsIkxvb3BNb2R1bGUiLCJpblhmcm0iLCJ0b3RhbFNlY3RQciIsInByZWZpeCIsInN0YXJ0IiwiZW5kIiwiZGFzaCIsImludmVydGVkIiwib3B0aW9uc1RyYW5zZm9ybWVyIiwib3B0cyIsImRvY3h0ZW1wbGF0ZXIiLCJwcmVwYXJzZSIsIl9yZWYzIiwiY29udGVudFR5cGUiLCJtYWluIiwic2VjdHMiLCJtYXRjaGVycyIsIm1vZHVsZSIsImV4cGFuZFRvIiwibG9jYXRpb24iLCJfcmVmNCIsIl9yZWY1IiwiZ2V0VHJhaXRzIiwidHJhaXROYW1lIiwidGFncyIsIm9mZnNldCIsInBvc3RwYXJzZSIsIl9yZWY2IiwiYmFzZVBhcnQiLCJmaWxlVHlwZSIsImluZGV4IiwibEluZGV4IiwiYWRkTmV4dFBhZ2UiLCJsYXN0UGFyYWdyYXBTZWN0UHIiLCJwYXJhZ3JhcGhMb29wIiwibGV2ZWwiLCJwIiwiZmlyc3RDaHVuayIsImxhc3RDaHVuayIsImZpcnN0T2Zmc2V0IiwibGFzdE9mZnNldCIsImhhc1BhZ2VCcmVha0JlZ2lubmluZyIsInJlc29sdmUiLCJvcHRpb25zIiwic20iLCJzY29wZU1hbmFnZXIiLCJwcm9taXNlZFZhbHVlIiwiZ2V0VmFsdWVBc3luYyIsInByb21pc2VzIiwibG9vcE92ZXIiLCJzY29wZSIsImNyZWF0ZVN1YlNjb3BlTWFuYWdlciIsImNvbXBpbGVkIiwiZXJyb3JMaXN0IiwidGhlbiIsInZhbHVlcyIsIlByb21pc2UiLCJhbGwiLCJsb29wT3ZlclZhbHVlIiwiX3JlZjciLCJyZXNvbHZlZCIsImVycm9ycyIsInJlbmRlciIsInBvc2l0aW9uIiwibGFzdEV4dCIsInRvdGFsVmFsdWUiLCJoZWlnaHRPZmZzZXQiLCJzZWxmIiwiZmlyc3RUYWciLCJ0YWdIZWlnaHQiLCJhMTZSb3dJZE9mZnNldCIsImluc2lkZVBhcmFncmFwaExvb3AiLCJwcCIsInZhbCIsImlzTm90Rmlyc3QiLCJzY29wZVBhdGhJdGVtIiwiX2kiLCJjeSIsImpvaW5VbmNvcnJ1cHQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar traits = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph, getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar moduleName = \"rawxml\";\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nfunction getInner(_ref) {\n    var part = _ref.part, left = _ref.left, right = _ref.right, postparsed = _ref.postparsed, index = _ref.index;\n    var paragraphParts = postparsed.slice(left + 1, right);\n    paragraphParts.forEach(function(p, i) {\n        if (i === index - left - 1) {\n            return;\n        }\n        if (isContent(p)) {\n            throwRawTagShouldBeOnlyTextInParagraph({\n                paragraphParts: paragraphParts,\n                part: part\n            });\n        }\n    });\n    return part;\n}\nvar RawXmlModule = /*#__PURE__*/ function() {\n    function RawXmlModule() {\n        _classCallCheck(this, RawXmlModule);\n        this.name = \"RawXmlModule\";\n        this.prefix = \"@\";\n    }\n    return _createClass(RawXmlModule, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                this.fileTypeConfig = docxtemplater.fileTypeConfig;\n                return options;\n            }\n        },\n        {\n            key: \"matchers\",\n            value: function matchers() {\n                return [\n                    [\n                        this.prefix,\n                        moduleName\n                    ]\n                ];\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed) {\n                return traits.expandToOne(postparsed, {\n                    moduleName: moduleName,\n                    getInner: getInner,\n                    expandTo: this.fileTypeConfig.tagRawXml,\n                    error: {\n                        message: \"Raw tag not in paragraph\",\n                        id: \"raw_tag_outerxml_invalid\",\n                        explanation: function explanation(part) {\n                            return 'The tag \"'.concat(part.value, '\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.');\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, options) {\n                if (part.module !== moduleName) {\n                    return null;\n                }\n                var value;\n                var errors = [];\n                try {\n                    value = options.scopeManager.getValue(part.value, {\n                        part: part\n                    });\n                    if (value == null) {\n                        value = options.nullGetter(part);\n                    }\n                } catch (e) {\n                    errors.push(e);\n                    return {\n                        errors: errors\n                    };\n                }\n                value = value ? value : \"\";\n                if (typeof value === \"string\") {\n                    return {\n                        value: value\n                    };\n                }\n                return {\n                    errors: [\n                        getInvalidRawXMLValueException({\n                            tag: part.value,\n                            value: value,\n                            offset: part.offset\n                        })\n                    ]\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new RawXmlModule());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUN4SixTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFBRUUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTUMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRVSxlQUFlTixXQUFXTyxHQUFHLEdBQUdQO0lBQWE7QUFBRTtBQUM1VSxTQUFTUSxhQUFhZixXQUFXLEVBQUVnQixVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZZCxrQkFBa0JGLFlBQVlILFNBQVMsRUFBRW1CO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCRixhQUFhaUI7SUFBY04sT0FBT0MsY0FBYyxDQUFDWixhQUFhLGFBQWE7UUFBRVUsVUFBVTtJ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TUFBTSxLQUFLaEMsWUFBWTtvQkFDOUIsT0FBTztnQkFDVDtnQkFDQSxJQUFJZ0I7Z0JBQ0osSUFBSWlCLFNBQVMsRUFBRTtnQkFDZixJQUFJO29CQUNGakIsUUFBUUUsUUFBUWdCLFlBQVksQ0FBQ0MsUUFBUSxDQUFDL0IsS0FBS1ksS0FBSyxFQUFFO3dCQUNoRFosTUFBTUE7b0JBQ1I7b0JBQ0EsSUFBSVksU0FBUyxNQUFNO3dCQUNqQkEsUUFBUUUsUUFBUWtCLFVBQVUsQ0FBQ2hDO29CQUM3QjtnQkFDRixFQUFFLE9BQU9oQixHQUFHO29CQUNWNkMsT0FBT0ksSUFBSSxDQUFDakQ7b0JBQ1osT0FBTzt3QkFDTDZDLFFBQVFBO29CQUNWO2dCQUNGO2dCQUNBakIsUUFBUUEsUUFBUUEsUUFBUTtnQkFDeEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7b0JBQzdCLE9BQU87d0JBQ0xBLE9BQU9BO29CQUNUO2dCQUNGO2dCQUNBLE9BQU87b0JBQ0xpQixRQUFRO3dCQUFDbEMsK0JBQStCOzRCQUN0Q3VDLEtBQUtsQyxLQUFLWSxLQUFLOzRCQUNmQSxPQUFPQTs0QkFDUHVCLFFBQVFuQyxLQUFLbUMsTUFBTTt3QkFDckI7cUJBQUc7Z0JBQ0w7WUFDRjtRQUNGO0tBQUU7QUFDSjtBQUNBUCxPQUFPUSxPQUFPLEdBQUc7SUFDZixPQUFPdkMsUUFBUSxJQUFJWTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvcmF3eG1sLmpzP2YxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgdHJhaXRzID0gcmVxdWlyZShcIi4uL3RyYWl0cy5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGlzQ29udGVudCA9IF9yZXF1aXJlLmlzQ29udGVudDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCA9IF9yZXF1aXJlMi50aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCxcbiAgZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uID0gX3JlcXVpcmUyLmdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbjtcbnZhciBtb2R1bGVOYW1lID0gXCJyYXd4bWxcIjtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xuZnVuY3Rpb24gZ2V0SW5uZXIoX3JlZikge1xuICB2YXIgcGFydCA9IF9yZWYucGFydCxcbiAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgIHJpZ2h0ID0gX3JlZi5yaWdodCxcbiAgICBwb3N0cGFyc2VkID0gX3JlZi5wb3N0cGFyc2VkLFxuICAgIGluZGV4ID0gX3JlZi5pbmRleDtcbiAgdmFyIHBhcmFncmFwaFBhcnRzID0gcG9zdHBhcnNlZC5zbGljZShsZWZ0ICsgMSwgcmlnaHQpO1xuICBwYXJhZ3JhcGhQYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgaWYgKGkgPT09IGluZGV4IC0gbGVmdCAtIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ29udGVudChwKSkge1xuICAgICAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgoe1xuICAgICAgICBwYXJhZ3JhcGhQYXJ0czogcGFyYWdyYXBoUGFydHMsXG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwYXJ0O1xufVxudmFyIFJhd1htbE1vZHVsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhd1htbE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3WG1sTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJhd1htbE1vZHVsZVwiO1xuICAgIHRoaXMucHJlZml4ID0gXCJAXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYXdYbWxNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWc7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW1t0aGlzLnByZWZpeCwgbW9kdWxlTmFtZV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQpIHtcbiAgICAgIHJldHVybiB0cmFpdHMuZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwge1xuICAgICAgICBtb2R1bGVOYW1lOiBtb2R1bGVOYW1lLFxuICAgICAgICBnZXRJbm5lcjogZ2V0SW5uZXIsXG4gICAgICAgIGV4cGFuZFRvOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ1Jhd1htbCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiLFxuICAgICAgICAgIGlkOiBcInJhd190YWdfb3V0ZXJ4bWxfaW52YWxpZFwiLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBmdW5jdGlvbiBleHBsYW5hdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQocGFydC52YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGgsIHB1dHRpbmcgcmF3IHRhZ3MgaW5zaWRlIGFuIGlubGluZSBsb29wIGlzIGRpc2FsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhcnQubW9kdWxlICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMubnVsbEdldHRlcihwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlIDogXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yczogW2dldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbih7XG4gICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0XG4gICAgICAgIH0pXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgUmF3WG1sTW9kdWxlKCkpO1xufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJ0IiwiX3RvUHJpbWl0aXZlIiwiciIsImUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJ0cmFpdHMiLCJyZXF1aXJlIiwiX3JlcXVpcmUiLCJpc0NvbnRlbnQiLCJfcmVxdWlyZTIiLCJ0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCIsImdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbiIsIm1vZHVsZU5hbWUiLCJ3cmFwcGVyIiwiZ2V0SW5uZXIiLCJfcmVmIiwicGFydCIsImxlZnQiLCJyaWdodCIsInBvc3RwYXJzZWQiLCJpbmRleCIsInBhcmFncmFwaFBhcnRzIiwic2xpY2UiLCJmb3JFYWNoIiwicCIsIlJhd1htbE1vZHVsZSIsIm5hbWUiLCJwcmVmaXgiLCJ2YWx1ZSIsIm9wdGlvbnNUcmFuc2Zvcm1lciIsIm9wdGlvbnMiLCJkb2N4dGVtcGxhdGVyIiwiZmlsZVR5cGVDb25maWciLCJtYXRjaGVycyIsInBvc3RwYXJzZSIsImV4cGFuZFRvT25lIiwiZXhwYW5kVG8iLCJ0YWdSYXdYbWwiLCJlcnJvciIsIm1lc3NhZ2UiLCJpZCIsImV4cGxhbmF0aW9uIiwiY29uY2F0IiwicmVuZGVyIiwibW9kdWxlIiwiZXJyb3JzIiwic2NvcGVNYW5hZ2VyIiwiZ2V0VmFsdWUiLCJudWxsR2V0dGVyIiwicHVzaCIsInRhZyIsIm9mZnNldCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/render.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/render.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), getScopeCompilationError = _require.getScopeCompilationError;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), utf8ToWord = _require2.utf8ToWord, hasCorruptCharacters = _require2.hasCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), getCorruptCharactersException = _require3.getCorruptCharactersException;\nvar _require4 = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/content-types.js\"), settingsContentType = _require4.settingsContentType, coreContentType = _require4.coreContentType, appContentType = _require4.appContentType, customContentType = _require4.customContentType;\nvar ftprefix = {\n    docx: \"w\",\n    pptx: \"a\"\n};\nvar Render = /*#__PURE__*/ function() {\n    function Render() {\n        _classCallCheck(this, Render);\n        this.name = \"Render\";\n        this.recordRun = false;\n        this.recordedRun = [];\n    }\n    return _createClass(Render, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                this.parser = docxtemplater.parser;\n                this.fileType = docxtemplater.fileType;\n                return options;\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(obj) {\n                if (obj.compiled) {\n                    this.compiled = obj.compiled;\n                }\n                if (obj.data != null) {\n                    this.data = obj.data;\n                }\n            }\n        },\n        {\n            key: \"getRenderedMap\",\n            value: function getRenderedMap(mapper) {\n                var _this = this;\n                return Object.keys(this.compiled).reduce(function(mapper, from) {\n                    mapper[from] = {\n                        from: from,\n                        data: _this.data\n                    };\n                    return mapper;\n                }, mapper);\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, options) {\n                var _this2 = this;\n                var errors = [];\n                postparsed.forEach(function(p) {\n                    if (p.type === \"placeholder\") {\n                        var tag = p.value;\n                        try {\n                            options.cachedParsers[p.lIndex] = _this2.parser(tag, {\n                                tag: p\n                            });\n                        } catch (rootError) {\n                            errors.push(getScopeCompilationError({\n                                tag: tag,\n                                rootError: rootError,\n                                offset: p.offset\n                            }));\n                        }\n                    }\n                });\n                return {\n                    postparsed: postparsed,\n                    errors: errors\n                };\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, _ref) {\n                var contentType = _ref.contentType, scopeManager = _ref.scopeManager, linebreaks = _ref.linebreaks, nullGetter = _ref.nullGetter, fileType = _ref.fileType;\n                if (linebreaks && [\n                    settingsContentType,\n                    coreContentType,\n                    appContentType,\n                    customContentType\n                ].indexOf(contentType) !== -1) {\n                    // Fixes issue tested in #docprops-linebreak\n                    linebreaks = false;\n                }\n                if (linebreaks) {\n                    this.recordRuns(part);\n                }\n                if (part.type !== \"placeholder\" || part.module) {\n                    return;\n                }\n                var value;\n                try {\n                    value = scopeManager.getValue(part.value, {\n                        part: part\n                    });\n                } catch (e) {\n                    return {\n                        errors: [\n                            e\n                        ]\n                    };\n                }\n                if (value == null) {\n                    value = nullGetter(part);\n                }\n                if (hasCorruptCharacters(value)) {\n                    return {\n                        errors: [\n                            getCorruptCharactersException({\n                                tag: part.value,\n                                value: value,\n                                offset: part.offset\n                            })\n                        ]\n                    };\n                }\n                if (fileType === \"text\") {\n                    return {\n                        value: value\n                    };\n                }\n                return {\n                    value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n                };\n            }\n        },\n        {\n            key: \"recordRuns\",\n            value: function recordRuns(part) {\n                if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\n                    this.recordedRun = [];\n                } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\n                    if (part.position === \"start\") {\n                        this.recordRun = true;\n                        this.recordedRun = [\n                            part.value\n                        ];\n                    }\n                    if (part.position === \"end\" || part.position === \"selfclosing\") {\n                        this.recordedRun.push(part.value);\n                        this.recordRun = false;\n                    }\n                } else if (this.recordRun) {\n                    this.recordedRun.push(part.value);\n                }\n            }\n        },\n        {\n            key: \"renderLineBreaks\",\n            value: function renderLineBreaks(value) {\n                var _this3 = this;\n                var p = ftprefix[this.fileType];\n                var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n                var lines = value.split(\"\\n\");\n                var runprops = this.recordedRun.join(\"\");\n                return lines.map(function(line) {\n                    return utf8ToWord(line);\n                }).reduce(function(result, line, i) {\n                    result.push(line);\n                    if (i < lines.length - 1) {\n                        result.push(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(_this3.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n                    }\n                    return result;\n                }, []);\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new Render());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3JlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUN4SixTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFBRUUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTUMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRVSxlQUFlTixXQUFXTyxHQUFHLEdBQUdQO0lBQWE7QUFBRTtBQUM1VSxTQUFTUSxhQUFhZixXQUFXLEVBQUVnQixVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZZCxrQkFBa0JGLFlBQVlILFNBQVMsRUFBRW1CO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCRixhQUFhaUI7SUFBY04sT0FBT0MsY0FBYyxDQUFDWixhQUFhLGFBQWE7UUFBRVUsVUFBVTtJ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UUFDRjtLQUFFO0FBQ0o7QUFDQWIsT0FBT2MsT0FBTyxHQUFHO0lBQ2YsT0FBT3pFLFFBQVEsSUFBSWlCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yZW5kZXIuanM/OGRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIHV0ZjhUb1dvcmQgPSBfcmVxdWlyZTIudXRmOFRvV29yZCxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnMgPSBfcmVxdWlyZTIuaGFzQ29ycnVwdENoYXJhY3RlcnM7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb247XG52YXIgX3JlcXVpcmU0ID0gcmVxdWlyZShcIi4uL2NvbnRlbnQtdHlwZXMuanNcIiksXG4gIHNldHRpbmdzQ29udGVudFR5cGUgPSBfcmVxdWlyZTQuc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlID0gX3JlcXVpcmU0LmNvcmVDb250ZW50VHlwZSxcbiAgYXBwQ29udGVudFR5cGUgPSBfcmVxdWlyZTQuYXBwQ29udGVudFR5cGUsXG4gIGN1c3RvbUNvbnRlbnRUeXBlID0gX3JlcXVpcmU0LmN1c3RvbUNvbnRlbnRUeXBlO1xudmFyIGZ0cHJlZml4ID0ge1xuICBkb2N4OiBcIndcIixcbiAgcHB0eDogXCJhXCJcbn07XG52YXIgUmVuZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXIpO1xuICAgIHRoaXMubmFtZSA9IFwiUmVuZGVyXCI7XG4gICAgdGhpcy5yZWNvcmRSdW4gPSBmYWxzZTtcbiAgICB0aGlzLnJlY29yZGVkUnVuID0gW107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZW5kZXIsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5wYXJzZXIgPSBkb2N4dGVtcGxhdGVyLnBhcnNlcjtcbiAgICAgIHRoaXMuZmlsZVR5cGUgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob2JqKSB7XG4gICAgICBpZiAob2JqLmNvbXBpbGVkKSB7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBvYmouY29tcGlsZWQ7XG4gICAgICB9XG4gICAgICBpZiAob2JqLmRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBvYmouZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyZWRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyZWRNYXAobWFwcGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLnJlZHVjZShmdW5jdGlvbiAobWFwcGVyLCBmcm9tKSB7XG4gICAgICAgIG1hcHBlcltmcm9tXSA9IHtcbiAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgIGRhdGE6IF90aGlzLmRhdGFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hcHBlcjtcbiAgICAgIH0sIG1hcHBlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBwb3N0cGFyc2VkLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHAudmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGVkUGFyc2Vyc1twLmxJbmRleF0gPSBfdGhpczIucGFyc2VyKHRhZywge1xuICAgICAgICAgICAgICB0YWc6IHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHJvb3RFcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgIHJvb3RFcnJvcjogcm9vdEVycm9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHAub2Zmc2V0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIF9yZWYpIHtcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IF9yZWYuY29udGVudFR5cGUsXG4gICAgICAgIHNjb3BlTWFuYWdlciA9IF9yZWYuc2NvcGVNYW5hZ2VyLFxuICAgICAgICBsaW5lYnJlYWtzID0gX3JlZi5saW5lYnJlYWtzLFxuICAgICAgICBudWxsR2V0dGVyID0gX3JlZi5udWxsR2V0dGVyLFxuICAgICAgICBmaWxlVHlwZSA9IF9yZWYuZmlsZVR5cGU7XG4gICAgICBpZiAobGluZWJyZWFrcyAmJiBbc2V0dGluZ3NDb250ZW50VHlwZSwgY29yZUNvbnRlbnRUeXBlLCBhcHBDb250ZW50VHlwZSwgY3VzdG9tQ29udGVudFR5cGVdLmluZGV4T2YoY29udGVudFR5cGUpICE9PSAtMSkge1xuICAgICAgICAvLyBGaXhlcyBpc3N1ZSB0ZXN0ZWQgaW4gI2RvY3Byb3BzLWxpbmVicmVha1xuICAgICAgICBsaW5lYnJlYWtzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobGluZWJyZWFrcykge1xuICAgICAgICB0aGlzLnJlY29yZFJ1bnMocGFydCk7XG4gICAgICB9XG4gICAgICBpZiAocGFydC50eXBlICE9PSBcInBsYWNlaG9sZGVyXCIgfHwgcGFydC5tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBzY29wZU1hbmFnZXIuZ2V0VmFsdWUocGFydC52YWx1ZSwge1xuICAgICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBbZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gbnVsbEdldHRlcihwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDb3JydXB0Q2hhcmFjdGVycyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IFtnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbih7XG4gICAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0XG4gICAgICAgICAgfSldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbGluZWJyZWFrcyAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB0aGlzLnJlbmRlckxpbmVCcmVha3ModmFsdWUpIDogdXRmOFRvV29yZCh2YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY29yZFJ1bnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkUnVucyhwYXJ0KSB7XG4gICAgICBpZiAocGFydC50YWcgPT09IFwiXCIuY29uY2F0KGZ0cHJlZml4W3RoaXMuZmlsZVR5cGVdLCBcIjpyXCIpKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4gPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAocGFydC50YWcgPT09IFwiXCIuY29uY2F0KGZ0cHJlZml4W3RoaXMuZmlsZVR5cGVdLCBcIjpyUHJcIikpIHtcbiAgICAgICAgaWYgKHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkUnVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlY29yZGVkUnVuID0gW3BhcnQudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnBvc2l0aW9uID09PSBcImVuZFwiIHx8IHBhcnQucG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkZWRSdW4ucHVzaChwYXJ0LnZhbHVlKTtcbiAgICAgICAgICB0aGlzLnJlY29yZFJ1biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3JkUnVuKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4ucHVzaChwYXJ0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGluZUJyZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5lQnJlYWtzKHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBwID0gZnRwcmVmaXhbdGhpcy5maWxlVHlwZV07XG4gICAgICB2YXIgYnIgPSB0aGlzLmZpbGVUeXBlID09PSBcImRvY3hcIiA/IFwiPHc6cj48dzpici8+PC93OnI+XCIgOiBcIjxhOmJyLz5cIjtcbiAgICAgIHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdmFyIHJ1bnByb3BzID0gdGhpcy5yZWNvcmRlZFJ1bi5qb2luKFwiXCIpO1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gdXRmOFRvV29yZChsaW5lKTtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBsaW5lLCBpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcIjwvXCIuY29uY2F0KHAsIFwiOnQ+PC9cIikuY29uY2F0KHAsIFwiOnI+XCIpLmNvbmNhdChiciwgXCI8XCIpLmNvbmNhdChwLCBcIjpyPlwiKS5jb25jYXQocnVucHJvcHMsIFwiPFwiKS5jb25jYXQocCwgXCI6dFwiKS5jb25jYXQoX3RoaXMzLmZpbGVUeXBlID09PSBcImRvY3hcIiA/ICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIicgOiBcIlwiLCBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFJlbmRlcigpKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwidCIsIl90b1ByaW1pdGl2ZSIsInIiLCJlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiU3RyaW5nIiwiTnVtYmVyIiwid3JhcHBlciIsInJlcXVpcmUiLCJfcmVxdWlyZSIsImdldFNjb3BlQ29tcGlsYXRpb25FcnJvciIsIl9yZXF1aXJlMiIsInV0ZjhUb1dvcmQiLCJoYXNDb3JydXB0Q2hhcmFjdGVycyIsIl9yZXF1aXJlMyIsImdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uIiwiX3JlcXVpcmU0Iiwic2V0dGluZ3NDb250ZW50VHlwZSIsImNvcmVDb250ZW50VHlwZSIsImFwcENvbnRlbnRUeXBlIiwiY3VzdG9tQ29udGVudFR5cGUiLCJmdHByZWZpeCIsImRvY3giLCJwcHR4IiwiUmVuZGVyIiwibmFtZSIsInJlY29yZFJ1biIsInJlY29yZGVkUnVuIiwidmFsdWUiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJvcHRpb25zIiwiZG9jeHRlbXBsYXRlciIsInBhcnNlciIsImZpbGVUeXBlIiwic2V0Iiwib2JqIiwiY29tcGlsZWQiLCJkYXRhIiwiZ2V0UmVuZGVyZWRNYXAiLCJtYXBwZXIiLCJfdGhpcyIsImtleXMiLCJyZWR1Y2UiLCJmcm9tIiwicG9zdHBhcnNlIiwicG9zdHBhcnNlZCIsIl90aGlzMiIsImVycm9ycyIsImZvckVhY2giLCJwIiwidHlwZSIsInRhZyIsImNhY2hlZFBhcnNlcnMiLCJsSW5kZXgiLCJyb290RXJyb3IiLCJwdXNoIiwib2Zmc2V0IiwicmVuZGVyIiwicGFydCIsIl9yZWYiLCJjb250ZW50VHlwZSIsInNjb3BlTWFuYWdlciIsImxpbmVicmVha3MiLCJudWxsR2V0dGVyIiwiaW5kZXhPZiIsInJlY29yZFJ1bnMiLCJtb2R1bGUiLCJnZXRWYWx1ZSIsInJlbmRlckxpbmVCcmVha3MiLCJjb25jYXQiLCJwb3NpdGlvbiIsIl90aGlzMyIsImJyIiwibGluZXMiLCJzcGxpdCIsInJ1bnByb3BzIiwiam9pbiIsIm1hcCIsImxpbmUiLCJyZXN1bHQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), isTextStart = _require.isTextStart, isTextEnd = _require.isTextEnd, endsWith = _require.endsWith, startsWith = _require.startsWith;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n    return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n    var tag = chunk[index].value;\n    if (chunk[index + 1].value === \"</w:t>\") {\n        return tag;\n    }\n    if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n        return tag;\n    }\n    return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n    return meta && meta.basePart && chunk.length > 1;\n}\nvar SpacePreserve = /*#__PURE__*/ function() {\n    function SpacePreserve() {\n        _classCallCheck(this, SpacePreserve);\n        this.name = \"SpacePreserveModule\";\n    }\n    return _createClass(SpacePreserve, [\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, meta) {\n                var chunk = [], inTextTag = false, endLindex = 0, lastTextTag = 0;\n                function isStartingPlaceHolder(part, chunk) {\n                    return part.type === \"placeholder\" && chunk.length > 1;\n                }\n                var result = postparsed.reduce(function(postparsed, part) {\n                    if (isWtStart(part)) {\n                        inTextTag = true;\n                        lastTextTag = chunk.length;\n                    }\n                    if (!inTextTag) {\n                        postparsed.push(part);\n                        return postparsed;\n                    }\n                    chunk.push(part);\n                    if (isInsideLoop(meta, chunk)) {\n                        endLindex = meta.basePart.endLindex;\n                        chunk[0].value = addXMLPreserve(chunk, 0);\n                    }\n                    if (isStartingPlaceHolder(part, chunk)) {\n                        chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n                        endLindex = part.endLindex;\n                    }\n                    if (isTextEnd(part) && part.lIndex > endLindex) {\n                        if (endLindex !== 0) {\n                            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n                        }\n                        Array.prototype.push.apply(postparsed, chunk);\n                        chunk = [];\n                        inTextTag = false;\n                        endLindex = 0;\n                        lastTextTag = 0;\n                    }\n                    return postparsed;\n                }, []);\n                Array.prototype.push.apply(result, chunk);\n                return result;\n            }\n        },\n        {\n            key: \"postrender\",\n            value: function postrender(parts) {\n                var lastNonEmpty = \"\";\n                var lastNonEmptyIndex = 0;\n                for(var i = 0, len = parts.length; i < len; i++){\n                    var index = i;\n                    var p = parts[i];\n                    if (p === \"\") {\n                        continue;\n                    }\n                    if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n                        parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n                        p = p.substr(wtEndlen);\n                    }\n                    lastNonEmpty = p;\n                    lastNonEmptyIndex = index;\n                    parts[i] = p;\n                }\n                return parts;\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new SpacePreserve());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFVLGVBQWVOLFdBQVdPLEdBQUcsR0FBR1A7SUFBYTtBQUFFO0FBQzVVLFNBQVNRLGFBQWFmLFdBQVcsRUFBRWdCLFVBQVUsRUFBRUMsV0FBVztJQUFJLElBQUlELFlBQVlkLGtCQUFrQkYsWUFBWUgsU0FBUyxFQUFFbUI7SUFBYSxJQUFJQyxhQUFhZixrQkFBa0JGLGFBQWFpQjtJQUFjTixPQUFPQyxjQUFjLENBQUNaLGFBQWEsYUFBYTtRQUFF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QUFDVDtvQkFDZjtvQkFDQThCLGVBQWVHO29CQUNmRixvQkFBb0J6QjtvQkFDcEJ1QixLQUFLLENBQUM1RCxFQUFFLEdBQUdnRTtnQkFDYjtnQkFDQSxPQUFPSjtZQUNUO1FBQ0Y7S0FBRTtBQUNKO0FBQ0FLLE9BQU9DLE9BQU8sR0FBRztJQUNmLE9BQU83QyxRQUFRLElBQUl1QjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZC1wbGFubmVyLWZyb250LWVuZC8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanM/OWUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgaXNUZXh0U3RhcnQgPSBfcmVxdWlyZS5pc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kID0gX3JlcXVpcmUuaXNUZXh0RW5kLFxuICBlbmRzV2l0aCA9IF9yZXF1aXJlLmVuZHNXaXRoLFxuICBzdGFydHNXaXRoID0gX3JlcXVpcmUuc3RhcnRzV2l0aDtcbnZhciB3VHByZXNlcnZlID0gJzx3OnQgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nO1xudmFyIHdUcHJlc2VydmVsZW4gPSB3VHByZXNlcnZlLmxlbmd0aDtcbnZhciB3dEVuZCA9IFwiPC93OnQ+XCI7XG52YXIgd3RFbmRsZW4gPSB3dEVuZC5sZW5ndGg7XG5mdW5jdGlvbiBpc1d0U3RhcnQocGFydCkge1xuICByZXR1cm4gaXNUZXh0U3RhcnQocGFydCkgJiYgcGFydC50YWcgPT09IFwidzp0XCI7XG59XG5mdW5jdGlvbiBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgaW5kZXgpIHtcbiAgdmFyIHRhZyA9IGNodW5rW2luZGV4XS52YWx1ZTtcbiAgaWYgKGNodW5rW2luZGV4ICsgMV0udmFsdWUgPT09IFwiPC93OnQ+XCIpIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIGlmICh0YWcuaW5kZXhPZigneG1sOnNwYWNlPVwicHJlc2VydmVcIicpICE9PSAtMSkge1xuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgcmV0dXJuIHRhZy5zdWJzdHIoMCwgdGFnLmxlbmd0aCAtIDEpICsgJyB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPic7XG59XG5mdW5jdGlvbiBpc0luc2lkZUxvb3AobWV0YSwgY2h1bmspIHtcbiAgcmV0dXJuIG1ldGEgJiYgbWV0YS5iYXNlUGFydCAmJiBjaHVuay5sZW5ndGggPiAxO1xufVxudmFyIFNwYWNlUHJlc2VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGFjZVByZXNlcnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFjZVByZXNlcnZlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNwYWNlUHJlc2VydmVNb2R1bGVcIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNwYWNlUHJlc2VydmUsIFt7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgbWV0YSkge1xuICAgICAgdmFyIGNodW5rID0gW10sXG4gICAgICAgIGluVGV4dFRhZyA9IGZhbHNlLFxuICAgICAgICBlbmRMaW5kZXggPSAwLFxuICAgICAgICBsYXN0VGV4dFRhZyA9IDA7XG4gICAgICBmdW5jdGlvbiBpc1N0YXJ0aW5nUGxhY2VIb2xkZXIocGFydCwgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiICYmIGNodW5rLmxlbmd0aCA+IDE7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gcG9zdHBhcnNlZC5yZWR1Y2UoZnVuY3Rpb24gKHBvc3RwYXJzZWQsIHBhcnQpIHtcbiAgICAgICAgaWYgKGlzV3RTdGFydChwYXJ0KSkge1xuICAgICAgICAgIGluVGV4dFRhZyA9IHRydWU7XG4gICAgICAgICAgbGFzdFRleHRUYWcgPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgICAgICBwb3N0cGFyc2VkLnB1c2gocGFydCk7XG4gICAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsucHVzaChwYXJ0KTtcbiAgICAgICAgaWYgKGlzSW5zaWRlTG9vcChtZXRhLCBjaHVuaykpIHtcbiAgICAgICAgICBlbmRMaW5kZXggPSBtZXRhLmJhc2VQYXJ0LmVuZExpbmRleDtcbiAgICAgICAgICBjaHVua1swXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdGFydGluZ1BsYWNlSG9sZGVyKHBhcnQsIGNodW5rKSkge1xuICAgICAgICAgIGNodW5rW2xhc3RUZXh0VGFnXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCBsYXN0VGV4dFRhZyk7XG4gICAgICAgICAgZW5kTGluZGV4ID0gcGFydC5lbmRMaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dEVuZChwYXJ0KSAmJiBwYXJ0LmxJbmRleCA+IGVuZExpbmRleCkge1xuICAgICAgICAgIGlmIChlbmRMaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGNodW5rW2xhc3RUZXh0VGFnXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCBsYXN0VGV4dFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHBvc3RwYXJzZWQsIGNodW5rKTtcbiAgICAgICAgICBjaHVuayA9IFtdO1xuICAgICAgICAgIGluVGV4dFRhZyA9IGZhbHNlO1xuICAgICAgICAgIGVuZExpbmRleCA9IDA7XG4gICAgICAgICAgbGFzdFRleHRUYWcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3N0cGFyc2VkO1xuICAgICAgfSwgW10pO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBjaHVuayk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RyZW5kZXIocGFydHMpIHtcbiAgICAgIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICAgICAgdmFyIGxhc3ROb25FbXB0eUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAocCA9PT0gXCJcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aChsYXN0Tm9uRW1wdHksIHdUcHJlc2VydmUpICYmIHN0YXJ0c1dpdGgocCwgd3RFbmQpKSB7XG4gICAgICAgICAgcGFydHNbbGFzdE5vbkVtcHR5SW5kZXhdID0gbGFzdE5vbkVtcHR5LnN1YnN0cigwLCBsYXN0Tm9uRW1wdHkubGVuZ3RoIC0gd1RwcmVzZXJ2ZWxlbikgKyBcIjx3OnQvPlwiO1xuICAgICAgICAgIHAgPSBwLnN1YnN0cih3dEVuZGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE5vbkVtcHR5ID0gcDtcbiAgICAgICAgbGFzdE5vbkVtcHR5SW5kZXggPSBpbmRleDtcbiAgICAgICAgcGFydHNbaV0gPSBwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBTcGFjZVByZXNlcnZlKCkpO1xufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJ0IiwiX3RvUHJpbWl0aXZlIiwiciIsImUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJ3cmFwcGVyIiwicmVxdWlyZSIsIl9yZXF1aXJlIiwiaXNUZXh0U3RhcnQiLCJpc1RleHRFbmQiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJ3VHByZXNlcnZlIiwid1RwcmVzZXJ2ZWxlbiIsInd0RW5kIiwid3RFbmRsZW4iLCJpc1d0U3RhcnQiLCJwYXJ0IiwidGFnIiwiYWRkWE1MUHJlc2VydmUiLCJjaHVuayIsImluZGV4IiwidmFsdWUiLCJpbmRleE9mIiwic3Vic3RyIiwiaXNJbnNpZGVMb29wIiwibWV0YSIsImJhc2VQYXJ0IiwiU3BhY2VQcmVzZXJ2ZSIsIm5hbWUiLCJwb3N0cGFyc2UiLCJwb3N0cGFyc2VkIiwiaW5UZXh0VGFnIiwiZW5kTGluZGV4IiwibGFzdFRleHRUYWciLCJpc1N0YXJ0aW5nUGxhY2VIb2xkZXIiLCJ0eXBlIiwicmVzdWx0IiwicmVkdWNlIiwicHVzaCIsImxJbmRleCIsIkFycmF5IiwiYXBwbHkiLCJwb3N0cmVuZGVyIiwicGFydHMiLCJsYXN0Tm9uRW1wdHkiLCJsYXN0Tm9uRW1wdHlJbmRleCIsImxlbiIsInAiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/parser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), wordToUtf8 = _require.wordToUtf8;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js\"), match = _require2.match, getValue = _require2.getValue, getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n    var matchers = [];\n    for(var i = 0, l = modules.length; i < l; i++){\n        var _module = modules[i];\n        if (_module.matchers) {\n            var mmm = _module.matchers(options);\n            if (!(mmm instanceof Array)) {\n                throw new Error(\"module matcher returns a non array\");\n            }\n            matchers.push.apply(matchers, _toConsumableArray(mmm));\n        }\n    }\n    return matchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n    var matches = [];\n    for(var i = 0, len = matchers.length; i < len; i++){\n        var matcher = matchers[i];\n        var _matcher = _slicedToArray(matcher, 2), prefix = _matcher[0], _module2 = _matcher[1];\n        var properties = matcher[2] || {};\n        if (options.match(prefix, placeHolderContent)) {\n            var values = options.getValues(prefix, placeHolderContent);\n            if (typeof properties === \"function\") {\n                properties = properties(values);\n            }\n            if (!properties.value) {\n                var _values = _slicedToArray(values, 2);\n                properties.value = _values[1];\n            }\n            matches.push(_objectSpread({\n                type: \"placeholder\",\n                prefix: prefix,\n                module: _module2,\n                onMatch: properties.onMatch,\n                priority: properties.priority\n            }, properties));\n        }\n    }\n    return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n    var modules = options.modules;\n    var startOffset = options.startOffset;\n    var endLindex = options.lIndex;\n    var moduleParsed;\n    options.offset = startOffset;\n    options.match = match;\n    options.getValue = getValue;\n    options.getValues = getValues;\n    var matchers = getMatchers(modules, options);\n    var matches = getMatches(matchers, placeHolderContent, options);\n    if (matches.length > 0) {\n        var bestMatch = null;\n        matches.forEach(function(match) {\n            match.priority = match.priority || -match.value.length;\n            if (!bestMatch || match.priority > bestMatch.priority) {\n                bestMatch = match;\n            }\n        });\n        bestMatch.offset = startOffset;\n        delete bestMatch.priority;\n        bestMatch.endLindex = endLindex;\n        bestMatch.lIndex = endLindex;\n        bestMatch.raw = placeHolderContent;\n        if (bestMatch.onMatch) {\n            bestMatch.onMatch(bestMatch);\n        }\n        delete bestMatch.onMatch;\n        delete bestMatch.prefix;\n        return bestMatch;\n    }\n    for(var i = 0, l = modules.length; i < l; i++){\n        var _module3 = modules[i];\n        moduleParsed = _module3.parse(placeHolderContent, options);\n        if (moduleParsed) {\n            moduleParsed.offset = startOffset;\n            moduleParsed.endLindex = endLindex;\n            moduleParsed.lIndex = endLindex;\n            moduleParsed.raw = placeHolderContent;\n            return moduleParsed;\n        }\n    }\n    return {\n        type: \"placeholder\",\n        value: placeHolderContent,\n        offset: startOffset,\n        endLindex: endLindex,\n        lIndex: endLindex\n    };\n}\nvar parser = {\n    preparse: function preparse(parsed, modules, options) {\n        function preparse(parsed, options) {\n            return modules.forEach(function(module1) {\n                module1.preparse(parsed, options);\n            });\n        }\n        return {\n            preparsed: preparse(parsed, options)\n        };\n    },\n    parse: function parse(lexed, modules, options) {\n        var inPlaceHolder = false;\n        var placeHolderContent = \"\";\n        var startOffset;\n        var tailParts = [];\n        var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n        return lexed.reduce(function lexedToParsed(parsed, token) {\n            if (token.type === \"delimiter\") {\n                inPlaceHolder = token.position === \"start\";\n                if (token.position === \"end\") {\n                    options.parse = function(placeHolderContent) {\n                        return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n                            startOffset: startOffset,\n                            modules: modules\n                        }));\n                    };\n                    parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n                    Array.prototype.push.apply(parsed, tailParts);\n                    tailParts = [];\n                }\n                if (token.position === \"start\") {\n                    tailParts = [];\n                    startOffset = token.offset;\n                }\n                placeHolderContent = \"\";\n                return parsed;\n            }\n            if (!inPlaceHolder) {\n                parsed.push(token);\n                return parsed;\n            }\n            if (token.type !== \"content\" || token.position !== \"insidetag\") {\n                if (droppedTags.indexOf(token.tag) !== -1) {\n                    return parsed;\n                }\n                tailParts.push(token);\n                return parsed;\n            }\n            placeHolderContent += token.value;\n            return parsed;\n        }, []);\n    },\n    postparse: function postparse(postparsed, modules, options) {\n        function getTraits(traitName, postparsed) {\n            return modules.map(function(module1) {\n                return module1.getTraits(traitName, postparsed);\n            });\n        }\n        var errors = [];\n        function _postparse(postparsed, options) {\n            return modules.reduce(function(postparsed, module1) {\n                var r = module1.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n                    postparse: function postparse(parsed, opts) {\n                        return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n                    },\n                    getTraits: getTraits\n                }));\n                if (r == null) {\n                    return postparsed;\n                }\n                if (r.errors) {\n                    Array.prototype.push.apply(errors, r.errors);\n                    return r.postparsed;\n                }\n                return r;\n            }, postparsed);\n        }\n        return {\n            postparsed: _postparse(postparsed, options),\n            errors: errors\n        };\n    }\n};\nmodule.exports = parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSVgsSUFBSVMsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVZLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdDLEdBQUdPLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEVBQUVPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUyxjQUFjWCxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlXLFVBQVVDLE1BQU0sRUFBRVosSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVUsU0FBUyxDQUFDWCxFQUFFLEdBQUdXLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR1ksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSWMsZ0JBQWdCZixHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFLRSxPQUFPYSx5QkFBeUIsR0FBR2IsT0FBT2MsZ0JBQWdCLENBQUNqQixHQUFHRyxPQUFPYSx5QkFBeUIsQ0FBQ2QsTUFBTUgsUUFBUUksT0FBT0QsSUFBSVksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSUUsT0FBT2UsY0FBYyxDQUFDbEIsR0FBR0MsR0FBR0UsT0FBT0ksd0JBQXdCLENBQUNMLEdBQUdEO1FBQUs7SUFBSTtJQUFFLE9BQU9EO0FBQUc7QUFDdGIsU0FBU2UsZ0JBQWdCSSxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUFJRCxNQUFNRSxlQUFlRjtJQUFNLElBQUlBLE9BQU9ELEtBQUs7UUFBRWhCLE9BQU9lLGNBQWMsQ0FBQ0MsS0FBS0MsS0FBSztZQUFFQyxPQUFPQTtZQUFPYixZQUFZO1lBQU1lLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFTCxHQUFHLENBQUNDLElBQUksR0FBR0M7SUFBTztJQUFFLE9BQU9GO0FBQUs7QUFDM08sU0FBU0csZUFBZXBCLENBQUM7SUFBSSxJQUFJdUIsSUFBSUMsYUFBYXhCLEdBQUc7SUFBVyxPQUFPLFlBQVlULFFBQVFnQyxLQUFLQSxJQUFJQSxJQUFJO0FBQUk7QUFDNUcsU0FBU0MsYUFBYXhCLENBQUMsRUFBRUQsQ0FBQztJQUFJLElBQUksWUFBWVIsUUFBUVMsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQUcsSUFBSUYsSUFBSUUsQ0FBQyxDQUFDUCxPQUFPZ0MsV0FBVyxDQUFDO0lBQUUsSUFBSSxLQUFLLE1BQU0zQixHQUFHO1FBQUUsSUFBSXlCLElBQUl6QixFQUFFNEIsSUFBSSxDQUFDMUIsR0FBR0QsS0FBSztRQUFZLElBQUksWUFBWVIsUUFBUWdDLElBQUksT0FBT0E7UUFBRyxNQUFNLElBQUlJLFVBQVU7SUFBaUQ7SUFBRSxPQUFPLENBQUMsYUFBYTVCLElBQUk2QixTQUFTQyxNQUFLLEVBQUc3QjtBQUFJO0FBQzNULFNBQVM4QixlQUFlQyxHQUFHLEVBQUVSLENBQUM7SUFBSSxPQUFPUyxnQkFBZ0JELFFBQVFFLHNCQUFzQkYsS0FBS1IsTUFBTVcsNEJBQTRCSCxLQUFLUixNQUFNWTtBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlSLFVBQVU7QUFBOEk7QUFDaE0sU0FBU00sc0JBQXNCbEMsQ0FBQyxFQUFFcUMsQ0FBQztJQUFJLElBQUlwQyxJQUFJLFFBQVFELElBQUksT0FBTyxlQUFlLE9BQU9OLFVBQVVNLENBQUMsQ0FBQ04sT0FBT0MsUUFBUSxDQUFDLElBQUlLLENBQUMsQ0FBQyxhQUFhO0lBQUUsSUFBSSxRQUFRQyxHQUFHO1FBQUUsSUFBSUYsR0FBR3VDLEdBQUdkLEdBQUdlLEdBQUdDLElBQUksRUFBRSxFQUFFQyxJQUFJLENBQUMsR0FBR2hELElBQUksQ0FBQztRQUFHLElBQUk7WUFBRSxJQUFJK0IsSUFBSSxDQUFDdkIsSUFBSUEsRUFBRTBCLElBQUksQ0FBQzNCLEVBQUMsRUFBRzBDLElBQUksRUFBRSxNQUFNTCxHQUFHO2dCQUFFLElBQUluQyxPQUFPRCxPQUFPQSxHQUFHO2dCQUFRd0MsSUFBSSxDQUFDO1lBQUcsT0FBTyxNQUFPLENBQUVBLENBQUFBLElBQUksQ0FBQzFDLElBQUl5QixFQUFFRyxJQUFJLENBQUMxQixFQUFDLEVBQUcwQyxJQUFJLEtBQU1ILENBQUFBLEVBQUVoQyxJQUFJLENBQUNULEVBQUVxQixLQUFLLEdBQUdvQixFQUFFNUIsTUFBTSxLQUFLeUIsQ0FBQUEsR0FBSUksSUFBSSxDQUFDO1FBQUksRUFBRSxPQUFPekMsR0FBRztZQUFFUCxJQUFJLENBQUMsR0FBRzZDLElBQUl0QztRQUFHLFNBQVU7WUFBRSxJQUFJO2dCQUFFLElBQUksQ0FBQ3lDLEtBQUssUUFBUXhDLENBQUMsQ0FBQyxTQUFTLElBQUtzQyxDQUFBQSxJQUFJdEMsQ0FBQyxDQUFDLFNBQVMsSUFBSUMsT0FBT3FDLE9BQU9BLENBQUFBLEdBQUk7WUFBUSxTQUFVO2dCQUFFLElBQUk5QyxHQUFHLE1BQU02QztZQUFHO1FBQUU7UUFBRSxPQUFPRTtJQUFHO0FBQUU7QUFDemhCLFNBQVNQLGdCQUFnQkQsR0FBRztJQUFJLElBQUlZLE1BQU1DLE9BQU8sQ0FBQ2IsTUFBTSxPQUFPQTtBQUFLO0FBQ3BFLFNBQVNjLG1CQUFtQmQsR0FBRztJQUFJLE9BQU9lLG1CQUFtQmYsUUFBUWdCLGlCQUFpQmhCLFFBQVFHLDRCQUE0QkgsUUFBUWlCO0FBQXNCO0FBQ3hKLFNBQVNBO0lBQXVCLE1BQU0sSUFBSXJCLFVBQVU7QUFBeUk7QUFDN0wsU0FBU08sNEJBQTRCMUMsQ0FBQyxFQUFFeUQsTUFBTTtJQUFJLElBQUksQ0FBQ3pELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPMEQsa0JBQWtCMUQsR0FBR3lEO0lBQVMsSUFBSVosSUFBSXBDLE9BQU9MLFNBQVMsQ0FBQ3VELFFBQVEsQ0FBQ3pCLElBQUksQ0FBQ2xDLEdBQUc0RCxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSWYsTUFBTSxZQUFZN0MsRUFBRUcsV0FBVyxFQUFFMEMsSUFBSTdDLEVBQUVHLFdBQVcsQ0FBQzBELElBQUk7SUFBRSxJQUFJaEIsTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT00sTUFBTVcsSUFBSSxDQUFDOUQ7SUFBSSxJQUFJNkMsTUFBTSxlQUFlLDJDQUEyQ2tCLElBQUksQ0FBQ2xCLElBQUksT0FBT2Esa0JBQWtCMUQsR0FBR3lEO0FBQVM7QUFDL1osU0FBU0YsaUJBQWlCUyxJQUFJO0lBQUksSUFBSSxPQUFPL0QsV0FBVyxlQUFlK0QsSUFBSSxDQUFDL0QsT0FBT0MsUUFBUSxDQUFDLElBQUksUUFBUThELElBQUksQ0FBQyxhQUFhLElBQUksTUFBTSxPQUFPYixNQUFNVyxJQUFJLENBQUNFO0FBQU87QUFDN0osU0FBU1YsbUJBQW1CZixHQUFHO0lBQUksSUFBSVksTUFBTUMsT0FBTyxDQUFDYixNQUFNLE9BQU9tQixrQkFBa0JuQjtBQUFNO0FBQzFGLFNBQVNtQixrQkFBa0JuQixHQUFHLEVBQUUwQixHQUFHO0lBQUksSUFBSUEsT0FBTyxRQUFRQSxNQUFNMUIsSUFBSXBCLE1BQU0sRUFBRThDLE1BQU0xQixJQUFJcEIsTUFBTTtJQUFFLElBQUssSUFBSVksSUFBSSxHQUFHbUMsT0FBTyxJQUFJZixNQUFNYyxNQUFNbEMsSUFBSWtDLEtBQUtsQyxJQUFLbUMsSUFBSSxDQUFDbkMsRUFBRSxHQUFHUSxHQUFHLENBQUNSLEVBQUU7SUFBRSxPQUFPbUM7QUFBTTtBQUNsTCxJQUFJQyxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBZ0IsR0FDckNDLGFBQWFGLFNBQVNFLFVBQVU7QUFDbEMsSUFBSUMsWUFBWUYsbUJBQU9BLENBQUMsb0ZBQXFCLEdBQzNDRyxRQUFRRCxVQUFVQyxLQUFLLEVBQ3ZCQyxXQUFXRixVQUFVRSxRQUFRLEVBQzdCQyxZQUFZSCxVQUFVRyxTQUFTO0FBQ2pDLFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTztJQUNuQyxJQUFJQyxXQUFXLEVBQUU7SUFDakIsSUFBSyxJQUFJOUMsSUFBSSxHQUFHYSxJQUFJK0IsUUFBUXhELE1BQU0sRUFBRVksSUFBSWEsR0FBR2IsSUFBSztRQUM5QyxJQUFJK0MsVUFBVUgsT0FBTyxDQUFDNUMsRUFBRTtRQUN4QixJQUFJK0MsUUFBUUQsUUFBUSxFQUFFO1lBQ3BCLElBQUlFLE1BQU1ELFFBQVFELFFBQVEsQ0FBQ0Q7WUFDM0IsSUFBSSxDQUFFRyxDQUFBQSxlQUFlNUIsS0FBSSxHQUFJO2dCQUMzQixNQUFNLElBQUk2QixNQUFNO1lBQ2xCO1lBQ0FILFNBQVM5RCxJQUFJLENBQUNDLEtBQUssQ0FBQzZELFVBQVV4QixtQkFBbUIwQjtRQUNuRDtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNJLFdBQVdKLFFBQVEsRUFBRUssa0JBQWtCLEVBQUVOLE9BQU87SUFDdkQsSUFBSU8sVUFBVSxFQUFFO0lBQ2hCLElBQUssSUFBSXBELElBQUksR0FBR2tDLE1BQU1ZLFNBQVMxRCxNQUFNLEVBQUVZLElBQUlrQyxLQUFLbEMsSUFBSztRQUNuRCxJQUFJcUQsVUFBVVAsUUFBUSxDQUFDOUMsRUFBRTtRQUN6QixJQUFJc0QsV0FBVy9DLGVBQWU4QyxTQUFTLElBQ3JDRSxTQUFTRCxRQUFRLENBQUMsRUFBRSxFQUNwQkUsV0FBV0YsUUFBUSxDQUFDLEVBQUU7UUFDeEIsSUFBSUcsYUFBYUosT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDO1FBQ2hDLElBQUlSLFFBQVFMLEtBQUssQ0FBQ2UsUUFBUUoscUJBQXFCO1lBQzdDLElBQUlPLFNBQVNiLFFBQVFILFNBQVMsQ0FBQ2EsUUFBUUo7WUFDdkMsSUFBSSxPQUFPTSxlQUFlLFlBQVk7Z0JBQ3BDQSxhQUFhQSxXQUFXQztZQUMxQjtZQUNBLElBQUksQ0FBQ0QsV0FBVzdELEtBQUssRUFBRTtnQkFDckIsSUFBSStELFVBQVVwRCxlQUFlbUQsUUFBUTtnQkFDckNELFdBQVc3RCxLQUFLLEdBQUcrRCxPQUFPLENBQUMsRUFBRTtZQUMvQjtZQUNBUCxRQUFRcEUsSUFBSSxDQUFDRSxjQUFjO2dCQUN6QjBFLE1BQU07Z0JBQ05MLFFBQVFBO2dCQUNSTSxRQUFRTDtnQkFDUk0sU0FBU0wsV0FBV0ssT0FBTztnQkFDM0JDLFVBQVVOLFdBQVdNLFFBQVE7WUFDL0IsR0FBR047UUFDTDtJQUNGO0lBQ0EsT0FBT0w7QUFDVDtBQUNBLFNBQVNZLFlBQVliLGtCQUFrQixFQUFFTixPQUFPO0lBQzlDLElBQUlELFVBQVVDLFFBQVFELE9BQU87SUFDN0IsSUFBSXFCLGNBQWNwQixRQUFRb0IsV0FBVztJQUNyQyxJQUFJQyxZQUFZckIsUUFBUXNCLE1BQU07SUFDOUIsSUFBSUM7SUFDSnZCLFFBQVF3QixNQUFNLEdBQUdKO0lBQ2pCcEIsUUFBUUwsS0FBSyxHQUFHQTtJQUNoQkssUUFBUUosUUFBUSxHQUFHQTtJQUNuQkksUUFBUUgsU0FBUyxHQUFHQTtJQUNwQixJQUFJSSxXQUFXSCxZQUFZQyxTQUFTQztJQUNwQyxJQUFJTyxVQUFVRixXQUFXSixVQUFVSyxvQkFBb0JOO0lBQ3ZELElBQUlPLFFBQVFoRSxNQUFNLEdBQUcsR0FBRztRQUN0QixJQUFJa0YsWUFBWTtRQUNoQmxCLFFBQVEvRCxPQUFPLENBQUMsU0FBVW1ELEtBQUs7WUFDN0JBLE1BQU11QixRQUFRLEdBQUd2QixNQUFNdUIsUUFBUSxJQUFJLENBQUN2QixNQUFNNUMsS0FBSyxDQUFDUixNQUFNO1lBQ3RELElBQUksQ0FBQ2tGLGFBQWE5QixNQUFNdUIsUUFBUSxHQUFHTyxVQUFVUCxRQUFRLEVBQUU7Z0JBQ3JETyxZQUFZOUI7WUFDZDtRQUNGO1FBQ0E4QixVQUFVRCxNQUFNLEdBQUdKO1FBQ25CLE9BQU9LLFVBQVVQLFFBQVE7UUFDekJPLFVBQVVKLFNBQVMsR0FBR0E7UUFDdEJJLFVBQVVILE1BQU0sR0FBR0Q7UUFDbkJJLFVBQVVDLEdBQUcsR0FBR3BCO1FBQ2hCLElBQUltQixVQUFVUixPQUFPLEVBQUU7WUFDckJRLFVBQVVSLE9BQU8sQ0FBQ1E7UUFDcEI7UUFDQSxPQUFPQSxVQUFVUixPQUFPO1FBQ3hCLE9BQU9RLFVBQVVmLE1BQU07UUFDdkIsT0FBT2U7SUFDVDtJQUNBLElBQUssSUFBSXRFLElBQUksR0FBR2EsSUFBSStCLFFBQVF4RCxNQUFNLEVBQUVZLElBQUlhLEdBQUdiLElBQUs7UUFDOUMsSUFBSXdFLFdBQVc1QixPQUFPLENBQUM1QyxFQUFFO1FBQ3pCb0UsZUFBZUksU0FBU0MsS0FBSyxDQUFDdEIsb0JBQW9CTjtRQUNsRCxJQUFJdUIsY0FBYztZQUNoQkEsYUFBYUMsTUFBTSxHQUFHSjtZQUN0QkcsYUFBYUYsU0FBUyxHQUFHQTtZQUN6QkUsYUFBYUQsTUFBTSxHQUFHRDtZQUN0QkUsYUFBYUcsR0FBRyxHQUFHcEI7WUFDbkIsT0FBT2lCO1FBQ1Q7SUFDRjtJQUNBLE9BQU87UUFDTFIsTUFBTTtRQUNOaEUsT0FBT3VEO1FBQ1BrQixRQUFRSjtRQUNSQyxXQUFXQTtRQUNYQyxRQUFRRDtJQUNWO0FBQ0Y7QUFDQSxJQUFJUSxTQUFTO0lBQ1hDLFVBQVUsU0FBU0EsU0FBU0MsTUFBTSxFQUFFaEMsT0FBTyxFQUFFQyxPQUFPO1FBQ2xELFNBQVM4QixTQUFTQyxNQUFNLEVBQUUvQixPQUFPO1lBQy9CLE9BQU9ELFFBQVF2RCxPQUFPLENBQUMsU0FBVXdFLE9BQU07Z0JBQ3JDQSxRQUFPYyxRQUFRLENBQUNDLFFBQVEvQjtZQUMxQjtRQUNGO1FBQ0EsT0FBTztZQUNMZ0MsV0FBV0YsU0FBU0MsUUFBUS9CO1FBQzlCO0lBQ0Y7SUFDQTRCLE9BQU8sU0FBU0EsTUFBTUssS0FBSyxFQUFFbEMsT0FBTyxFQUFFQyxPQUFPO1FBQzNDLElBQUlrQyxnQkFBZ0I7UUFDcEIsSUFBSTVCLHFCQUFxQjtRQUN6QixJQUFJYztRQUNKLElBQUllLFlBQVksRUFBRTtRQUNsQixJQUFJQyxjQUFjcEMsUUFBUXFDLGNBQWMsQ0FBQ0MsNEJBQTRCLElBQUksRUFBRTtRQUMzRSxPQUFPTCxNQUFNTSxNQUFNLENBQUMsU0FBU0MsY0FBY1QsTUFBTSxFQUFFVSxLQUFLO1lBQ3RELElBQUlBLE1BQU0xQixJQUFJLEtBQUssYUFBYTtnQkFDOUJtQixnQkFBZ0JPLE1BQU1DLFFBQVEsS0FBSztnQkFDbkMsSUFBSUQsTUFBTUMsUUFBUSxLQUFLLE9BQU87b0JBQzVCMUMsUUFBUTRCLEtBQUssR0FBRyxTQUFVdEIsa0JBQWtCO3dCQUMxQyxPQUFPYSxZQUFZYixvQkFBb0JqRSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBRzJELFVBQVV5QyxRQUFRLENBQUMsR0FBRzs0QkFDekdyQixhQUFhQTs0QkFDYnJCLFNBQVNBO3dCQUNYO29CQUNGO29CQUNBZ0MsT0FBTzVGLElBQUksQ0FBQzZELFFBQVE0QixLQUFLLENBQUNuQyxXQUFXYTtvQkFDckMvQixNQUFNL0MsU0FBUyxDQUFDVyxJQUFJLENBQUNDLEtBQUssQ0FBQzJGLFFBQVFJO29CQUNuQ0EsWUFBWSxFQUFFO2dCQUNoQjtnQkFDQSxJQUFJTSxNQUFNQyxRQUFRLEtBQUssU0FBUztvQkFDOUJQLFlBQVksRUFBRTtvQkFDZGYsY0FBY3FCLE1BQU1qQixNQUFNO2dCQUM1QjtnQkFDQWxCLHFCQUFxQjtnQkFDckIsT0FBT3lCO1lBQ1Q7WUFDQSxJQUFJLENBQUNHLGVBQWU7Z0JBQ2xCSCxPQUFPNUYsSUFBSSxDQUFDc0c7Z0JBQ1osT0FBT1Y7WUFDVDtZQUNBLElBQUlVLE1BQU0xQixJQUFJLEtBQUssYUFBYTBCLE1BQU1DLFFBQVEsS0FBSyxhQUFhO2dCQUM5RCxJQUFJTixZQUFZTyxPQUFPLENBQUNGLE1BQU1HLEdBQUcsTUFBTSxDQUFDLEdBQUc7b0JBQ3pDLE9BQU9iO2dCQUNUO2dCQUNBSSxVQUFVaEcsSUFBSSxDQUFDc0c7Z0JBQ2YsT0FBT1Y7WUFDVDtZQUNBekIsc0JBQXNCbUMsTUFBTTFGLEtBQUs7WUFDakMsT0FBT2dGO1FBQ1QsR0FBRyxFQUFFO0lBQ1A7SUFDQWMsV0FBVyxTQUFTQSxVQUFVQyxVQUFVLEVBQUUvQyxPQUFPLEVBQUVDLE9BQU87UUFDeEQsU0FBUytDLFVBQVVDLFNBQVMsRUFBRUYsVUFBVTtZQUN0QyxPQUFPL0MsUUFBUWtELEdBQUcsQ0FBQyxTQUFVakMsT0FBTTtnQkFDakMsT0FBT0EsUUFBTytCLFNBQVMsQ0FBQ0MsV0FBV0Y7WUFDckM7UUFDRjtRQUNBLElBQUlJLFNBQVMsRUFBRTtRQUNmLFNBQVNDLFdBQVdMLFVBQVUsRUFBRTlDLE9BQU87WUFDckMsT0FBT0QsUUFBUXdDLE1BQU0sQ0FBQyxTQUFVTyxVQUFVLEVBQUU5QixPQUFNO2dCQUNoRCxJQUFJckYsSUFBSXFGLFFBQU82QixTQUFTLENBQUNDLFlBQVl6RyxjQUFjQSxjQUFjLENBQUMsR0FBRzJELFVBQVUsQ0FBQyxHQUFHO29CQUNqRjZDLFdBQVcsU0FBU0EsVUFBVWQsTUFBTSxFQUFFcUIsSUFBSTt3QkFDeEMsT0FBT0QsV0FBV3BCLFFBQVExRixjQUFjQSxjQUFjLENBQUMsR0FBRzJELFVBQVVvRDtvQkFDdEU7b0JBQ0FMLFdBQVdBO2dCQUNiO2dCQUNBLElBQUlwSCxLQUFLLE1BQU07b0JBQ2IsT0FBT21IO2dCQUNUO2dCQUNBLElBQUluSCxFQUFFdUgsTUFBTSxFQUFFO29CQUNaM0UsTUFBTS9DLFNBQVMsQ0FBQ1csSUFBSSxDQUFDQyxLQUFLLENBQUM4RyxRQUFRdkgsRUFBRXVILE1BQU07b0JBQzNDLE9BQU92SCxFQUFFbUgsVUFBVTtnQkFDckI7Z0JBQ0EsT0FBT25IO1lBQ1QsR0FBR21IO1FBQ0w7UUFDQSxPQUFPO1lBQ0xBLFlBQVlLLFdBQVdMLFlBQVk5QztZQUNuQ2tELFFBQVFBO1FBQ1Y7SUFDRjtBQUNGO0FBQ0FsQyxPQUFPcUMsT0FBTyxHQUFHeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanM/NGE4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0Zjg7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vcHJlZml4LW1hdGNoZXIuanNcIiksXG4gIG1hdGNoID0gX3JlcXVpcmUyLm1hdGNoLFxuICBnZXRWYWx1ZSA9IF9yZXF1aXJlMi5nZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzID0gX3JlcXVpcmUyLmdldFZhbHVlcztcbmZ1bmN0aW9uIGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgaWYgKF9tb2R1bGUubWF0Y2hlcnMpIHtcbiAgICAgIHZhciBtbW0gPSBfbW9kdWxlLm1hdGNoZXJzKG9wdGlvbnMpO1xuICAgICAgaWYgKCEobW1tIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZHVsZSBtYXRjaGVyIHJldHVybnMgYSBub24gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBtYXRjaGVycy5wdXNoLmFwcGx5KG1hdGNoZXJzLCBfdG9Db25zdW1hYmxlQXJyYXkobW1tKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVycztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXMobWF0Y2hlcnMsIHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucykge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWF0Y2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJzW2ldO1xuICAgIHZhciBfbWF0Y2hlciA9IF9zbGljZWRUb0FycmF5KG1hdGNoZXIsIDIpLFxuICAgICAgcHJlZml4ID0gX21hdGNoZXJbMF0sXG4gICAgICBfbW9kdWxlMiA9IF9tYXRjaGVyWzFdO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gbWF0Y2hlclsyXSB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXRjaChwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCkpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBvcHRpb25zLmdldFZhbHVlcyhwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCk7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9wZXJ0aWVzLnZhbHVlKSB7XG4gICAgICAgIHZhciBfdmFsdWVzID0gX3NsaWNlZFRvQXJyYXkodmFsdWVzLCAyKTtcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IF92YWx1ZXNbMV07XG4gICAgICB9XG4gICAgICBtYXRjaGVzLnB1c2goX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIG1vZHVsZTogX21vZHVsZTIsXG4gICAgICAgIG9uTWF0Y2g6IHByb3BlcnRpZXMub25NYXRjaCxcbiAgICAgICAgcHJpb3JpdHk6IHByb3BlcnRpZXMucHJpb3JpdHlcbiAgICAgIH0sIHByb3BlcnRpZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBtb2R1bGVQYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXM7XG4gIHZhciBzdGFydE9mZnNldCA9IG9wdGlvbnMuc3RhcnRPZmZzZXQ7XG4gIHZhciBlbmRMaW5kZXggPSBvcHRpb25zLmxJbmRleDtcbiAgdmFyIG1vZHVsZVBhcnNlZDtcbiAgb3B0aW9ucy5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgb3B0aW9ucy5tYXRjaCA9IG1hdGNoO1xuICBvcHRpb25zLmdldFZhbHVlID0gZ2V0VmFsdWU7XG4gIG9wdGlvbnMuZ2V0VmFsdWVzID0gZ2V0VmFsdWVzO1xuICB2YXIgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycyhtb2R1bGVzLCBvcHRpb25zKTtcbiAgdmFyIG1hdGNoZXMgPSBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGJlc3RNYXRjaCA9IG51bGw7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgbWF0Y2gucHJpb3JpdHkgPSBtYXRjaC5wcmlvcml0eSB8fCAtbWF0Y2gudmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKCFiZXN0TWF0Y2ggfHwgbWF0Y2gucHJpb3JpdHkgPiBiZXN0TWF0Y2gucHJpb3JpdHkpIHtcbiAgICAgICAgYmVzdE1hdGNoID0gbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVzdE1hdGNoLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgIGRlbGV0ZSBiZXN0TWF0Y2gucHJpb3JpdHk7XG4gICAgYmVzdE1hdGNoLmVuZExpbmRleCA9IGVuZExpbmRleDtcbiAgICBiZXN0TWF0Y2gubEluZGV4ID0gZW5kTGluZGV4O1xuICAgIGJlc3RNYXRjaC5yYXcgPSBwbGFjZUhvbGRlckNvbnRlbnQ7XG4gICAgaWYgKGJlc3RNYXRjaC5vbk1hdGNoKSB7XG4gICAgICBiZXN0TWF0Y2gub25NYXRjaChiZXN0TWF0Y2gpO1xuICAgIH1cbiAgICBkZWxldGUgYmVzdE1hdGNoLm9uTWF0Y2g7XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5wcmVmaXg7XG4gICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIF9tb2R1bGUzID0gbW9kdWxlc1tpXTtcbiAgICBtb2R1bGVQYXJzZWQgPSBfbW9kdWxlMy5wYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVQYXJzZWQpIHtcbiAgICAgIG1vZHVsZVBhcnNlZC5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgIG1vZHVsZVBhcnNlZC5lbmRMaW5kZXggPSBlbmRMaW5kZXg7XG4gICAgICBtb2R1bGVQYXJzZWQubEluZGV4ID0gZW5kTGluZGV4O1xuICAgICAgbW9kdWxlUGFyc2VkLnJhdyA9IHBsYWNlSG9sZGVyQ29udGVudDtcbiAgICAgIHJldHVybiBtb2R1bGVQYXJzZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBwbGFjZUhvbGRlckNvbnRlbnQsXG4gICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICBlbmRMaW5kZXg6IGVuZExpbmRleCxcbiAgICBsSW5kZXg6IGVuZExpbmRleFxuICB9O1xufVxudmFyIHBhcnNlciA9IHtcbiAgcHJlcGFyc2U6IGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5wcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwcmVwYXJzZWQ6IHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucylcbiAgICB9O1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UobGV4ZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5QbGFjZUhvbGRlciA9IGZhbHNlO1xuICAgIHZhciBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgIHZhciBzdGFydE9mZnNldDtcbiAgICB2YXIgdGFpbFBhcnRzID0gW107XG4gICAgdmFyIGRyb3BwZWRUYWdzID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy5kcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIHx8IFtdO1xuICAgIHJldHVybiBsZXhlZC5yZWR1Y2UoZnVuY3Rpb24gbGV4ZWRUb1BhcnNlZChwYXJzZWQsIHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJkZWxpbWl0ZXJcIikge1xuICAgICAgICBpblBsYWNlSG9sZGVyID0gdG9rZW4ucG9zaXRpb24gPT09IFwic3RhcnRcIjtcbiAgICAgICAgaWYgKHRva2VuLnBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgb3B0aW9ucy5wYXJzZSA9IGZ1bmN0aW9uIChwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVQYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwgdG9rZW4pLCB7fSwge1xuICAgICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgIG1vZHVsZXM6IG1vZHVsZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhcnNlZC5wdXNoKG9wdGlvbnMucGFyc2Uod29yZFRvVXRmOChwbGFjZUhvbGRlckNvbnRlbnQpKSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocGFyc2VkLCB0YWlsUGFydHMpO1xuICAgICAgICAgIHRhaWxQYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdGFpbFBhcnRzID0gW107XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VIb2xkZXJDb250ZW50ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGlmICghaW5QbGFjZUhvbGRlcikge1xuICAgICAgICBwYXJzZWQucHVzaCh0b2tlbik7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJjb250ZW50XCIgfHwgdG9rZW4ucG9zaXRpb24gIT09IFwiaW5zaWRldGFnXCIpIHtcbiAgICAgICAgaWYgKGRyb3BwZWRUYWdzLmluZGV4T2YodG9rZW4udGFnKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxQYXJ0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHBsYWNlSG9sZGVyQ29udGVudCArPSB0b2tlbi52YWx1ZTtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSwgW10pO1xuICB9LFxuICBwb3N0cGFyc2U6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcG9zdHBhcnNlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZnVuY3Rpb24gX3Bvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHBvc3RwYXJzZWQsIG1vZHVsZSkge1xuICAgICAgICB2YXIgciA9IG1vZHVsZS5wb3N0cGFyc2UocG9zdHBhcnNlZCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBwb3N0cGFyc2U6IGZ1bmN0aW9uIHBvc3RwYXJzZShwYXJzZWQsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcG9zdHBhcnNlKHBhcnNlZCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwgb3B0cykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0VHJhaXRzOiBnZXRUcmFpdHNcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIuZXJyb3JzKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZXJyb3JzLCByLmVycm9ycyk7XG4gICAgICAgICAgcmV0dXJuIHIucG9zdHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sIHBvc3RwYXJzZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zdHBhcnNlZDogX3Bvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSxcbiAgICAgIGVycm9yczogZXJyb3JzXG4gICAgfTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibCIsIm4iLCJ1IiwiYSIsImYiLCJuZXh0IiwiZG9uZSIsIkFycmF5IiwiaXNBcnJheSIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJpdGVyIiwibGVuIiwiYXJyMiIsIl9yZXF1aXJlIiwicmVxdWlyZSIsIndvcmRUb1V0ZjgiLCJfcmVxdWlyZTIiLCJtYXRjaCIsImdldFZhbHVlIiwiZ2V0VmFsdWVzIiwiZ2V0TWF0Y2hlcnMiLCJtb2R1bGVzIiwib3B0aW9ucyIsIm1hdGNoZXJzIiwiX21vZHVsZSIsIm1tbSIsIkVycm9yIiwiZ2V0TWF0Y2hlcyIsInBsYWNlSG9sZGVyQ29udGVudCIsIm1hdGNoZXMiLCJtYXRjaGVyIiwiX21hdGNoZXIiLCJwcmVmaXgiLCJfbW9kdWxlMiIsInByb3BlcnRpZXMiLCJ2YWx1ZXMiLCJfdmFsdWVzIiwidHlwZSIsIm1vZHVsZSIsIm9uTWF0Y2giLCJwcmlvcml0eSIsIm1vZHVsZVBhcnNlIiwic3RhcnRPZmZzZXQiLCJlbmRMaW5kZXgiLCJsSW5kZXgiLCJtb2R1bGVQYXJzZWQiLCJvZmZzZXQiLCJiZXN0TWF0Y2giLCJyYXciLCJfbW9kdWxlMyIsInBhcnNlIiwicGFyc2VyIiwicHJlcGFyc2UiLCJwYXJzZWQiLCJwcmVwYXJzZWQiLCJsZXhlZCIsImluUGxhY2VIb2xkZXIiLCJ0YWlsUGFydHMiLCJkcm9wcGVkVGFncyIsImZpbGVUeXBlQ29uZmlnIiwiZHJvcHBlZFRhZ3NJbnNpZGVQbGFjZWhvbGRlciIsInJlZHVjZSIsImxleGVkVG9QYXJzZWQiLCJ0b2tlbiIsInBvc2l0aW9uIiwiaW5kZXhPZiIsInRhZyIsInBvc3RwYXJzZSIsInBvc3RwYXJzZWQiLCJnZXRUcmFpdHMiLCJ0cmFpdE5hbWUiLCJtYXAiLCJlcnJvcnMiLCJfcG9zdHBhcnNlIiwib3B0cyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/postrender.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/postrender.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n// convert string to array (typed, when possible)\n// Stryker disable all : because this is a utility function that was copied\n// from\n// https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n// eslint-disable-next-line complexity\nfunction string2buf(str) {\n    var c, c2, mPos, i, bufLen = 0;\n    var strLen = str.length;\n    // count binary size\n    for(mPos = 0; mPos < strLen; mPos++){\n        c = str.charCodeAt(mPos);\n        if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n            c2 = str.charCodeAt(mPos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                mPos++;\n            }\n        }\n        bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    var buf = new Uint8Array(bufLen);\n    // convert\n    for(i = 0, mPos = 0; i < bufLen; mPos++){\n        c = str.charCodeAt(mPos);\n        if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n            c2 = str.charCodeAt(mPos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                mPos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xc0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xe0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n}\n// Stryker restore all\nfunction postrender(parts, options) {\n    for(var i = 0, l = options.modules.length; i < l; i++){\n        var _module = options.modules[i];\n        parts = _module.postrender(parts, options);\n    }\n    var fullLength = 0;\n    var newParts = options.joinUncorrupt(parts, options);\n    var longStr = \"\";\n    var lenStr = 0;\n    var maxCompact = 65536;\n    var uintArrays = [];\n    for(var _i = 0, len = newParts.length; _i < len; _i++){\n        var part = newParts[_i];\n        // This condition should be hit in the integration test at :\n        // it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n        // Stryker disable all : because this is an optimisation that won't make any tests fail\n        if (part.length + lenStr > maxCompact) {\n            var _arr = string2buf(longStr);\n            fullLength += _arr.length;\n            uintArrays.push(_arr);\n            longStr = \"\";\n        }\n        // Stryker restore all\n        longStr += part;\n        lenStr += part.length;\n        delete newParts[_i];\n    }\n    var arr = string2buf(longStr);\n    fullLength += arr.length;\n    uintArrays.push(arr);\n    var array = new Uint8Array(fullLength);\n    var j = 0;\n    // Stryker disable all : because this is an optimisation that won't make any tests fail\n    uintArrays.forEach(function(buf) {\n        for(var _i2 = 0; _i2 < buf.length; ++_i2){\n            array[_i2 + j] = buf[_i2];\n        }\n        j += buf.length;\n    });\n    // Stryker restore all\n    return array;\n}\nmodule.exports = postrender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsaURBQWlEO0FBQ2pELDJFQUEyRTtBQUMzRSxPQUFPO0FBQ1AsOEdBQThHO0FBQzlHLHNDQUFzQztBQUN0QyxTQUFTQSxXQUFXQyxHQUFHO0lBQ3JCLElBQUlDLEdBQ0ZDLElBQ0FDLE1BQ0FDLEdBQ0FDLFNBQVM7SUFDWCxJQUFJQyxTQUFTTixJQUFJTyxNQUFNO0lBRXZCLG9CQUFvQjtJQUNwQixJQUFLSixPQUFPLEdBQUdBLE9BQU9HLFFBQVFILE9BQVE7UUFDcENGLElBQUlELElBQUlRLFVBQVUsQ0FBQ0w7UUFDbkIsSUFBSSxDQUFDRixJQUFJLE1BQUssTUFBTyxVQUFVRSxPQUFPLElBQUlHLFFBQVE7WUFDaERKLEtBQUtGLElBQUlRLFVBQVUsQ0FBQ0wsT0FBTztZQUMzQixJQUFJLENBQUNELEtBQUssTUFBSyxNQUFPLFFBQVE7Z0JBQzVCRCxJQUFJLFVBQVdBLENBQUFBLElBQUksVUFBVSxFQUFDLElBQU1DLENBQUFBLEtBQUssTUFBSztnQkFDOUNDO1lBQ0Y7UUFDRjtRQUNBRSxVQUFVSixJQUFJLE9BQU8sSUFBSUEsSUFBSSxRQUFRLElBQUlBLElBQUksVUFBVSxJQUFJO0lBQzdEO0lBRUEsa0JBQWtCO0lBQ2xCLElBQUlRLE1BQU0sSUFBSUMsV0FBV0w7SUFFekIsVUFBVTtJQUNWLElBQUtELElBQUksR0FBR0QsT0FBTyxHQUFHQyxJQUFJQyxRQUFRRixPQUFRO1FBQ3hDRixJQUFJRCxJQUFJUSxVQUFVLENBQUNMO1FBQ25CLElBQUksQ0FBQ0YsSUFBSSxNQUFLLE1BQU8sVUFBVUUsT0FBTyxJQUFJRyxRQUFRO1lBQ2hESixLQUFLRixJQUFJUSxVQUFVLENBQUNMLE9BQU87WUFDM0IsSUFBSSxDQUFDRCxLQUFLLE1BQUssTUFBTyxRQUFRO2dCQUM1QkQsSUFBSSxVQUFXQSxDQUFBQSxJQUFJLFVBQVUsRUFBQyxJQUFNQyxDQUFBQSxLQUFLLE1BQUs7Z0JBQzlDQztZQUNGO1FBQ0Y7UUFDQSxJQUFJRixJQUFJLE1BQU07WUFDWixZQUFZLEdBQ1pRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHSDtRQUNiLE9BQU8sSUFBSUEsSUFBSSxPQUFPO1lBQ3BCLGFBQWEsR0FDYlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsTUFBTTtZQUN4QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QixPQUFPLElBQUlBLElBQUksU0FBUztZQUN0QixlQUFlLEdBQ2ZRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU07WUFDeEJRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU0sSUFBSTtZQUM1QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QixPQUFPO1lBQ0wsY0FBYyxHQUNkUSxHQUFHLENBQUNMLElBQUksR0FBRyxPQUFPSCxNQUFNO1lBQ3hCUSxHQUFHLENBQUNMLElBQUksR0FBRyxPQUFPSCxNQUFNLEtBQUs7WUFDN0JRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU0sSUFBSTtZQUM1QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QjtJQUNGO0lBQ0EsT0FBT1E7QUFDVDtBQUNBLHNCQUFzQjtBQUV0QixTQUFTRSxXQUFXQyxLQUFLLEVBQUVDLE9BQU87SUFDaEMsSUFBSyxJQUFJVCxJQUFJLEdBQUdVLElBQUlELFFBQVFFLE9BQU8sQ0FBQ1IsTUFBTSxFQUFFSCxJQUFJVSxHQUFHVixJQUFLO1FBQ3RELElBQUlZLFVBQVVILFFBQVFFLE9BQU8sQ0FBQ1gsRUFBRTtRQUNoQ1EsUUFBUUksUUFBUUwsVUFBVSxDQUFDQyxPQUFPQztJQUNwQztJQUNBLElBQUlJLGFBQWE7SUFDakIsSUFBSUMsV0FBV0wsUUFBUU0sYUFBYSxDQUFDUCxPQUFPQztJQUM1QyxJQUFJTyxVQUFVO0lBQ2QsSUFBSUMsU0FBUztJQUNiLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsYUFBYSxFQUFFO0lBQ25CLElBQUssSUFBSUMsS0FBSyxHQUFHQyxNQUFNUCxTQUFTWCxNQUFNLEVBQUVpQixLQUFLQyxLQUFLRCxLQUFNO1FBQ3RELElBQUlFLE9BQU9SLFFBQVEsQ0FBQ00sR0FBRztRQUV2Qiw0REFBNEQ7UUFDNUQsd0ZBQXdGO1FBQ3hGLHVGQUF1RjtRQUN2RixJQUFJRSxLQUFLbkIsTUFBTSxHQUFHYyxTQUFTQyxZQUFZO1lBQ3JDLElBQUlLLE9BQU81QixXQUFXcUI7WUFDdEJILGNBQWNVLEtBQUtwQixNQUFNO1lBQ3pCZ0IsV0FBV0ssSUFBSSxDQUFDRDtZQUNoQlAsVUFBVTtRQUNaO1FBQ0Esc0JBQXNCO1FBRXRCQSxXQUFXTTtRQUNYTCxVQUFVSyxLQUFLbkIsTUFBTTtRQUNyQixPQUFPVyxRQUFRLENBQUNNLEdBQUc7SUFDckI7SUFDQSxJQUFJSyxNQUFNOUIsV0FBV3FCO0lBQ3JCSCxjQUFjWSxJQUFJdEIsTUFBTTtJQUN4QmdCLFdBQVdLLElBQUksQ0FBQ0M7SUFDaEIsSUFBSUMsUUFBUSxJQUFJcEIsV0FBV087SUFDM0IsSUFBSWMsSUFBSTtJQUVSLHVGQUF1RjtJQUN2RlIsV0FBV1MsT0FBTyxDQUFDLFNBQVV2QixHQUFHO1FBQzlCLElBQUssSUFBSXdCLE1BQU0sR0FBR0EsTUFBTXhCLElBQUlGLE1BQU0sRUFBRSxFQUFFMEIsSUFBSztZQUN6Q0gsS0FBSyxDQUFDRyxNQUFNRixFQUFFLEdBQUd0QixHQUFHLENBQUN3QixJQUFJO1FBQzNCO1FBQ0FGLEtBQUt0QixJQUFJRixNQUFNO0lBQ2pCO0lBQ0Esc0JBQXNCO0lBQ3RCLE9BQU91QjtBQUNUO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcG9zdHJlbmRlci5qcz9kNDlmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG4vLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdhcyBjb3BpZWRcbi8vIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXhtbC10ZW1wbGF0aW5nL3BpenppcC9ibG9iLzM0YTg0MDU1M2M2MDQ5ODA4NTlkYzZkMGRjZDFmODliNmU1NTI3YjMvZXM2L3V0ZjguanMjTDMzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gc3RyaW5nMmJ1ZihzdHIpIHtcbiAgdmFyIGMsXG4gICAgYzIsXG4gICAgbVBvcyxcbiAgICBpLFxuICAgIGJ1ZkxlbiA9IDA7XG4gIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobVBvcyA9IDA7IG1Qb3MgPCBzdHJMZW47IG1Qb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtUG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgbVBvcyArIDEgPCBzdHJMZW4pIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobVBvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArIChjIC0gMHhkODAwIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1Qb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmTGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZMZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbVBvcyA9IDA7IGkgPCBidWZMZW47IG1Qb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtUG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgbVBvcyArIDEgPCBzdHJMZW4pIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobVBvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArIChjIC0gMHhkODAwIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1Qb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhjMCB8IGMgPj4+IDY7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGUwIHwgYyA+Pj4gMTI7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiA2ICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCBjID4+PiAxODtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDEyICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDYgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWY7XG59XG4vLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbmZ1bmN0aW9uIHBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLm1vZHVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBvcHRpb25zLm1vZHVsZXNbaV07XG4gICAgcGFydHMgPSBfbW9kdWxlLnBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBmdWxsTGVuZ3RoID0gMDtcbiAgdmFyIG5ld1BhcnRzID0gb3B0aW9ucy5qb2luVW5jb3JydXB0KHBhcnRzLCBvcHRpb25zKTtcbiAgdmFyIGxvbmdTdHIgPSBcIlwiO1xuICB2YXIgbGVuU3RyID0gMDtcbiAgdmFyIG1heENvbXBhY3QgPSA2NTUzNjtcbiAgdmFyIHVpbnRBcnJheXMgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSAwLCBsZW4gPSBuZXdQYXJ0cy5sZW5ndGg7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBuZXdQYXJ0c1tfaV07XG5cbiAgICAvLyBUaGlzIGNvbmRpdGlvbiBzaG91bGQgYmUgaGl0IGluIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0IGF0IDpcbiAgICAvLyBpdChcInNob3VsZCBub3QgcmVncmVzcyB3aXRoIGxvbmcgZmlsZSAoaGl0IG1heENvbXBhY3QgdmFsdWUgb2YgNjU1MzYpXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvbiB0aGF0IHdvbid0IG1ha2UgYW55IHRlc3RzIGZhaWxcbiAgICBpZiAocGFydC5sZW5ndGggKyBsZW5TdHIgPiBtYXhDb21wYWN0KSB7XG4gICAgICB2YXIgX2FyciA9IHN0cmluZzJidWYobG9uZ1N0cik7XG4gICAgICBmdWxsTGVuZ3RoICs9IF9hcnIubGVuZ3RoO1xuICAgICAgdWludEFycmF5cy5wdXNoKF9hcnIpO1xuICAgICAgbG9uZ1N0ciA9IFwiXCI7XG4gICAgfVxuICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuICAgIGxvbmdTdHIgKz0gcGFydDtcbiAgICBsZW5TdHIgKz0gcGFydC5sZW5ndGg7XG4gICAgZGVsZXRlIG5ld1BhcnRzW19pXTtcbiAgfVxuICB2YXIgYXJyID0gc3RyaW5nMmJ1Zihsb25nU3RyKTtcbiAgZnVsbExlbmd0aCArPSBhcnIubGVuZ3RoO1xuICB1aW50QXJyYXlzLnB1c2goYXJyKTtcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZnVsbExlbmd0aCk7XG4gIHZhciBqID0gMDtcblxuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvbiB0aGF0IHdvbid0IG1ha2UgYW55IHRlc3RzIGZhaWxcbiAgdWludEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChidWYpIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBidWYubGVuZ3RoOyArK19pMikge1xuICAgICAgYXJyYXlbX2kyICsgal0gPSBidWZbX2kyXTtcbiAgICB9XG4gICAgaiArPSBidWYubGVuZ3RoO1xuICB9KTtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICByZXR1cm4gYXJyYXk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RyZW5kZXI7Il0sIm5hbWVzIjpbInN0cmluZzJidWYiLCJzdHIiLCJjIiwiYzIiLCJtUG9zIiwiaSIsImJ1ZkxlbiIsInN0ckxlbiIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJidWYiLCJVaW50OEFycmF5IiwicG9zdHJlbmRlciIsInBhcnRzIiwib3B0aW9ucyIsImwiLCJtb2R1bGVzIiwiX21vZHVsZSIsImZ1bGxMZW5ndGgiLCJuZXdQYXJ0cyIsImpvaW5VbmNvcnJ1cHQiLCJsb25nU3RyIiwibGVuU3RyIiwibWF4Q29tcGFjdCIsInVpbnRBcnJheXMiLCJfaSIsImxlbiIsInBhcnQiLCJfYXJyIiwicHVzaCIsImFyciIsImFycmF5IiwiaiIsImZvckVhY2giLCJfaTIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n    return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n    }\n    if (condition instanceof RegExp) {\n        return condition.test(replaceNbsps(placeHolderContent));\n    }\n    if (type === \"function\") {\n        return !!condition(placeHolderContent);\n    }\n}\nfunction getValue(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return replaceNbsps(placeHolderContent).substr(condition.length);\n    }\n    if (condition instanceof RegExp) {\n        return replaceNbsps(placeHolderContent).match(condition)[1];\n    }\n    if (type === \"function\") {\n        return condition(placeHolderContent);\n    }\n}\nfunction getValues(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return [\n            placeHolderContent,\n            replaceNbsps(placeHolderContent).substr(condition.length)\n        ];\n    }\n    if (condition instanceof RegExp) {\n        return replaceNbsps(placeHolderContent).match(condition);\n    }\n    if (type === \"function\") {\n        return [\n            placeHolderContent,\n            condition(placeHolderContent)\n        ];\n    }\n}\nmodule.exports = {\n    match: match,\n    getValue: getValue,\n    getValues: getValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxJQUFJSyxZQUFZLElBQUlDLE9BQU9DLE9BQU9DLFlBQVksQ0FBQyxNQUFNO0FBQ3JELFNBQVNDLGFBQWFDLEdBQUc7SUFDdkIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDTixXQUFXO0FBQ2hDO0FBQ0EsU0FBU08sTUFBTUMsU0FBUyxFQUFFQyxrQkFBa0I7SUFDMUMsSUFBSUMsT0FBT2hCLFFBQVFjO0lBQ25CLElBQUlFLFNBQVMsVUFBVTtRQUNyQixPQUFPTixhQUFhSyxtQkFBbUJFLE1BQU0sQ0FBQyxHQUFHSCxVQUFVSSxNQUFNLE9BQU9KO0lBQzFFO0lBQ0EsSUFBSUEscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9PLFVBQVVLLElBQUksQ0FBQ1QsYUFBYUs7SUFDckM7SUFDQSxJQUFJQyxTQUFTLFlBQVk7UUFDdkIsT0FBTyxDQUFDLENBQUNGLFVBQVVDO0lBQ3JCO0FBQ0Y7QUFDQSxTQUFTSyxTQUFTTixTQUFTLEVBQUVDLGtCQUFrQjtJQUM3QyxJQUFJQyxPQUFPaEIsUUFBUWM7SUFDbkIsSUFBSUUsU0FBUyxVQUFVO1FBQ3JCLE9BQU9OLGFBQWFLLG9CQUFvQkUsTUFBTSxDQUFDSCxVQUFVSSxNQUFNO0lBQ2pFO0lBQ0EsSUFBSUoscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9HLGFBQWFLLG9CQUFvQkYsS0FBSyxDQUFDQyxVQUFVLENBQUMsRUFBRTtJQUM3RDtJQUNBLElBQUlFLFNBQVMsWUFBWTtRQUN2QixPQUFPRixVQUFVQztJQUNuQjtBQUNGO0FBQ0EsU0FBU00sVUFBVVAsU0FBUyxFQUFFQyxrQkFBa0I7SUFDOUMsSUFBSUMsT0FBT2hCLFFBQVFjO0lBQ25CLElBQUlFLFNBQVMsVUFBVTtRQUNyQixPQUFPO1lBQUNEO1lBQW9CTCxhQUFhSyxvQkFBb0JFLE1BQU0sQ0FBQ0gsVUFBVUksTUFBTTtTQUFFO0lBQ3hGO0lBQ0EsSUFBSUoscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9HLGFBQWFLLG9CQUFvQkYsS0FBSyxDQUFDQztJQUNoRDtJQUNBLElBQUlFLFNBQVMsWUFBWTtRQUN2QixPQUFPO1lBQUNEO1lBQW9CRCxVQUFVQztTQUFvQjtJQUM1RDtBQUNGO0FBQ0FPLE9BQU9DLE9BQU8sR0FBRztJQUNmVixPQUFPQTtJQUNQTyxVQUFVQTtJQUNWQyxXQUFXQTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcHJlZml4LW1hdGNoZXIuanM/NzM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxudmFyIG5ic3BSZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLCBcImdcIik7XG5mdW5jdGlvbiByZXBsYWNlTmJzcHMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuYnNwUmVnZXgsIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoKGNvbmRpdGlvbiwgcGxhY2VIb2xkZXJDb250ZW50KSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZihjb25kaXRpb24pO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50LnN1YnN0cigwLCBjb25kaXRpb24ubGVuZ3RoKSkgPT09IGNvbmRpdGlvbjtcbiAgfVxuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbi50ZXN0KHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuICEhY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGNvbmRpdGlvbiwgcGxhY2VIb2xkZXJDb250ZW50KSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZihjb25kaXRpb24pO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5zdWJzdHIoY29uZGl0aW9uLmxlbmd0aCk7XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5tYXRjaChjb25kaXRpb24pWzFdO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyhjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3BsYWNlSG9sZGVyQ29udGVudCwgcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkuc3Vic3RyKGNvbmRpdGlvbi5sZW5ndGgpXTtcbiAgfVxuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLm1hdGNoKGNvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBbcGxhY2VIb2xkZXJDb250ZW50LCBjb25kaXRpb24ocGxhY2VIb2xkZXJDb250ZW50KV07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXRjaDogbWF0Y2gsXG4gIGdldFZhbHVlOiBnZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzOiBnZXRWYWx1ZXNcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm5ic3BSZWdleCIsIlJlZ0V4cCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlcGxhY2VOYnNwcyIsInN0ciIsInJlcGxhY2UiLCJtYXRjaCIsImNvbmRpdGlvbiIsInBsYWNlSG9sZGVyQ29udGVudCIsInR5cGUiLCJzdWJzdHIiLCJsZW5ndGgiLCJ0ZXN0IiwiZ2V0VmFsdWUiLCJnZXRWYWx1ZXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/render.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/render.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), throwUnimplementedTagType = _require.throwUnimplementedTagType, XTScopeParserError = _require.XTScopeParserError;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n    var moduleRendered;\n    for(var i = 0, l = options.modules.length; i < l; i++){\n        var _module = options.modules[i];\n        moduleRendered = _module.render(part, options);\n        if (moduleRendered) {\n            return moduleRendered;\n        }\n    }\n    return false;\n}\nfunction render(options) {\n    var baseNullGetter = options.baseNullGetter;\n    var compiled = options.compiled, scopeManager = options.scopeManager;\n    options.nullGetter = function(part, sm) {\n        return baseNullGetter(part, sm || scopeManager);\n    };\n    var errors = [];\n    var parts = compiled.map(function(part, i) {\n        options.index = i;\n        options.resolvedId = getResolvedId(part, options);\n        var moduleRendered;\n        try {\n            moduleRendered = moduleRender(part, options);\n        } catch (e) {\n            if (e instanceof XTScopeParserError) {\n                errors.push(e);\n                return part;\n            }\n            throw e;\n        }\n        if (moduleRendered) {\n            if (moduleRendered.errors) {\n                Array.prototype.push.apply(errors, moduleRendered.errors);\n            }\n            return moduleRendered;\n        }\n        if (part.type === \"content\" || part.type === \"tag\") {\n            return part;\n        }\n        throwUnimplementedTagType(part, i);\n    }).reduce(function(parts, _ref) {\n        var value = _ref.value;\n        if (value instanceof Array) {\n            for(var i = 0, len = value.length; i < len; i++){\n                parts.push(value[i]);\n            }\n        } else if (value) {\n            parts.push(value);\n        }\n        return parts;\n    }, []);\n    return {\n        errors: errors,\n        parts: parts\n    };\n}\nmodule.exports = render;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyxvRUFBYSxHQUNsQ0MsNEJBQTRCRixTQUFTRSx5QkFBeUIsRUFDOURDLHFCQUFxQkgsU0FBU0csa0JBQWtCO0FBQ2xELElBQUlDLGdCQUFnQkgsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQ2xELFNBQVNJLGFBQWFDLElBQUksRUFBRUMsT0FBTztJQUNqQyxJQUFJQztJQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJSCxRQUFRSSxPQUFPLENBQUNDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztRQUN0RCxJQUFJSSxVQUFVTixRQUFRSSxPQUFPLENBQUNGLEVBQUU7UUFDaENELGlCQUFpQkssUUFBUUMsTUFBTSxDQUFDUixNQUFNQztRQUN0QyxJQUFJQyxnQkFBZ0I7WUFDbEIsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU00sT0FBT1AsT0FBTztJQUNyQixJQUFJUSxpQkFBaUJSLFFBQVFRLGNBQWM7SUFDM0MsSUFBSUMsV0FBV1QsUUFBUVMsUUFBUSxFQUM3QkMsZUFBZVYsUUFBUVUsWUFBWTtJQUNyQ1YsUUFBUVcsVUFBVSxHQUFHLFNBQVVaLElBQUksRUFBRWEsRUFBRTtRQUNyQyxPQUFPSixlQUFlVCxNQUFNYSxNQUFNRjtJQUNwQztJQUNBLElBQUlHLFNBQVMsRUFBRTtJQUNmLElBQUlDLFFBQVFMLFNBQVNNLEdBQUcsQ0FBQyxTQUFVaEIsSUFBSSxFQUFFRyxDQUFDO1FBQ3hDRixRQUFRZ0IsS0FBSyxHQUFHZDtRQUNoQkYsUUFBUWlCLFVBQVUsR0FBR3BCLGNBQWNFLE1BQU1DO1FBQ3pDLElBQUlDO1FBQ0osSUFBSTtZQUNGQSxpQkFBaUJILGFBQWFDLE1BQU1DO1FBQ3RDLEVBQUUsT0FBT2tCLEdBQUc7WUFDVixJQUFJQSxhQUFhdEIsb0JBQW9CO2dCQUNuQ2lCLE9BQU9NLElBQUksQ0FBQ0Q7Z0JBQ1osT0FBT25CO1lBQ1Q7WUFDQSxNQUFNbUI7UUFDUjtRQUNBLElBQUlqQixnQkFBZ0I7WUFDbEIsSUFBSUEsZUFBZVksTUFBTSxFQUFFO2dCQUN6Qk8sTUFBTUMsU0FBUyxDQUFDRixJQUFJLENBQUNHLEtBQUssQ0FBQ1QsUUFBUVosZUFBZVksTUFBTTtZQUMxRDtZQUNBLE9BQU9aO1FBQ1Q7UUFDQSxJQUFJRixLQUFLd0IsSUFBSSxLQUFLLGFBQWF4QixLQUFLd0IsSUFBSSxLQUFLLE9BQU87WUFDbEQsT0FBT3hCO1FBQ1Q7UUFDQUosMEJBQTBCSSxNQUFNRztJQUNsQyxHQUFHc0IsTUFBTSxDQUFDLFNBQVVWLEtBQUssRUFBRVcsSUFBSTtRQUM3QixJQUFJQyxRQUFRRCxLQUFLQyxLQUFLO1FBQ3RCLElBQUlBLGlCQUFpQk4sT0FBTztZQUMxQixJQUFLLElBQUlsQixJQUFJLEdBQUd5QixNQUFNRCxNQUFNckIsTUFBTSxFQUFFSCxJQUFJeUIsS0FBS3pCLElBQUs7Z0JBQ2hEWSxNQUFNSyxJQUFJLENBQUNPLEtBQUssQ0FBQ3hCLEVBQUU7WUFDckI7UUFDRixPQUFPLElBQUl3QixPQUFPO1lBQ2hCWixNQUFNSyxJQUFJLENBQUNPO1FBQ2I7UUFDQSxPQUFPWjtJQUNULEdBQUcsRUFBRTtJQUNMLE9BQU87UUFDTEQsUUFBUUE7UUFDUkMsT0FBT0E7SUFDVDtBQUNGO0FBQ0FjLE9BQU9DLE9BQU8sR0FBR3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzP2Y4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSA9IF9yZXF1aXJlLnRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUsXG4gIFhUU2NvcGVQYXJzZXJFcnJvciA9IF9yZXF1aXJlLlhUU2NvcGVQYXJzZXJFcnJvcjtcbnZhciBnZXRSZXNvbHZlZElkID0gcmVxdWlyZShcIi4vZ2V0LXJlc29sdmVkLWlkLmpzXCIpO1xuZnVuY3Rpb24gbW9kdWxlUmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZVJlbmRlcmVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IG9wdGlvbnMubW9kdWxlc1tpXTtcbiAgICBtb2R1bGVSZW5kZXJlZCA9IF9tb2R1bGUucmVuZGVyKHBhcnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVSZW5kZXJlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVJlbmRlcmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW5kZXIob3B0aW9ucykge1xuICB2YXIgYmFzZU51bGxHZXR0ZXIgPSBvcHRpb25zLmJhc2VOdWxsR2V0dGVyO1xuICB2YXIgY29tcGlsZWQgPSBvcHRpb25zLmNvbXBpbGVkLFxuICAgIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyO1xuICBvcHRpb25zLm51bGxHZXR0ZXIgPSBmdW5jdGlvbiAocGFydCwgc20pIHtcbiAgICByZXR1cm4gYmFzZU51bGxHZXR0ZXIocGFydCwgc20gfHwgc2NvcGVNYW5hZ2VyKTtcbiAgfTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFydHMgPSBjb21waWxlZC5tYXAoZnVuY3Rpb24gKHBhcnQsIGkpIHtcbiAgICBvcHRpb25zLmluZGV4ID0gaTtcbiAgICBvcHRpb25zLnJlc29sdmVkSWQgPSBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpO1xuICAgIHZhciBtb2R1bGVSZW5kZXJlZDtcbiAgICB0cnkge1xuICAgICAgbW9kdWxlUmVuZGVyZWQgPSBtb2R1bGVSZW5kZXIocGFydCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYVFNjb3BlUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZVJlbmRlcmVkKSB7XG4gICAgICBpZiAobW9kdWxlUmVuZGVyZWQuZXJyb3JzKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVycm9ycywgbW9kdWxlUmVuZGVyZWQuZXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2R1bGVSZW5kZXJlZDtcbiAgICB9XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIgfHwgcGFydC50eXBlID09PSBcInRhZ1wiKSB7XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG4gICAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZShwYXJ0LCBpKTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChwYXJ0cywgX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgcGFydHM6IHBhcnRzXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcjsiXSwibmFtZXMiOlsiX3JlcXVpcmUiLCJyZXF1aXJlIiwidGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSIsIlhUU2NvcGVQYXJzZXJFcnJvciIsImdldFJlc29sdmVkSWQiLCJtb2R1bGVSZW5kZXIiLCJwYXJ0Iiwib3B0aW9ucyIsIm1vZHVsZVJlbmRlcmVkIiwiaSIsImwiLCJtb2R1bGVzIiwibGVuZ3RoIiwiX21vZHVsZSIsInJlbmRlciIsImJhc2VOdWxsR2V0dGVyIiwiY29tcGlsZWQiLCJzY29wZU1hbmFnZXIiLCJudWxsR2V0dGVyIiwic20iLCJlcnJvcnMiLCJwYXJ0cyIsIm1hcCIsImluZGV4IiwicmVzb2x2ZWRJZCIsImUiLCJwdXNoIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInR5cGUiLCJyZWR1Y2UiLCJfcmVmIiwidmFsdWUiLCJsZW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/resolve.js":
/*!**************************************************!*\
  !*** ./node_modules/docxtemplater/js/resolve.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n    var moduleResolved;\n    for(var i = 0, l = options.modules.length; i < l; i++){\n        var _module = options.modules[i];\n        moduleResolved = _module.resolve(part, options);\n        if (moduleResolved) {\n            return moduleResolved;\n        }\n    }\n    return false;\n}\nfunction resolve(options) {\n    var resolved = [];\n    var baseNullGetter = options.baseNullGetter;\n    var compiled = options.compiled, scopeManager = options.scopeManager;\n    options.nullGetter = function(part, sm) {\n        return baseNullGetter(part, sm || scopeManager);\n    };\n    options.resolved = resolved;\n    var errors = [];\n    return Promise.all(compiled.filter(function(part) {\n        return [\n            \"content\",\n            \"tag\"\n        ].indexOf(part.type) === -1;\n    }).reduce(function(promises, part) {\n        var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n            resolvedId: getResolvedId(part, options)\n        }));\n        var result;\n        if (moduleResolved) {\n            result = moduleResolved.then(function(value) {\n                resolved.push({\n                    tag: part.value,\n                    lIndex: part.lIndex,\n                    value: value\n                });\n            });\n        } else if (part.type === \"placeholder\") {\n            result = scopeManager.getValueAsync(part.value, {\n                part: part\n            }).then(function(value) {\n                return value == null ? options.nullGetter(part) : value;\n            }).then(function(value) {\n                resolved.push({\n                    tag: part.value,\n                    lIndex: part.lIndex,\n                    value: value\n                });\n                return value;\n            });\n        } else {\n            return;\n        }\n        promises.push(result[\"catch\"](function(e) {\n            if (e instanceof Array) {\n                errors.push.apply(errors, _toConsumableArray(e));\n            } else {\n                errors.push(e);\n            }\n        }));\n        return promises;\n    }, [])).then(function() {\n        return {\n            errors: errors,\n            resolved: resolved\n        };\n    });\n}\nmodule.exports = resolve;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLG1CQUFtQkMsR0FBRztJQUFJLE9BQU9DLG1CQUFtQkQsUUFBUUUsaUJBQWlCRixRQUFRRyw0QkFBNEJILFFBQVFJO0FBQXNCO0FBQ3hKLFNBQVNBO0lBQXVCLE1BQU0sSUFBSUMsVUFBVTtBQUF5STtBQUM3TCxTQUFTRiw0QkFBNEJULENBQUMsRUFBRVksTUFBTTtJQUFJLElBQUksQ0FBQ1osR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9hLGtCQUFrQmIsR0FBR1k7SUFBUyxJQUFJRSxJQUFJQyxPQUFPWCxTQUFTLENBQUNZLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDakIsR0FBR2tCLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJSixNQUFNLFlBQVlkLEVBQUVHLFdBQVcsRUFBRVcsSUFBSWQsRUFBRUcsV0FBVyxDQUFDZ0IsSUFBSTtJQUFFLElBQUlMLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9NLE1BQU1DLElBQUksQ0FBQ3JCO0lBQUksSUFBSWMsTUFBTSxlQUFlLDJDQUEyQ1EsSUFBSSxDQUFDUixJQUFJLE9BQU9ELGtCQUFrQmIsR0FBR1k7QUFBUztBQUMvWixTQUFTSixpQkFBaUJlLElBQUk7SUFBSSxJQUFJLE9BQU90QixXQUFXLGVBQWVzQixJQUFJLENB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U25CLGVBQWVvQixJQUFJLENBQUMsU0FBVWpDLEtBQUs7Z0JBQzFDa0IsU0FBUzdCLElBQUksQ0FBQztvQkFDWjZDLEtBQUt2QixLQUFLWCxLQUFLO29CQUNmbUMsUUFBUXhCLEtBQUt3QixNQUFNO29CQUNuQm5DLE9BQU9BO2dCQUNUO1lBQ0Y7UUFDRixPQUFPLElBQUlXLEtBQUtpQixJQUFJLEtBQUssZUFBZTtZQUN0Q0ksU0FBU1gsYUFBYWUsYUFBYSxDQUFDekIsS0FBS1gsS0FBSyxFQUFFO2dCQUM5Q1csTUFBTUE7WUFDUixHQUFHc0IsSUFBSSxDQUFDLFNBQVVqQyxLQUFLO2dCQUNyQixPQUFPQSxTQUFTLE9BQU9ZLFFBQVFVLFVBQVUsQ0FBQ1gsUUFBUVg7WUFDcEQsR0FBR2lDLElBQUksQ0FBQyxTQUFVakMsS0FBSztnQkFDckJrQixTQUFTN0IsSUFBSSxDQUFDO29CQUNaNkMsS0FBS3ZCLEtBQUtYLEtBQUs7b0JBQ2ZtQyxRQUFReEIsS0FBS3dCLE1BQU07b0JBQ25CbkMsT0FBT0E7Z0JBQ1Q7Z0JBQ0EsT0FBT0E7WUFDVDtRQUNGLE9BQU87WUFDTDtRQUNGO1FBQ0E4QixTQUFTekMsSUFBSSxDQUFDMkMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFVbkQsQ0FBQztZQUN2QyxJQUFJQSxhQUFhVixPQUFPO2dCQUN0QnFELE9BQU9uQyxJQUFJLENBQUNDLEtBQUssQ0FBQ2tDLFFBQVFwRSxtQkFBbUJ5QjtZQUMvQyxPQUFPO2dCQUNMMkMsT0FBT25DLElBQUksQ0FBQ1I7WUFDZDtRQUNGO1FBQ0EsT0FBT2lEO0lBQ1QsR0FBRyxFQUFFLEdBQUdHLElBQUksQ0FBQztRQUNYLE9BQU87WUFDTFQsUUFBUUE7WUFDUk4sVUFBVUE7UUFDWjtJQUNGO0FBQ0Y7QUFDQW1CLE9BQU9DLE9BQU8sR0FBR3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVzb2x2ZS5qcz9lYzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBnZXRSZXNvbHZlZElkID0gcmVxdWlyZShcIi4vZ2V0LXJlc29sdmVkLWlkLmpzXCIpO1xuZnVuY3Rpb24gbW9kdWxlUmVzb2x2ZShwYXJ0LCBvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVSZXNvbHZlZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLm1vZHVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBvcHRpb25zLm1vZHVsZXNbaV07XG4gICAgbW9kdWxlUmVzb2x2ZWQgPSBfbW9kdWxlLnJlc29sdmUocGFydCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVJlc29sdmVkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlUmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUob3B0aW9ucykge1xuICB2YXIgcmVzb2x2ZWQgPSBbXTtcbiAgdmFyIGJhc2VOdWxsR2V0dGVyID0gb3B0aW9ucy5iYXNlTnVsbEdldHRlcjtcbiAgdmFyIGNvbXBpbGVkID0gb3B0aW9ucy5jb21waWxlZCxcbiAgICBzY29wZU1hbmFnZXIgPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgb3B0aW9ucy5udWxsR2V0dGVyID0gZnVuY3Rpb24gKHBhcnQsIHNtKSB7XG4gICAgcmV0dXJuIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtIHx8IHNjb3BlTWFuYWdlcik7XG4gIH07XG4gIG9wdGlvbnMucmVzb2x2ZWQgPSByZXNvbHZlZDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoY29tcGlsZWQuZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIFtcImNvbnRlbnRcIiwgXCJ0YWdcIl0uaW5kZXhPZihwYXJ0LnR5cGUpID09PSAtMTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChwcm9taXNlcywgcGFydCkge1xuICAgIHZhciBtb2R1bGVSZXNvbHZlZCA9IG1vZHVsZVJlc29sdmUocGFydCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIHJlc29sdmVkSWQ6IGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucylcbiAgICB9KSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobW9kdWxlUmVzb2x2ZWQpIHtcbiAgICAgIHJlc3VsdCA9IG1vZHVsZVJlc29sdmVkLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmVkLnB1c2goe1xuICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICBsSW5kZXg6IHBhcnQubEluZGV4LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIHJlc3VsdCA9IHNjb3BlTWFuYWdlci5nZXRWYWx1ZUFzeW5jKHBhcnQudmFsdWUsIHtcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBvcHRpb25zLm51bGxHZXR0ZXIocGFydCkgOiB2YWx1ZTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmVkLnB1c2goe1xuICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICBsSW5kZXg6IHBhcnQubEluZGV4LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvbWlzZXMucHVzaChyZXN1bHRbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHByb21pc2VzO1xuICB9LCBbXSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIHJlc29sdmVkOiByZXNvbHZlZFxuICAgIH07XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpc0FycmF5IiwibGVuIiwibGVuZ3RoIiwiaSIsImFycjIiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsImdldFJlc29sdmVkSWQiLCJyZXF1aXJlIiwibW9kdWxlUmVzb2x2ZSIsInBhcnQiLCJvcHRpb25zIiwibW9kdWxlUmVzb2x2ZWQiLCJsIiwibW9kdWxlcyIsIl9tb2R1bGUiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJiYXNlTnVsbEdldHRlciIsImNvbXBpbGVkIiwic2NvcGVNYW5hZ2VyIiwibnVsbEdldHRlciIsInNtIiwiZXJyb3JzIiwiUHJvbWlzZSIsImFsbCIsImluZGV4T2YiLCJ0eXBlIiwicmVkdWNlIiwicHJvbWlzZXMiLCJyZXNvbHZlZElkIiwicmVzdWx0IiwidGhlbiIsInRhZyIsImxJbmRleCIsImdldFZhbHVlQXN5bmMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/scope-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"), last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n    var length = list.length >>> 0;\n    var value;\n    for(var i = 0; i < length; i++){\n        value = list[i];\n        if (fn.call(this, value, i, list)) {\n            return value;\n        }\n    }\n    return undefined;\n}\nfunction _getValue(tag, meta, num) {\n    var _this = this;\n    var scope = this.scopeList[num];\n    if (this.root.finishedResolving) {\n        var w = this.resolved;\n        var _loop = function _loop() {\n            var lIndex = _this.scopeLindex[i];\n            w = find(w, function(r) {\n                return r.lIndex === lIndex;\n            });\n            w = w.value[_this.scopePathItem[i]];\n        };\n        for(var i = this.resolveOffset, len = this.scopePath.length; i < len; i++){\n            _loop();\n        }\n        return find(w, function(r) {\n            return meta.part.lIndex === r.lIndex;\n        }).value;\n    }\n    // search in the scopes (in reverse order) and keep the first defined value\n    var result;\n    var parser;\n    if (!this.cachedParsers || !meta.part) {\n        parser = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    } else if (this.cachedParsers[meta.part.lIndex]) {\n        parser = this.cachedParsers[meta.part.lIndex];\n    } else {\n        parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    }\n    try {\n        result = parser.get(scope, this.getContext(meta, num));\n    } catch (error) {\n        throw getScopeParserExecutionError({\n            tag: tag,\n            scope: scope,\n            error: error,\n            offset: meta.part.offset\n        });\n    }\n    if (result == null && num > 0) {\n        return _getValue.call(this, tag, meta, num - 1);\n    }\n    return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n    var _this2 = this;\n    var scope = this.scopeList[num];\n    // search in the scopes (in reverse order) and keep the first defined value\n    var parser;\n    if (!this.cachedParsers || !meta.part) {\n        parser = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    } else if (this.cachedParsers[meta.part.lIndex]) {\n        parser = this.cachedParsers[meta.part.lIndex];\n    } else {\n        parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    }\n    return Promise.resolve().then(function() {\n        return parser.get(scope, _this2.getContext(meta, num));\n    })[\"catch\"](function(error) {\n        throw getScopeParserExecutionError({\n            tag: tag,\n            scope: scope,\n            error: error,\n            offset: meta.part.offset\n        });\n    }).then(function(result) {\n        if (result == null && num > 0) {\n            return _getValueAsync.call(_this2, tag, meta, num - 1);\n        }\n        return result;\n    });\n}\nvar ScopeManager = /*#__PURE__*/ function() {\n    function ScopeManager(options) {\n        _classCallCheck(this, ScopeManager);\n        this.root = options.root || this;\n        this.resolveOffset = options.resolveOffset || 0;\n        this.scopePath = options.scopePath;\n        this.scopePathItem = options.scopePathItem;\n        this.scopePathLength = options.scopePathLength;\n        this.scopeList = options.scopeList;\n        this.scopeType = \"\";\n        this.scopeTypes = options.scopeTypes;\n        this.scopeLindex = options.scopeLindex;\n        this.parser = options.parser;\n        this.resolved = options.resolved;\n        this.cachedParsers = options.cachedParsers;\n    }\n    return _createClass(ScopeManager, [\n        {\n            key: \"loopOver\",\n            value: function loopOver(tag, functor, inverted, meta) {\n                return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n            }\n        },\n        {\n            key: \"functorIfInverted\",\n            value: function functorIfInverted(inverted, functor, value, i, length) {\n                if (inverted) {\n                    functor(value, i, length);\n                }\n                return inverted;\n            }\n        },\n        {\n            key: \"isValueFalsy\",\n            value: function isValueFalsy(value, type) {\n                return value == null || !value || type === \"[object Array]\" && value.length === 0;\n            }\n        },\n        {\n            key: \"loopOverValue\",\n            value: function loopOverValue(value, functor, inverted) {\n                if (this.root.finishedResolving) {\n                    inverted = false;\n                }\n                var type = Object.prototype.toString.call(value);\n                if (this.isValueFalsy(value, type)) {\n                    this.scopeType = false;\n                    return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n                }\n                if (type === \"[object Array]\") {\n                    this.scopeType = \"array\";\n                    for(var i = 0; i < value.length; i++){\n                        this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n                    }\n                    return true;\n                }\n                if (type === \"[object Object]\") {\n                    this.scopeType = \"object\";\n                    return this.functorIfInverted(!inverted, functor, value, 0, 1);\n                }\n                return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n            }\n        },\n        {\n            key: \"getValue\",\n            value: function getValue(tag, meta) {\n                var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n                if (typeof result === \"function\") {\n                    return result(this.scopeList[this.scopeList.length - 1], this);\n                }\n                return result;\n            }\n        },\n        {\n            key: \"getValueAsync\",\n            value: function getValueAsync(tag, meta) {\n                var _this3 = this;\n                return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function(result) {\n                    if (typeof result === \"function\") {\n                        return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n                    }\n                    return result;\n                });\n            }\n        },\n        {\n            key: \"getContext\",\n            value: function getContext(meta, num) {\n                return {\n                    num: num,\n                    meta: meta,\n                    scopeList: this.scopeList,\n                    resolved: this.resolved,\n                    scopePath: this.scopePath,\n                    scopeTypes: this.scopeTypes,\n                    scopePathItem: this.scopePathItem,\n                    scopePathLength: this.scopePathLength\n                };\n            }\n        },\n        {\n            key: \"createSubScopeManager\",\n            value: function createSubScopeManager(scope, tag, i, part, length) {\n                return new ScopeManager({\n                    root: this.root,\n                    resolveOffset: this.resolveOffset,\n                    resolved: this.resolved,\n                    parser: this.parser,\n                    cachedParsers: this.cachedParsers,\n                    scopeTypes: concatArrays([\n                        this.scopeTypes,\n                        [\n                            this.scopeType\n                        ]\n                    ]),\n                    scopeList: concatArrays([\n                        this.scopeList,\n                        [\n                            scope\n                        ]\n                    ]),\n                    scopePath: concatArrays([\n                        this.scopePath,\n                        [\n                            tag\n                        ]\n                    ]),\n                    scopePathItem: concatArrays([\n                        this.scopePathItem,\n                        [\n                            i\n                        ]\n                    ]),\n                    scopePathLength: concatArrays([\n                        this.scopePathLength,\n                        [\n                            length\n                        ]\n                    ]),\n                    scopeLindex: concatArrays([\n                        this.scopeLindex,\n                        [\n                            part.lIndex\n                        ]\n                    ])\n                });\n            }\n        }\n    ]);\n}();\nmodule.exports = function(options) {\n    options.scopePath = [];\n    options.scopePathItem = [];\n    options.scopePathLength = [];\n    options.scopeTypes = [];\n    options.scopeLindex = [];\n    options.scopeList = [\n        options.tags\n    ];\n    return new ScopeManager(options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9zY29wZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFVLGVBQWVOLFdBQVdPLEdBQUcsR0FBR1A7SUFBYTtBQUFFO0FBQzVVLFNBQVNRLGFBQWFmLFdBQVcsRUFBRWdCLFVBQVUsRUFBRUMsV0FBVztJQUFJLElBQUlELFlBQVlkLGtCQUFrQkYsWUFBWUgsU0FBUyxFQUFFbUI7SUFBYSxJQUFJQyxhQUFhZixrQkFBa0JGLGFBQWFpQjtJQUFjTixPQUFPQyxjQUFjLENBQUNaLGFBQWEsYUFBYTtRQUFFVSxVQUFVO0lB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UUFBUTtvQkFDdkJVLFFBQVEsSUFBSSxDQUFDQSxNQUFNO29CQUNuQkMsZUFBZSxJQUFJLENBQUNBLGFBQWE7b0JBQ2pDYyxZQUFZekMsYUFBYTt3QkFBQyxJQUFJLENBQUN5QyxVQUFVO3dCQUFFOzRCQUFDLElBQUksQ0FBQ0QsU0FBUzt5QkFBQztxQkFBQztvQkFDNUQ1QixXQUFXWixhQUFhO3dCQUFDLElBQUksQ0FBQ1ksU0FBUzt3QkFBRTs0QkFBQ0Q7eUJBQU07cUJBQUM7b0JBQ2pEWSxXQUFXdkIsYUFBYTt3QkFBQyxJQUFJLENBQUN1QixTQUFTO3dCQUFFOzRCQUFDaEI7eUJBQUk7cUJBQUM7b0JBQy9DYSxlQUFlcEIsYUFBYTt3QkFBQyxJQUFJLENBQUNvQixhQUFhO3dCQUFFOzRCQUFDL0M7eUJBQUU7cUJBQUM7b0JBQ3JEa0UsaUJBQWlCdkMsYUFBYTt3QkFBQyxJQUFJLENBQUN1QyxlQUFlO3dCQUFFOzRCQUFDakU7eUJBQU87cUJBQUM7b0JBQzlENkMsYUFBYW5CLGFBQWE7d0JBQUMsSUFBSSxDQUFDbUIsV0FBVzt3QkFBRTs0QkFBQ0ssS0FBS04sTUFBTTt5QkFBQztxQkFBQztnQkFDN0Q7WUFDRjtRQUNGO0tBQUU7QUFDSjtBQUNBb0MsT0FBT0MsT0FBTyxHQUFHLFNBQVVqQixPQUFPO0lBQ2hDQSxRQUFRZixTQUFTLEdBQUcsRUFBRTtJQUN0QmUsUUFBUWxCLGFBQWEsR0FBRyxFQUFFO0lBQzFCa0IsUUFBUUMsZUFBZSxHQUFHLEVBQUU7SUFDNUJELFFBQVFHLFVBQVUsR0FBRyxFQUFFO0lBQ3ZCSCxRQUFRbkIsV0FBVyxHQUFHLEVBQUU7SUFDeEJtQixRQUFRMUIsU0FBUyxHQUFHO1FBQUMwQixRQUFRa0IsSUFBSTtLQUFDO0lBQ2xDLE9BQU8sSUFBSW5CLGFBQWFDO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvc2NvcGUtbWFuYWdlci5qcz85NWJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlMi5sYXN0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgY29uY2F0QXJyYXlzID0gX3JlcXVpcmUzLmNvbmNhdEFycmF5cztcbmZ1bmN0aW9uIGZpbmQobGlzdCwgZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICB2YXIgdmFsdWU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgaWYgKGZuLmNhbGwodGhpcywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfZ2V0VmFsdWUodGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZUxpc3RbbnVtXTtcbiAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgIHZhciB3ID0gdGhpcy5yZXNvbHZlZDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBsSW5kZXggPSBfdGhpcy5zY29wZUxpbmRleFtpXTtcbiAgICAgIHcgPSBmaW5kKHcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmxJbmRleCA9PT0gbEluZGV4O1xuICAgICAgfSk7XG4gICAgICB3ID0gdy52YWx1ZVtfdGhpcy5zY29wZVBhdGhJdGVtW2ldXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnJlc29sdmVPZmZzZXQsIGxlbiA9IHRoaXMuc2NvcGVQYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmluZCh3LCBmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIG1ldGEucGFydC5sSW5kZXggPT09IHIubEluZGV4O1xuICAgIH0pLnZhbHVlO1xuICB9XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcmVzdWx0O1xuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IHBhcnNlci5nZXQoc2NvcGUsIHRoaXMuZ2V0Q29udGV4dChtZXRhLCBudW0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yKHtcbiAgICAgIHRhZzogdGFnLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgb2Zmc2V0OiBtZXRhLnBhcnQub2Zmc2V0XG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICByZXR1cm4gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2dldFZhbHVlQXN5bmModGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGVMaXN0W251bV07XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXQoc2NvcGUsIF90aGlzMi5nZXRDb250ZXh0KG1ldGEsIG51bSkpO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRocm93IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgdGFnOiB0YWcsXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvZmZzZXQ6IG1ldGEucGFydC5vZmZzZXRcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKF90aGlzMiwgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG52YXIgU2NvcGVNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NvcGVNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NvcGVNYW5hZ2VyKTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgdGhpcztcbiAgICB0aGlzLnJlc29sdmVPZmZzZXQgPSBvcHRpb25zLnJlc29sdmVPZmZzZXQgfHwgMDtcbiAgICB0aGlzLnNjb3BlUGF0aCA9IG9wdGlvbnMuc2NvcGVQYXRoO1xuICAgIHRoaXMuc2NvcGVQYXRoSXRlbSA9IG9wdGlvbnMuc2NvcGVQYXRoSXRlbTtcbiAgICB0aGlzLnNjb3BlUGF0aExlbmd0aCA9IG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoO1xuICAgIHRoaXMuc2NvcGVMaXN0ID0gb3B0aW9ucy5zY29wZUxpc3Q7XG4gICAgdGhpcy5zY29wZVR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc2NvcGVUeXBlcyA9IG9wdGlvbnMuc2NvcGVUeXBlcztcbiAgICB0aGlzLnNjb3BlTGluZGV4ID0gb3B0aW9ucy5zY29wZUxpbmRleDtcbiAgICB0aGlzLnBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuICAgIHRoaXMucmVzb2x2ZWQgPSBvcHRpb25zLnJlc29sdmVkO1xuICAgIHRoaXMuY2FjaGVkUGFyc2VycyA9IG9wdGlvbnMuY2FjaGVkUGFyc2VycztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNjb3BlTWFuYWdlciwgW3tcbiAgICBrZXk6IFwibG9vcE92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9vcE92ZXIodGFnLCBmdW5jdG9yLCBpbnZlcnRlZCwgbWV0YSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9vcE92ZXJWYWx1ZSh0aGlzLmdldFZhbHVlKHRhZywgbWV0YSksIGZ1bmN0b3IsIGludmVydGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnVuY3RvcklmSW52ZXJ0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnVuY3RvcklmSW52ZXJ0ZWQoaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlLCBpLCBsZW5ndGgpIHtcbiAgICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICBmdW5jdG9yKHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmVydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbHVlRmFsc3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUgfHwgdHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9vcE92ZXJWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29wT3ZlclZhbHVlKHZhbHVlLCBmdW5jdG9yLCBpbnZlcnRlZCkge1xuICAgICAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHRoaXMuaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSkge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZChpbnZlcnRlZCwgZnVuY3RvciwgbGFzdCh0aGlzLnNjb3BlTGlzdCksIDAsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZVtpXSwgaSwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gXCJvYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZSwgMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIGxhc3QodGhpcy5zY29wZUxpc3QpLCAwLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUodGFnLCBtZXRhKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCB0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLnNjb3BlTGlzdFt0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXN5bmModGFnLCBtZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKHRoaXMsIHRhZywgbWV0YSwgdGhpcy5zY29wZUxpc3QubGVuZ3RoIC0gMSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KF90aGlzMy5zY29wZUxpc3RbX3RoaXMzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgX3RoaXMzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dChtZXRhLCBudW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICBzY29wZUxpc3Q6IHRoaXMuc2NvcGVMaXN0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aCxcbiAgICAgICAgc2NvcGVUeXBlczogdGhpcy5zY29wZVR5cGVzLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiB0aGlzLnNjb3BlUGF0aEl0ZW0sXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogdGhpcy5zY29wZVBhdGhMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVN1YlNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHRhZywgaSwgcGFydCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlTWFuYWdlcih7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgcmVzb2x2ZU9mZnNldDogdGhpcy5yZXNvbHZlT2Zmc2V0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICBzY29wZVR5cGVzOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVUeXBlcywgW3RoaXMuc2NvcGVUeXBlXV0pLFxuICAgICAgICBzY29wZUxpc3Q6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpc3QsIFtzY29wZV1dKSxcbiAgICAgICAgc2NvcGVQYXRoOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoLCBbdGFnXV0pLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoSXRlbSwgW2ldXSksXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlUGF0aExlbmd0aCwgW2xlbmd0aF1dKSxcbiAgICAgICAgc2NvcGVMaW5kZXg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpbmRleCwgW3BhcnQubEluZGV4XV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5zY29wZVBhdGggPSBbXTtcbiAgb3B0aW9ucy5zY29wZVBhdGhJdGVtID0gW107XG4gIG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoID0gW107XG4gIG9wdGlvbnMuc2NvcGVUeXBlcyA9IFtdO1xuICBvcHRpb25zLnNjb3BlTGluZGV4ID0gW107XG4gIG9wdGlvbnMuc2NvcGVMaXN0ID0gW29wdGlvbnMudGFnc107XG4gIHJldHVybiBuZXcgU2NvcGVNYW5hZ2VyKG9wdGlvbnMpO1xufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJ0IiwiX3RvUHJpbWl0aXZlIiwiciIsImUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJfcmVxdWlyZSIsInJlcXVpcmUiLCJnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yIiwiX3JlcXVpcmUyIiwibGFzdCIsIl9yZXF1aXJlMyIsImNvbmNhdEFycmF5cyIsImZpbmQiLCJsaXN0IiwiZm4iLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIl9nZXRWYWx1ZSIsInRhZyIsIm1ldGEiLCJudW0iLCJfdGhpcyIsInNjb3BlIiwic2NvcGVMaXN0Iiwicm9vdCIsImZpbmlzaGVkUmVzb2x2aW5nIiwidyIsInJlc29sdmVkIiwiX2xvb3AiLCJsSW5kZXgiLCJzY29wZUxpbmRleCIsInNjb3BlUGF0aEl0ZW0iLCJyZXNvbHZlT2Zmc2V0IiwibGVuIiwic2NvcGVQYXRoIiwicGFydCIsInJlc3VsdCIsInBhcnNlciIsImNhY2hlZFBhcnNlcnMiLCJnZXQiLCJnZXRDb250ZXh0IiwiZXJyb3IiLCJvZmZzZXQiLCJfZ2V0VmFsdWVBc3luYyIsIl90aGlzMiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIlNjb3BlTWFuYWdlciIsIm9wdGlvbnMiLCJzY29wZVBhdGhMZW5ndGgiLCJzY29wZVR5cGUiLCJzY29wZVR5cGVzIiwibG9vcE92ZXIiLCJmdW5jdG9yIiwiaW52ZXJ0ZWQiLCJsb29wT3ZlclZhbHVlIiwiZ2V0VmFsdWUiLCJmdW5jdG9ySWZJbnZlcnRlZCIsImlzVmFsdWVGYWxzeSIsInR5cGUiLCJ0b1N0cmluZyIsImdldFZhbHVlQXN5bmMiLCJfdGhpczMiLCJjcmVhdGVTdWJTY29wZU1hbmFnZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwidGFncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/traits.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/traits.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), getRightOrNull = _require.getRightOrNull, getRight = _require.getRight, getLeft = _require.getLeft, getLeftOrNull = _require.getLeftOrNull, chunkBy = _require.chunkBy, isTagStart = _require.isTagStart, isTagEnd = _require.isTagEnd, isContent = _require.isContent, last = _require.last, first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"), XTTemplateError = _require2.XTTemplateError, throwExpandNotFound = _require2.throwExpandNotFound, getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n    if (tags.length === 0) {\n        return false;\n    }\n    var innerLastTag = last(tags).substr(1);\n    return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n    /*\n  Gets the list of closing and opening tags between two texts. It doesn't take\n  into account tags that are opened then closed. Those that are closed then\n  opened are kept\n  \tExample input :\n  \t[\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"table1\",\n  \t\t...\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data1\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"position\": \"end\",\n  \t\t\"text\": true,\n  \t\t\"value\": \"</w:t>\",\n  \t\t\"tag\": \"w:t\",\n  \t\t\"lIndex\": 112\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:p>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"content\",\n  \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n  \t},\n  \t...\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data4\",\n  \t}\n  ]\n  \treturns\n  \t[\n  \t\t{\n  \t\t\t\"tag\": \"</w:t>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:t>\",\n  \t\t},\n  \t]\n  */ var result = [];\n    for(var i = 0; i < parts.length; i++){\n        var _parts$i = parts[i], position = _parts$i.position, value = _parts$i.value, tag = _parts$i.tag;\n        // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n        if (!tag) {\n            continue;\n        }\n        // Stryker restore all\n        if (position === \"end\") {\n            if (lastTagIsOpenTag(result, tag)) {\n                result.pop();\n            } else {\n                result.push(value);\n            }\n        } else if (position === \"start\") {\n            result.push(value);\n        }\n    // ignore position === \"selfclosing\"\n    }\n    return result;\n}\nfunction has(name, xmlElements) {\n    for(var i = 0; i < xmlElements.length; i++){\n        var xmlElement = xmlElements[i];\n        if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n    var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n    var xmlElements = getListXmlElements(parts);\n    var closingTagCount = xmlElements.filter(function(tag) {\n        return tag[1] === \"/\";\n    }).length;\n    var startingTagCount = xmlElements.filter(function(tag) {\n        return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n    }).length;\n    if (closingTagCount !== startingTagCount) {\n        return {\n            error: getLoopPositionProducesInvalidXMLError({\n                tag: first(pair).part.value,\n                offset: [\n                    first(pair).part.offset,\n                    last(pair).part.offset\n                ]\n            })\n        };\n    }\n    var _loop = function _loop() {\n        var _expandTags$i = expandTags[i], contains = _expandTags$i.contains, expand = _expandTags$i.expand, onlyTextInTag = _expandTags$i.onlyTextInTag;\n        if (has(contains, xmlElements)) {\n            if (onlyTextInTag) {\n                var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n                var right = getRightOrNull(postparsed, contains, pair[1].offset);\n                if (left === null || right === null) {\n                    return 0; // continue\n                }\n                var chunks = chunkBy(postparsed.slice(left, right), function(p) {\n                    return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n                });\n                var firstChunk = first(chunks);\n                var lastChunk = last(chunks);\n                var firstContent = firstChunk.filter(isContent);\n                var lastContent = lastChunk.filter(isContent);\n                if (firstContent.length !== 1 || lastContent.length !== 1) {\n                    return 0; // continue\n                }\n            }\n            return {\n                v: {\n                    value: expand\n                }\n            };\n        }\n    }, _ret;\n    for(var i = 0, len = expandTags.length; i < len; i++){\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n    }\n    return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n    var expandTo = part.expandTo || options.expandTo;\n    // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n    if (!expandTo) {\n        return;\n    }\n    // Stryker restore all\n    var right, left;\n    try {\n        left = getLeft(postparsed, expandTo, index);\n        right = getRight(postparsed, expandTo, index);\n    } catch (rootError) {\n        if (rootError instanceof XTTemplateError) {\n            throwExpandNotFound(_objectSpread({\n                part: part,\n                rootError: rootError,\n                postparsed: postparsed,\n                expandTo: expandTo,\n                index: index\n            }, options.error));\n        }\n        throw rootError;\n    }\n    return [\n        left,\n        right\n    ];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n    var _ref2 = _slicedToArray(_ref, 2), left = _ref2[0], right = _ref2[1];\n    var index = postparsed.indexOf(part);\n    var leftParts = postparsed.slice(left, index);\n    var rightParts = postparsed.slice(index + 1, right + 1);\n    var inner = options.getInner({\n        postparse: options.postparse,\n        index: index,\n        part: part,\n        leftParts: leftParts,\n        rightParts: rightParts,\n        left: left,\n        right: right,\n        postparsed: postparsed\n    });\n    if (!inner.length) {\n        inner.expanded = [\n            leftParts,\n            rightParts\n        ];\n        inner = [\n            inner\n        ];\n    }\n    return {\n        left: left,\n        right: right,\n        inner: inner\n    };\n}\nfunction expandToOne(postparsed, options) {\n    var errors = [];\n    if (postparsed.errors) {\n        errors = postparsed.errors;\n        postparsed = postparsed.postparsed;\n    }\n    var limits = [];\n    for(var i = 0, len = postparsed.length; i < len; i++){\n        var part = postparsed[i];\n        if (part.type === \"placeholder\" && part.module === options.moduleName && // The part.subparsed check is used to fix this github issue :\n        // https://github.com/open-xml-templating/docxtemplater/issues/671\n        !part.subparsed && !part.expanded) {\n            try {\n                var limit = getExpandLimit(part, i, postparsed, options);\n                if (!limit) {\n                    continue;\n                }\n                var _limit = _slicedToArray(limit, 2), left = _limit[0], right = _limit[1];\n                limits.push({\n                    left: left,\n                    right: right,\n                    part: part,\n                    i: i,\n                    leftPart: postparsed[left],\n                    rightPart: postparsed[right]\n                });\n            } catch (error) {\n                if (error instanceof XTTemplateError) {\n                    errors.push(error);\n                } else {\n                    throw error;\n                }\n            }\n        }\n    }\n    limits.sort(function(l1, l2) {\n        if (l1.left === l2.left) {\n            return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n        }\n        return l2.left < l1.left ? 1 : -1;\n    });\n    var maxRight = -1;\n    var offset = 0;\n    limits.forEach(function(limit, i) {\n        var _postparsed;\n        maxRight = Math.max(maxRight, i > 0 ? limits[i - 1].right : 0);\n        if (limit.left < maxRight) {\n            return;\n        }\n        var result;\n        try {\n            result = expandOne([\n                limit.left + offset,\n                limit.right + offset\n            ], limit.part, postparsed, options);\n        } catch (error) {\n            if (error instanceof XTTemplateError) {\n                errors.push(error);\n            } else {\n                throw error;\n            }\n        }\n        if (!result) {\n            return;\n        }\n        offset += result.inner.length - (result.right + 1 - result.left);\n        (_postparsed = postparsed).splice.apply(_postparsed, [\n            result.left,\n            result.right + 1 - result.left\n        ].concat(_toConsumableArray(result.inner)));\n    });\n    return {\n        postparsed: postparsed,\n        errors: errors\n    };\n}\nmodule.exports = {\n    expandToOne: expandToOne,\n    getExpandToDefault: getExpandToDefault\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssbUJBQW1CQyxHQUFHO0lBQUksT0FBT0MsbUJBQW1CRCxRQUFRRSxpQkFBaUJGLFFBQVFHLDRCQUE0QkgsUUFBUUk7QUFBc0I7QUFDeEosU0FBU0E7SUFBdUIsTUFBTSxJQUFJQyxVQUFVO0FBQXlJO0FBQzdMLFNBQVNILGlCQUFpQkksSUFBSTtJQUFJLElBQUksT0FBT1gsV0FBVyxlQUFlVyxJQUFJLENBQUNYLE9BQU9DLFFBQVEsQ0FBQyxJQUFJLFFBQVFVLElBQUksQ0FBQyxhQUFhLElBQUksTUFBTSxPQUFPQyxNQUFNQyxJQUFJLENBQUNGO0FBQU87QUFDN0osU0FBU0wsbUJBQW1CRCxHQUFHO0lBQUksSUFBSU8sTUFBTUUsT0FBTyxDQUFDVCxNQUFNLE9BQU9VLGtCQUFrQlY7QUFBTTtBQUMxRixTQUFTVyxlQUFlWCxHQUFHLEVBQUVZLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JiLFFBQVFjLHNCQUFzQmQsS0FBS1ksTUFBTVQsNEJBQTRCSCxLQUFLWSxNQUFNRztBQUFvQjtBQUM3SixTQUFTQTtJQUFxQixNQUFNLElBQUlWLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCVCxDQUFDLEVBQUVzQixNQUFNO0lBQUksSUFBSSxDQUFDdEIsR0FBRztJQUFRLElBQUksT0FBT0EsTUFB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QUFLQyxHQUFHLENBQUNILFVBQVV0SSxJQUFJLElBQUl5SCxNQUFNLENBQUN6SCxJQUFJLEVBQUUsQ0FBQ2dHLEtBQUssR0FBRztRQUM1RCxJQUFJOEIsTUFBTS9CLElBQUksR0FBR3VDLFVBQVU7WUFDekI7UUFDRjtRQUNBLElBQUk3RDtRQUNKLElBQUk7WUFDRkEsU0FBU3FDLFVBQVU7Z0JBQUNnQixNQUFNL0IsSUFBSSxHQUFHVjtnQkFBUXlDLE1BQU05QixLQUFLLEdBQUdYO2FBQU8sRUFBRXlDLE1BQU1yQyxJQUFJLEVBQUVQLFlBQVl5QjtRQUMxRixFQUFFLE9BQU9uQixPQUFPO1lBQ2QsSUFBSUEsaUJBQWlCMUIsaUJBQWlCO2dCQUNwQzBELE9BQU9oRyxJQUFJLENBQUNnRTtZQUNkLE9BQU87Z0JBQ0wsTUFBTUE7WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDZixRQUFRO1lBQ1g7UUFDRjtRQUNBWSxVQUFVWixPQUFPMEMsS0FBSyxDQUFDdEcsTUFBTSxHQUFJNEQsQ0FBQUEsT0FBT3VCLEtBQUssR0FBRyxJQUFJdkIsT0FBT3NCLElBQUk7UUFDOUR3QyxDQUFBQSxjQUFjckQsVUFBUyxFQUFHd0QsTUFBTSxDQUFDMUcsS0FBSyxDQUFDdUcsYUFBYTtZQUFDOUQsT0FBT3NCLElBQUk7WUFBRXRCLE9BQU91QixLQUFLLEdBQUcsSUFBSXZCLE9BQU9zQixJQUFJO1NBQUMsQ0FBQ2YsTUFBTSxDQUFDN0YsbUJBQW1Cc0YsT0FBTzBDLEtBQUs7SUFDM0k7SUFDQSxPQUFPO1FBQ0xqQyxZQUFZQTtRQUNac0MsUUFBUUE7SUFDVjtBQUNGO0FBQ0FHLE9BQU9nQixPQUFPLEdBQUc7SUFDZnBCLGFBQWFBO0lBQ2J0QyxvQkFBb0JBO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdHJhaXRzLmpzP2ZkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldFJpZ2h0T3JOdWxsID0gX3JlcXVpcmUuZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0ID0gX3JlcXVpcmUuZ2V0UmlnaHQsXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRMZWZ0T3JOdWxsID0gX3JlcXVpcmUuZ2V0TGVmdE9yTnVsbCxcbiAgY2h1bmtCeSA9IF9yZXF1aXJlLmNodW5rQnksXG4gIGlzVGFnU3RhcnQgPSBfcmVxdWlyZS5pc1RhZ1N0YXJ0LFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUyLlhUVGVtcGxhdGVFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZCA9IF9yZXF1aXJlMi50aHJvd0V4cGFuZE5vdEZvdW5kLFxuICBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvciA9IF9yZXF1aXJlMi5nZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcjtcbmZ1bmN0aW9uIGxhc3RUYWdJc09wZW5UYWcodGFncywgdGFnKSB7XG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5uZXJMYXN0VGFnID0gbGFzdCh0YWdzKS5zdWJzdHIoMSk7XG4gIHJldHVybiBpbm5lckxhc3RUYWcuaW5kZXhPZih0YWcpID09PSAwO1xufVxuZnVuY3Rpb24gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKSB7XG4gIC8qXG4gIEdldHMgdGhlIGxpc3Qgb2YgY2xvc2luZyBhbmQgb3BlbmluZyB0YWdzIGJldHdlZW4gdHdvIHRleHRzLiBJdCBkb2Vzbid0IHRha2VcbiAgaW50byBhY2NvdW50IHRhZ3MgdGhhdCBhcmUgb3BlbmVkIHRoZW4gY2xvc2VkLiBUaG9zZSB0aGF0IGFyZSBjbG9zZWQgdGhlblxuICBvcGVuZWQgYXJlIGtlcHRcbiAgXHRFeGFtcGxlIGlucHV0IDpcbiAgXHRbXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgXHRcdFwidmFsdWVcIjogXCJ0YWJsZTFcIixcbiAgXHRcdC4uLlxuICBcdH0sXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgXHRcdFwidmFsdWVcIjogXCJ0MWRhdGExXCIsXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgXHRcdFwicG9zaXRpb25cIjogXCJlbmRcIixcbiAgXHRcdFwidGV4dFwiOiB0cnVlLFxuICBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0PlwiLFxuICBcdFx0XCJ0YWdcIjogXCJ3OnRcIixcbiAgXHRcdFwibEluZGV4XCI6IDExMlxuICBcdH0sXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gIFx0XHRcInZhbHVlXCI6IFwiPC93OnI+XCIsXG4gIFx0fSxcbiAgXHR7XG4gIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgXHRcdFwidmFsdWVcIjogXCI8L3c6cD5cIixcbiAgXHR9LFxuICBcdHtcbiAgXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0Yz5cIixcbiAgXHR9LFxuICBcdHtcbiAgXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjPlwiLFxuICBcdH0sXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwiY29udGVudFwiLFxuICBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjUHI+PHc6dGNXIHc6dz1cIjI0NDRcIiB3OnR5cGU9XCJkeGFcIi8+PHc6dGNCb3JkZXJzPjx3OnRvcCB3OnZhbD1cIm5pbFwiLz48dzpsZWZ0IHc6dmFsPVwibmlsXCIvPjx3OmJvdHRvbSB3OnZhbD1cIm5pbFwiLz48dzpyaWdodCB3OnZhbD1cIm5pbFwiLz48L3c6dGNCb3JkZXJzPjx3OnNoZCB3OnZhbD1cImNsZWFyXCIgdzpjb2xvcj1cImF1dG9cIiB3OmZpbGw9XCJGRkZGRkZcIi8+PC93OnRjUHI+XCIsXG4gIFx0fSxcbiAgXHQuLi5cbiAgXHR7XG4gIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgXHRcdFwidmFsdWVcIjogXCI8dzpyPlwiLFxuICBcdH0sXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gIFx0XHRcInZhbHVlXCI6IFwiPHc6dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlwiLFxuICBcdH0sXG4gIFx0e1xuICBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgXHRcdFwidmFsdWVcIjogXCJ0MWRhdGE0XCIsXG4gIFx0fVxuICBdXG4gIFx0cmV0dXJuc1xuICBcdFtcbiAgXHRcdHtcbiAgXHRcdFx0XCJ0YWdcIjogXCI8L3c6dD5cIixcbiAgXHRcdH0sXG4gIFx0XHR7XG4gIFx0XHRcdFwidGFnXCI6IFwiPC93OnI+XCIsXG4gIFx0XHR9LFxuICBcdFx0e1xuICBcdFx0XHRcInRhZ1wiOiBcIjwvdzpwPlwiLFxuICBcdFx0fSxcbiAgXHRcdHtcbiAgXHRcdFx0XCJ0YWdcIjogXCI8L3c6dGM+XCIsXG4gIFx0XHR9LFxuICBcdFx0e1xuICBcdFx0XHRcInRhZ1wiOiBcIjx3OnRjPlwiLFxuICBcdFx0fSxcbiAgXHRcdHtcbiAgXHRcdFx0XCJ0YWdcIjogXCI8dzpwPlwiLFxuICBcdFx0fSxcbiAgXHRcdHtcbiAgXHRcdFx0XCJ0YWdcIjogXCI8dzpyPlwiLFxuICBcdFx0fSxcbiAgXHRcdHtcbiAgXHRcdFx0XCJ0YWdcIjogXCI8dzp0PlwiLFxuICBcdFx0fSxcbiAgXHRdXG4gICovXG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wYXJ0cyRpID0gcGFydHNbaV0sXG4gICAgICBwb3NpdGlvbiA9IF9wYXJ0cyRpLnBvc2l0aW9uLFxuICAgICAgdmFsdWUgPSBfcGFydHMkaS52YWx1ZSxcbiAgICAgIHRhZyA9IF9wYXJ0cyRpLnRhZztcbiAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSByZW1vdmluZyB0aGlzIGNvbmRpdGlvbiB3b3VsZCBhbHNvIHdvcmsgYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICAgIGlmICghdGFnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKGxhc3RUYWdJc09wZW5UYWcocmVzdWx0LCB0YWcpKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHBvc2l0aW9uID09PSBcInNlbGZjbG9zaW5nXCJcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzKG5hbWUsIHhtbEVsZW1lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeG1sRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeG1sRWxlbWVudCA9IHhtbEVsZW1lbnRzW2ldO1xuICAgIGlmICh4bWxFbGVtZW50LmluZGV4T2YoXCI8XCIuY29uY2F0KG5hbWUpKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZFRvRGVmYXVsdChwb3N0cGFyc2VkLCBwYWlyLCBleHBhbmRUYWdzKSB7XG4gIHZhciBwYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UocGFpclswXS5vZmZzZXQsIHBhaXJbMV0ub2Zmc2V0KTtcbiAgdmFyIHhtbEVsZW1lbnRzID0gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKTtcbiAgdmFyIGNsb3NpbmdUYWdDb3VudCA9IHhtbEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIHRhZ1sxXSA9PT0gXCIvXCI7XG4gIH0pLmxlbmd0aDtcbiAgdmFyIHN0YXJ0aW5nVGFnQ291bnQgPSB4bWxFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiB0YWdbMV0gIT09IFwiL1wiICYmIHRhZ1t0YWcubGVuZ3RoIC0gMl0gIT09IFwiL1wiO1xuICB9KS5sZW5ndGg7XG4gIGlmIChjbG9zaW5nVGFnQ291bnQgIT09IHN0YXJ0aW5nVGFnQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKHtcbiAgICAgICAgdGFnOiBmaXJzdChwYWlyKS5wYXJ0LnZhbHVlLFxuICAgICAgICBvZmZzZXQ6IFtmaXJzdChwYWlyKS5wYXJ0Lm9mZnNldCwgbGFzdChwYWlyKS5wYXJ0Lm9mZnNldF1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBfZXhwYW5kVGFncyRpID0gZXhwYW5kVGFnc1tpXSxcbiAgICAgICAgY29udGFpbnMgPSBfZXhwYW5kVGFncyRpLmNvbnRhaW5zLFxuICAgICAgICBleHBhbmQgPSBfZXhwYW5kVGFncyRpLmV4cGFuZCxcbiAgICAgICAgb25seVRleHRJblRhZyA9IF9leHBhbmRUYWdzJGkub25seVRleHRJblRhZztcbiAgICAgIGlmIChoYXMoY29udGFpbnMsIHhtbEVsZW1lbnRzKSkge1xuICAgICAgICBpZiAob25seVRleHRJblRhZykge1xuICAgICAgICAgIHZhciBsZWZ0ID0gZ2V0TGVmdE9yTnVsbChwb3N0cGFyc2VkLCBjb250YWlucywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICAgIHZhciByaWdodCA9IGdldFJpZ2h0T3JOdWxsKHBvc3RwYXJzZWQsIGNvbnRhaW5zLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwgfHwgcmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwb3N0cGFyc2VkLnNsaWNlKGxlZnQsIHJpZ2h0KSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhZ1N0YXJ0KGNvbnRhaW5zLCBwKSA/IFwic3RhcnRcIiA6IGlzVGFnRW5kKGNvbnRhaW5zLCBwKSA/IFwiZW5kXCIgOiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmaXJzdENodW5rID0gZmlyc3QoY2h1bmtzKTtcbiAgICAgICAgICB2YXIgbGFzdENodW5rID0gbGFzdChjaHVua3MpO1xuICAgICAgICAgIHZhciBmaXJzdENvbnRlbnQgPSBmaXJzdENodW5rLmZpbHRlcihpc0NvbnRlbnQpO1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudCA9IGxhc3RDaHVuay5maWx0ZXIoaXNDb250ZW50KTtcbiAgICAgICAgICBpZiAoZmlyc3RDb250ZW50Lmxlbmd0aCAhPT0gMSB8fCBsYXN0Q29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgIHZhbHVlOiBleHBhbmRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmV0O1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwYW5kVGFncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICBpZiAoX3JldCkgcmV0dXJuIF9yZXQudjtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRMaW1pdChwYXJ0LCBpbmRleCwgcG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXhwYW5kVG8gPSBwYXJ0LmV4cGFuZFRvIHx8IG9wdGlvbnMuZXhwYW5kVG87XG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY29uZGl0aW9uIGNhbiBiZSByZW1vdmVkIGluIHY0ICh0aGUgb25seSB1c2FnZSB3YXMgdGhlIGltYWdlIG1vZHVsZSBiZWZvcmUgdmVyc2lvbiAzLjEyLjMgb2YgdGhlIGltYWdlIG1vZHVsZVxuICBpZiAoIWV4cGFuZFRvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgdmFyIHJpZ2h0LCBsZWZ0O1xuICB0cnkge1xuICAgIGxlZnQgPSBnZXRMZWZ0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBpbmRleCk7XG4gICAgcmlnaHQgPSBnZXRSaWdodChwb3N0cGFyc2VkLCBleHBhbmRUbywgaW5kZXgpO1xuICB9IGNhdGNoIChyb290RXJyb3IpIHtcbiAgICBpZiAocm9vdEVycm9yIGluc3RhbmNlb2YgWFRUZW1wbGF0ZUVycm9yKSB7XG4gICAgICB0aHJvd0V4cGFuZE5vdEZvdW5kKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICByb290RXJyb3I6IHJvb3RFcnJvcixcbiAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH0sIG9wdGlvbnMuZXJyb3IpKTtcbiAgICB9XG4gICAgdGhyb3cgcm9vdEVycm9yO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufVxuZnVuY3Rpb24gZXhwYW5kT25lKF9yZWYsIHBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgbGVmdCA9IF9yZWYyWzBdLFxuICAgIHJpZ2h0ID0gX3JlZjJbMV07XG4gIHZhciBpbmRleCA9IHBvc3RwYXJzZWQuaW5kZXhPZihwYXJ0KTtcbiAgdmFyIGxlZnRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgaW5kZXgpO1xuICB2YXIgcmlnaHRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UoaW5kZXggKyAxLCByaWdodCArIDEpO1xuICB2YXIgaW5uZXIgPSBvcHRpb25zLmdldElubmVyKHtcbiAgICBwb3N0cGFyc2U6IG9wdGlvbnMucG9zdHBhcnNlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGxlZnRQYXJ0czogbGVmdFBhcnRzLFxuICAgIHJpZ2h0UGFydHM6IHJpZ2h0UGFydHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZFxuICB9KTtcbiAgaWYgKCFpbm5lci5sZW5ndGgpIHtcbiAgICBpbm5lci5leHBhbmRlZCA9IFtsZWZ0UGFydHMsIHJpZ2h0UGFydHNdO1xuICAgIGlubmVyID0gW2lubmVyXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGlubmVyOiBpbm5lclxuICB9O1xufVxuZnVuY3Rpb24gZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChwb3N0cGFyc2VkLmVycm9ycykge1xuICAgIGVycm9ycyA9IHBvc3RwYXJzZWQuZXJyb3JzO1xuICAgIHBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkLnBvc3RwYXJzZWQ7XG4gIH1cbiAgdmFyIGxpbWl0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9zdHBhcnNlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcG9zdHBhcnNlZFtpXTtcbiAgICBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgcGFydC5tb2R1bGUgPT09IG9wdGlvbnMubW9kdWxlTmFtZSAmJlxuICAgIC8vIFRoZSBwYXJ0LnN1YnBhcnNlZCBjaGVjayBpcyB1c2VkIHRvIGZpeCB0aGlzIGdpdGh1YiBpc3N1ZSA6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW4teG1sLXRlbXBsYXRpbmcvZG9jeHRlbXBsYXRlci9pc3N1ZXMvNjcxXG4gICAgIXBhcnQuc3VicGFyc2VkICYmICFwYXJ0LmV4cGFuZGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGltaXQgPSBnZXRFeHBhbmRMaW1pdChwYXJ0LCBpLCBwb3N0cGFyc2VkLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbGltaXQgPSBfc2xpY2VkVG9BcnJheShsaW1pdCwgMiksXG4gICAgICAgICAgbGVmdCA9IF9saW1pdFswXSxcbiAgICAgICAgICByaWdodCA9IF9saW1pdFsxXTtcbiAgICAgICAgbGltaXRzLnB1c2goe1xuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBsZWZ0UGFydDogcG9zdHBhcnNlZFtsZWZ0XSxcbiAgICAgICAgICByaWdodFBhcnQ6IHBvc3RwYXJzZWRbcmlnaHRdXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgWFRUZW1wbGF0ZUVycm9yKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbWl0cy5zb3J0KGZ1bmN0aW9uIChsMSwgbDIpIHtcbiAgICBpZiAobDEubGVmdCA9PT0gbDIubGVmdCkge1xuICAgICAgcmV0dXJuIGwyLnBhcnQubEluZGV4IDwgbDEucGFydC5sSW5kZXggPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBsMi5sZWZ0IDwgbDEubGVmdCA/IDEgOiAtMTtcbiAgfSk7XG4gIHZhciBtYXhSaWdodCA9IC0xO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgbGltaXRzLmZvckVhY2goZnVuY3Rpb24gKGxpbWl0LCBpKSB7XG4gICAgdmFyIF9wb3N0cGFyc2VkO1xuICAgIG1heFJpZ2h0ID0gTWF0aC5tYXgobWF4UmlnaHQsIGkgPiAwID8gbGltaXRzW2kgLSAxXS5yaWdodCA6IDApO1xuICAgIGlmIChsaW1pdC5sZWZ0IDwgbWF4UmlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZXhwYW5kT25lKFtsaW1pdC5sZWZ0ICsgb2Zmc2V0LCBsaW1pdC5yaWdodCArIG9mZnNldF0sIGxpbWl0LnBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBYVFRlbXBsYXRlRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9mZnNldCArPSByZXN1bHQuaW5uZXIubGVuZ3RoIC0gKHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdCk7XG4gICAgKF9wb3N0cGFyc2VkID0gcG9zdHBhcnNlZCkuc3BsaWNlLmFwcGx5KF9wb3N0cGFyc2VkLCBbcmVzdWx0LmxlZnQsIHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQuaW5uZXIpKSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHBhbmRUb09uZTogZXhwYW5kVG9PbmUsXG4gIGdldEV4cGFuZFRvRGVmYXVsdDogZ2V0RXhwYW5kVG9EZWZhdWx0XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwiaXRlciIsIkFycmF5IiwiZnJvbSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIl9zbGljZWRUb0FycmF5IiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJtaW5MZW4iLCJuIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsImxlbiIsImxlbmd0aCIsImFycjIiLCJyIiwibCIsInQiLCJlIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImdldFJpZ2h0T3JOdWxsIiwiZ2V0UmlnaHQiLCJnZXRMZWZ0IiwiZ2V0TGVmdE9yTnVsbCIsImNodW5rQnkiLCJpc1RhZ1N0YXJ0IiwiaXNUYWdFbmQiLCJpc0NvbnRlbnQiLCJsYXN0IiwiZmlyc3QiLCJfcmVxdWlyZTIiLCJYVFRlbXBsYXRlRXJyb3IiLCJ0aHJvd0V4cGFuZE5vdEZvdW5kIiwiZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IiLCJsYXN0VGFnSXNPcGVuVGFnIiwidGFncyIsInRhZyIsImlubmVyTGFzdFRhZyIsInN1YnN0ciIsImluZGV4T2YiLCJnZXRMaXN0WG1sRWxlbWVudHMiLCJwYXJ0cyIsInJlc3VsdCIsIl9wYXJ0cyRpIiwicG9zaXRpb24iLCJwb3AiLCJoYXMiLCJ4bWxFbGVtZW50cyIsInhtbEVsZW1lbnQiLCJjb25jYXQiLCJnZXRFeHBhbmRUb0RlZmF1bHQiLCJwb3N0cGFyc2VkIiwicGFpciIsImV4cGFuZFRhZ3MiLCJvZmZzZXQiLCJjbG9zaW5nVGFnQ291bnQiLCJzdGFydGluZ1RhZ0NvdW50IiwiZXJyb3IiLCJwYXJ0IiwiX2xvb3AiLCJfZXhwYW5kVGFncyRpIiwiY29udGFpbnMiLCJleHBhbmQiLCJvbmx5VGV4dEluVGFnIiwibGVmdCIsInJpZ2h0IiwiY2h1bmtzIiwicCIsImZpcnN0Q2h1bmsiLCJsYXN0Q2h1bmsiLCJmaXJzdENvbnRlbnQiLCJsYXN0Q29udGVudCIsInYiLCJfcmV0IiwiZ2V0RXhwYW5kTGltaXQiLCJpbmRleCIsIm9wdGlvbnMiLCJleHBhbmRUbyIsInJvb3RFcnJvciIsImV4cGFuZE9uZSIsIl9yZWYiLCJfcmVmMiIsImxlZnRQYXJ0cyIsInJpZ2h0UGFydHMiLCJpbm5lciIsImdldElubmVyIiwicG9zdHBhcnNlIiwiZXhwYW5kZWQiLCJleHBhbmRUb09uZSIsImVycm9ycyIsImxpbWl0cyIsInR5cGUiLCJtb2R1bGUiLCJtb2R1bGVOYW1lIiwic3VicGFyc2VkIiwibGltaXQiLCJfbGltaXQiLCJsZWZ0UGFydCIsInJpZ2h0UGFydCIsInNvcnQiLCJsMSIsImwyIiwibEluZGV4IiwibWF4UmlnaHQiLCJfcG9zdHBhcnNlZCIsIk1hdGgiLCJtYXgiLCJzcGxpY2UiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/utils.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/utils.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nfunction last(a) {\n    return a[a.length - 1];\n}\nfunction first(a) {\n    return a[0];\n}\nmodule.exports = {\n    last: last,\n    first: first\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLEtBQUtDLENBQUM7SUFDYixPQUFPQSxDQUFDLENBQUNBLEVBQUVDLE1BQU0sR0FBRyxFQUFFO0FBQ3hCO0FBQ0EsU0FBU0MsTUFBTUYsQ0FBQztJQUNkLE9BQU9BLENBQUMsQ0FBQyxFQUFFO0FBQ2I7QUFDQUcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZMLE1BQU1BO0lBQ05HLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcz81YzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBsYXN0KGEpIHtcbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGZpcnN0KGEpIHtcbiAgcmV0dXJuIGFbMF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0XG59OyJdLCJuYW1lcyI6WyJsYXN0IiwiYSIsImxlbmd0aCIsImZpcnN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/xml-matcher.js":
/*!******************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-matcher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n    var res = {\n        content: content\n    };\n    var taj = tagsXmlArray.join(\"|\");\n    var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n    res.matches = pregMatchAll(regexp, res.content);\n    return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLDBFQUFnQixHQUNyQ0MsZUFBZUYsU0FBU0UsWUFBWTtBQUN0Q0MsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFdBQVdDLE9BQU8sRUFBRUMsWUFBWTtJQUN4RCxJQUFJQyxNQUFNO1FBQ1JGLFNBQVNBO0lBQ1g7SUFDQSxJQUFJRyxNQUFNRixhQUFhRyxJQUFJLENBQUM7SUFDNUIsSUFBSUMsU0FBUyxJQUFJQyxPQUFPLFdBQVdDLE1BQU0sQ0FBQ0osS0FBSyx5QkFBeUJJLE1BQU0sQ0FBQ0osS0FBSyxhQUFhSSxNQUFNLENBQUNKLEtBQUssY0FBYztJQUMzSEQsSUFBSU0sT0FBTyxHQUFHWixhQUFhUyxRQUFRSCxJQUFJRixPQUFPO0lBQzlDLE9BQU9FO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWQtcGxhbm5lci1mcm9udC1lbmQvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcz9iMGY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHByZWdNYXRjaEFsbCA9IF9yZXF1aXJlLnByZWdNYXRjaEFsbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG1sTWF0Y2hlcihjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIHJlcyA9IHtcbiAgICBjb250ZW50OiBjb250ZW50XG4gIH07XG4gIHZhciB0YWogPSB0YWdzWG1sQXJyYXkuam9pbihcInxcIik7XG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiKD86KDwoPzpcIi5jb25jYXQodGFqLCBcIilbXj5dKj4pKFtePD5dKik8Lyg/OlwiKS5jb25jYXQodGFqLCBcIik+KXwoPCg/OlwiKS5jb25jYXQodGFqLCBcIilbXj5dKi8+KVwiKSwgXCJnXCIpO1xuICByZXMubWF0Y2hlcyA9IHByZWdNYXRjaEFsbChyZWdleHAsIHJlcy5jb250ZW50KTtcbiAgcmV0dXJuIHJlcztcbn07Il0sIm5hbWVzIjpbIl9yZXF1aXJlIiwicmVxdWlyZSIsInByZWdNYXRjaEFsbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ4bWxNYXRjaGVyIiwiY29udGVudCIsInRhZ3NYbWxBcnJheSIsInJlcyIsInRhaiIsImpvaW4iLCJyZWdleHAiLCJSZWdFeHAiLCJjb25jYXQiLCJtYXRjaGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/xml-templater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-templater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"), wordToUtf8 = _require.wordToUtf8, convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(ssr)/./node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(ssr)/./node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(ssr)/./node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(ssr)/./node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n    var matcher = xmlMatcher(content, tagsXmlArray);\n    var result = matcher.matches.map(function(match) {\n        return match.array[2];\n    });\n    return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/ function() {\n    function XmlTemplater(content, options) {\n        var _this = this;\n        _classCallCheck(this, XmlTemplater);\n        this.cachedParsers = {};\n        this.content = content;\n        Object.keys(options).forEach(function(key) {\n            _this[key] = options[key];\n        });\n        this.setModules({\n            inspect: {\n                filePath: options.filePath\n            }\n        });\n    }\n    return _createClass(XmlTemplater, [\n        {\n            key: \"resolveTags\",\n            value: function resolveTags(tags) {\n                var _this2 = this;\n                this.tags = tags;\n                var options = this.getOptions();\n                var filePath = this.filePath;\n                options.scopeManager = this.scopeManager;\n                options.resolve = resolve;\n                var errors = [];\n                return Promise.all(this.modules.map(function(module1) {\n                    return Promise.resolve(module1.preResolve(options))[\"catch\"](function(e) {\n                        errors.push(e);\n                    });\n                })).then(function() {\n                    if (errors.length !== 0) {\n                        throw errors;\n                    }\n                    return resolve(options).then(function(_ref) {\n                        var resolved = _ref.resolved, errors = _ref.errors;\n                        errors = errors.map(function(error) {\n                            // If a string is thrown, convert it to a real Error\n                            if (!(error instanceof Error)) {\n                                error = new Error(error);\n                            }\n                            // error properties might not be defined if some foreign error\n                            // (unhandled error not thrown by docxtemplater willingly) is\n                            // thrown.\n                            error.properties = error.properties || {};\n                            error.properties.file = filePath;\n                            return error;\n                        });\n                        if (errors.length !== 0) {\n                            throw errors;\n                        }\n                        return Promise.all(resolved).then(function(resolved) {\n                            options.scopeManager.root.finishedResolving = true;\n                            options.scopeManager.resolved = resolved;\n                            _this2.setModules({\n                                inspect: {\n                                    resolved: resolved,\n                                    filePath: filePath\n                                }\n                            });\n                            return resolved;\n                        });\n                    });\n                });\n            }\n        },\n        {\n            key: \"getFullText\",\n            value: function getFullText() {\n                return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n            }\n        },\n        {\n            key: \"setModules\",\n            value: function setModules(obj) {\n                this.modules.forEach(function(module1) {\n                    module1.set(obj);\n                });\n            }\n        },\n        {\n            key: \"preparse\",\n            value: function preparse() {\n                this.allErrors = [];\n                this.xmllexed = Lexer.xmlparse(this.content, {\n                    text: this.fileTypeConfig.tagsXmlTextArray,\n                    other: this.fileTypeConfig.tagsXmlLexedArray\n                });\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        xmllexed: this.xmllexed\n                    }\n                });\n                var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType), lexed = _Lexer$parse.lexed, lexerErrors = _Lexer$parse.errors;\n                this.allErrors = this.allErrors.concat(lexerErrors);\n                this.lexed = lexed;\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        lexed: this.lexed\n                    }\n                });\n                var options = this.getOptions();\n                Parser.preparse(this.lexed, this.modules, options);\n            }\n        },\n        {\n            key: \"parse\",\n            value: function parse() {\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath\n                    }\n                });\n                var options = this.getOptions();\n                this.parsed = Parser.parse(this.lexed, this.modules, options);\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        parsed: this.parsed\n                    }\n                });\n                var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options), postparsed = _Parser$postparse.postparsed, postparsedErrors = _Parser$postparse.errors;\n                this.postparsed = postparsed;\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        postparsed: this.postparsed\n                    }\n                });\n                this.allErrors = this.allErrors.concat(postparsedErrors);\n                this.errorChecker(this.allErrors);\n                return this;\n            }\n        },\n        {\n            key: \"errorChecker\",\n            value: function errorChecker(errors) {\n                var _this3 = this;\n                errors.forEach(function(error) {\n                    // error properties might not be defined if some foreign\n                    // (unhandled error not thrown by docxtemplater willingly) is\n                    // thrown.\n                    error.properties = error.properties || {};\n                    error.properties.file = _this3.filePath;\n                });\n                this.modules.forEach(function(module1) {\n                    errors = module1.errorsTransformer(errors);\n                });\n            }\n        },\n        {\n            key: \"baseNullGetter\",\n            value: function baseNullGetter(part, sm) {\n                var _this4 = this;\n                var value = this.modules.reduce(function(value, module1) {\n                    if (value != null) {\n                        return value;\n                    }\n                    return module1.nullGetter(part, sm, _this4);\n                }, null);\n                if (value != null) {\n                    return value;\n                }\n                return this.nullGetter(part, sm);\n            }\n        },\n        {\n            key: \"getOptions\",\n            value: function getOptions() {\n                return {\n                    compiled: this.postparsed,\n                    cachedParsers: this.cachedParsers,\n                    tags: this.tags,\n                    modules: this.modules,\n                    parser: this.parser,\n                    contentType: this.contentType,\n                    relsType: this.relsType,\n                    baseNullGetter: this.baseNullGetter.bind(this),\n                    filePath: this.filePath,\n                    fileTypeConfig: this.fileTypeConfig,\n                    fileType: this.fileType,\n                    linebreaks: this.linebreaks\n                };\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(to) {\n                this.filePath = to;\n                var options = this.getOptions();\n                options.resolved = this.scopeManager.resolved;\n                options.scopeManager = this.scopeManager;\n                options.render = _render;\n                options.joinUncorrupt = joinUncorrupt;\n                var _render2 = _render(options), errors = _render2.errors, parts = _render2.parts;\n                if (errors.length > 0) {\n                    this.allErrors = errors;\n                    this.errorChecker(errors);\n                    return this;\n                }\n                this.content = postrender(parts, options);\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        content: this.content\n                    }\n                });\n                return this;\n            }\n        }\n    ]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxvQkFBb0JDLFdBQVUsR0FBSTtRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFzQztBQUFFO0FBQ3hKLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFVLGVBQWVOLFdBQVdPLEdBQUcsR0FBR1A7SUFBYTtBQUFFO0FBQzVVLFNBQVNRLGFBQWFmLFdBQVcsRUFBRWdCLFVBQVUsRUFBRUMsV0FBVztJQUFJLElBQUlELFlBQVlkLGtCQUFrQkYsWUFBWUgsU0FBUyxFQUFFbUI7SUFBYSxJQUFJQyxhQUFhZixrQkFBa0JGLGFBQWFpQjtJQUFjTixPQUFPQyxjQUFjLENBQUNaLGFBQWEsYUFBYTtRQUFFVSxVQUFVO0lB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QUFDLElBQUk7b0JBQzdDNUQsVUFBVSxJQUFJLENBQUNBLFFBQVE7b0JBQ3ZCdUIsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztvQkFDbkNlLFVBQVUsSUFBSSxDQUFDQSxRQUFRO29CQUN2QnVCLFlBQVksSUFBSSxDQUFDQSxVQUFVO2dCQUM3QjtZQUNGO1FBQ0Y7UUFBRztZQUNEeEcsS0FBSztZQUNMNEMsT0FBTyxTQUFTNkQsT0FBT0MsRUFBRTtnQkFDdkIsSUFBSSxDQUFDL0QsUUFBUSxHQUFHK0Q7Z0JBQ2hCLElBQUl0RSxVQUFVLElBQUksQ0FBQ1ksVUFBVTtnQkFDN0JaLFFBQVFzQixRQUFRLEdBQUcsSUFBSSxDQUFDVCxZQUFZLENBQUNTLFFBQVE7Z0JBQzdDdEIsUUFBUWEsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtnQkFDeENiLFFBQVFxRSxNQUFNLEdBQUd0RjtnQkFDakJpQixRQUFRZCxhQUFhLEdBQUdBO2dCQUN4QixJQUFJcUYsV0FBV3hGLFFBQVFpQixVQUNyQmMsU0FBU3lELFNBQVN6RCxNQUFNLEVBQ3hCMEQsUUFBUUQsU0FBU0MsS0FBSztnQkFDeEIsSUFBSTFELE9BQU8xRCxNQUFNLEdBQUcsR0FBRztvQkFDckIsSUFBSSxDQUFDK0UsU0FBUyxHQUFHckI7b0JBQ2pCLElBQUksQ0FBQ3dDLFlBQVksQ0FBQ3hDO29CQUNsQixPQUFPLElBQUk7Z0JBQ2I7Z0JBQ0EsSUFBSSxDQUFDMUIsT0FBTyxHQUFHSixXQUFXd0YsT0FBT3hFO2dCQUNqQyxJQUFJLENBQUNLLFVBQVUsQ0FBQztvQkFDZEMsU0FBUzt3QkFDUEMsVUFBVSxJQUFJLENBQUNBLFFBQVE7d0JBQ3ZCbkIsU0FBUyxJQUFJLENBQUNBLE9BQU87b0JBQ3ZCO2dCQUNGO2dCQUNBLE9BQU8sSUFBSTtZQUNiO1FBQ0Y7S0FBRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkLXBsYW5uZXItZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcz85MWY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICB3b3JkVG9VdGY4ID0gX3JlcXVpcmUud29yZFRvVXRmOCxcbiAgY29udmVydFNwYWNlcyA9IF9yZXF1aXJlLmNvbnZlcnRTcGFjZXM7XG52YXIgeG1sTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3htbC1tYXRjaGVyLmpzXCIpO1xudmFyIExleGVyID0gcmVxdWlyZShcIi4vbGV4ZXIuanNcIik7XG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2VyLmpzXCIpO1xudmFyIF9yZW5kZXIgPSByZXF1aXJlKFwiLi9yZW5kZXIuanNcIik7XG52YXIgcG9zdHJlbmRlciA9IHJlcXVpcmUoXCIuL3Bvc3RyZW5kZXIuanNcIik7XG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoXCIuL3Jlc29sdmUuanNcIik7XG52YXIgam9pblVuY29ycnVwdCA9IHJlcXVpcmUoXCIuL2pvaW4tdW5jb3JydXB0LmpzXCIpO1xuZnVuY3Rpb24gX2dldEZ1bGxUZXh0KGNvbnRlbnQsIHRhZ3NYbWxBcnJheSkge1xuICB2YXIgbWF0Y2hlciA9IHhtbE1hdGNoZXIoY29udGVudCwgdGFnc1htbEFycmF5KTtcbiAgdmFyIHJlc3VsdCA9IG1hdGNoZXIubWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLmFycmF5WzJdO1xuICB9KTtcbiAgcmV0dXJuIHdvcmRUb1V0ZjgoY29udmVydFNwYWNlcyhyZXN1bHQuam9pbihcIlwiKSkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYbWxUZW1wbGF0ZXIoY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhtbFRlbXBsYXRlcik7XG4gICAgdGhpcy5jYWNoZWRQYXJzZXJzID0ge307XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF90aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfSk7XG4gICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgZmlsZVBhdGg6IG9wdGlvbnMuZmlsZVBhdGhcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFhtbFRlbXBsYXRlciwgW3tcbiAgICBrZXk6IFwicmVzb2x2ZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZVRhZ3ModGFncykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHZhciBmaWxlUGF0aCA9IHRoaXMuZmlsZVBhdGg7XG4gICAgICBvcHRpb25zLnNjb3BlTWFuYWdlciA9IHRoaXMuc2NvcGVNYW5hZ2VyO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGUucHJlUmVzb2x2ZShvcHRpb25zKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUob3B0aW9ucykudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWYucmVzb2x2ZWQsXG4gICAgICAgICAgICBlcnJvcnMgPSBfcmVmLmVycm9ycztcbiAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgYSBzdHJpbmcgaXMgdGhyb3duLCBjb252ZXJ0IGl0IHRvIGEgcmVhbCBFcnJvclxuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXJyb3IgcHJvcGVydGllcyBtaWdodCBub3QgYmUgZGVmaW5lZCBpZiBzb21lIGZvcmVpZ24gZXJyb3JcbiAgICAgICAgICAgIC8vICh1bmhhbmRsZWQgZXJyb3Igbm90IHRocm93biBieSBkb2N4dGVtcGxhdGVyIHdpbGxpbmdseSkgaXNcbiAgICAgICAgICAgIC8vIHRocm93bi5cbiAgICAgICAgICAgIGVycm9yLnByb3BlcnRpZXMgPSBlcnJvci5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gZmlsZVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmVkKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIucm9vdC5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlTWFuYWdlci5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgX3RoaXMyLnNldE1vZHVsZXMoe1xuICAgICAgICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlUGF0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFRleHQoKSB7XG4gICAgICByZXR1cm4gX2dldEZ1bGxUZXh0KHRoaXMuY29udGVudCwgdGhpcy5maWxlVHlwZUNvbmZpZy50YWdzWG1sVGV4dEFycmF5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVzKG9iaikge1xuICAgICAgdGhpcy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICBtb2R1bGUuc2V0KG9iaik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UoKSB7XG4gICAgICB0aGlzLmFsbEVycm9ycyA9IFtdO1xuICAgICAgdGhpcy54bWxsZXhlZCA9IExleGVyLnhtbHBhcnNlKHRoaXMuY29udGVudCwge1xuICAgICAgICB0ZXh0OiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxUZXh0QXJyYXksXG4gICAgICAgIG90aGVyOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxMZXhlZEFycmF5XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICB4bWxsZXhlZDogdGhpcy54bWxsZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfTGV4ZXIkcGFyc2UgPSBMZXhlci5wYXJzZSh0aGlzLnhtbGxleGVkLCB0aGlzLmRlbGltaXRlcnMsIHRoaXMuc3ludGF4LCB0aGlzLmZpbGVUeXBlKSxcbiAgICAgICAgbGV4ZWQgPSBfTGV4ZXIkcGFyc2UubGV4ZWQsXG4gICAgICAgIGxleGVyRXJyb3JzID0gX0xleGVyJHBhcnNlLmVycm9ycztcbiAgICAgIHRoaXMuYWxsRXJyb3JzID0gdGhpcy5hbGxFcnJvcnMuY29uY2F0KGxleGVyRXJyb3JzKTtcbiAgICAgIHRoaXMubGV4ZWQgPSBsZXhlZDtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBsZXhlZDogdGhpcy5sZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICBQYXJzZXIucHJlcGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGhcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdGhpcy5wYXJzZWQgPSBQYXJzZXIucGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBwYXJzZWQ6IHRoaXMucGFyc2VkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9QYXJzZXIkcG9zdHBhcnNlID0gUGFyc2VyLnBvc3RwYXJzZSh0aGlzLnBhcnNlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKSxcbiAgICAgICAgcG9zdHBhcnNlZCA9IF9QYXJzZXIkcG9zdHBhcnNlLnBvc3RwYXJzZWQsXG4gICAgICAgIHBvc3RwYXJzZWRFcnJvcnMgPSBfUGFyc2VyJHBvc3RwYXJzZS5lcnJvcnM7XG4gICAgICB0aGlzLnBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIHBvc3RwYXJzZWQ6IHRoaXMucG9zdHBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWxsRXJyb3JzID0gdGhpcy5hbGxFcnJvcnMuY29uY2F0KHBvc3RwYXJzZWRFcnJvcnMpO1xuICAgICAgdGhpcy5lcnJvckNoZWNrZXIodGhpcy5hbGxFcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yQ2hlY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvckNoZWNrZXIoZXJyb3JzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBlcnJvciBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGlmIHNvbWUgZm9yZWlnblxuICAgICAgICAvLyAodW5oYW5kbGVkIGVycm9yIG5vdCB0aHJvd24gYnkgZG9jeHRlbXBsYXRlciB3aWxsaW5nbHkpIGlzXG4gICAgICAgIC8vIHRocm93bi5cbiAgICAgICAgZXJyb3IucHJvcGVydGllcyA9IGVycm9yLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGVycm9yLnByb3BlcnRpZXMuZmlsZSA9IF90aGlzMy5maWxlUGF0aDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICBlcnJvcnMgPSBtb2R1bGUuZXJyb3JzVHJhbnNmb3JtZXIoZXJyb3JzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYXNlTnVsbEdldHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbW9kdWxlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUubnVsbEdldHRlcihwYXJ0LCBzbSwgX3RoaXM0KTtcbiAgICAgIH0sIG51bGwpO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubnVsbEdldHRlcihwYXJ0LCBzbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGVkOiB0aGlzLnBvc3RwYXJzZWQsXG4gICAgICAgIGNhY2hlZFBhcnNlcnM6IHRoaXMuY2FjaGVkUGFyc2VycyxcbiAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICBtb2R1bGVzOiB0aGlzLm1vZHVsZXMsXG4gICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmNvbnRlbnRUeXBlLFxuICAgICAgICByZWxzVHlwZTogdGhpcy5yZWxzVHlwZSxcbiAgICAgICAgYmFzZU51bGxHZXR0ZXI6IHRoaXMuYmFzZU51bGxHZXR0ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgIGZpbGVUeXBlQ29uZmlnOiB0aGlzLmZpbGVUeXBlQ29uZmlnLFxuICAgICAgICBmaWxlVHlwZTogdGhpcy5maWxlVHlwZSxcbiAgICAgICAgbGluZWJyZWFrczogdGhpcy5saW5lYnJlYWtzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHRvKSB7XG4gICAgICB0aGlzLmZpbGVQYXRoID0gdG87XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlZCA9IHRoaXMuc2NvcGVNYW5hZ2VyLnJlc29sdmVkO1xuICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIgPSB0aGlzLnNjb3BlTWFuYWdlcjtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gX3JlbmRlcjtcbiAgICAgIG9wdGlvbnMuam9pblVuY29ycnVwdCA9IGpvaW5VbmNvcnJ1cHQ7XG4gICAgICB2YXIgX3JlbmRlcjIgPSBfcmVuZGVyKG9wdGlvbnMpLFxuICAgICAgICBlcnJvcnMgPSBfcmVuZGVyMi5lcnJvcnMsXG4gICAgICAgIHBhcnRzID0gX3JlbmRlcjIucGFydHM7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuZXJyb3JDaGVja2VyKGVycm9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50ID0gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwidCIsIl90b1ByaW1pdGl2ZSIsInIiLCJlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwid29yZFRvVXRmOCIsImNvbnZlcnRTcGFjZXMiLCJ4bWxNYXRjaGVyIiwiTGV4ZXIiLCJQYXJzZXIiLCJfcmVuZGVyIiwicG9zdHJlbmRlciIsInJlc29sdmUiLCJqb2luVW5jb3JydXB0IiwiX2dldEZ1bGxUZXh0IiwiY29udGVudCIsInRhZ3NYbWxBcnJheSIsIm1hdGNoZXIiLCJyZXN1bHQiLCJtYXRjaGVzIiwibWFwIiwibWF0Y2giLCJhcnJheSIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwiWG1sVGVtcGxhdGVyIiwib3B0aW9ucyIsIl90aGlzIiwiY2FjaGVkUGFyc2VycyIsImtleXMiLCJmb3JFYWNoIiwic2V0TW9kdWxlcyIsImluc3BlY3QiLCJmaWxlUGF0aCIsInZhbHVlIiwicmVzb2x2ZVRhZ3MiLCJ0YWdzIiwiX3RoaXMyIiwiZ2V0T3B0aW9ucyIsInNjb3BlTWFuYWdlciIsImVycm9ycyIsIlByb21pc2UiLCJhbGwiLCJtb2R1bGVzIiwicHJlUmVzb2x2ZSIsInB1c2giLCJ0aGVuIiwiX3JlZiIsInJlc29sdmVkIiwiZXJyb3IiLCJFcnJvciIsInByb3BlcnRpZXMiLCJmaWxlIiwicm9vdCIsImZpbmlzaGVkUmVzb2x2aW5nIiwiZ2V0RnVsbFRleHQiLCJmaWxlVHlwZUNvbmZpZyIsInRhZ3NYbWxUZXh0QXJyYXkiLCJvYmoiLCJzZXQiLCJwcmVwYXJzZSIsImFsbEVycm9ycyIsInhtbGxleGVkIiwieG1scGFyc2UiLCJ0ZXh0Iiwib3RoZXIiLCJ0YWdzWG1sTGV4ZWRBcnJheSIsIl9MZXhlciRwYXJzZSIsInBhcnNlIiwiZGVsaW1pdGVycyIsInN5bnRheCIsImZpbGVUeXBlIiwibGV4ZWQiLCJsZXhlckVycm9ycyIsImNvbmNhdCIsInBhcnNlZCIsIl9QYXJzZXIkcG9zdHBhcnNlIiwicG9zdHBhcnNlIiwicG9zdHBhcnNlZCIsInBvc3RwYXJzZWRFcnJvcnMiLCJlcnJvckNoZWNrZXIiLCJfdGhpczMiLCJlcnJvcnNUcmFuc2Zvcm1lciIsImJhc2VOdWxsR2V0dGVyIiwicGFydCIsInNtIiwiX3RoaXM0IiwicmVkdWNlIiwibnVsbEdldHRlciIsImNvbXBpbGVkIiwicGFyc2VyIiwiY29udGVudFR5cGUiLCJyZWxzVHlwZSIsImJpbmQiLCJsaW5lYnJlYWtzIiwicmVuZGVyIiwidG8iLCJfcmVuZGVyMiIsInBhcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;